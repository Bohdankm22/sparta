\htmlhr

\newcommand{\tp}[1]{\mathit{typeof}}
\newcommand{\Fix}[1]{\textbf{[[}{\color{red} #1}\textbf{]]}}


\chapter{Intent Checker\label{intent-checker}}

Android intents are the standard inter-component communication
mechanism in Android.  They are used for communication within an app,
among apps, and with the Android system.  An Android component can
send or broadcast intents and can register interest in receiving
intents.

Intents can be seen as messages exchanged through components; the
payloads of these messages are maps.  Sensitive data can flow in and
out of intent objects.  Consequently, to prevent manifestations of
forbidden flows, \theFlowChecker{} needs to be aware of the
information flow types associated to the various data elements
encapsulated in intent maps.

\TheFlowChecker{} provides support to
ensure that the type of data stored within an intent conforms to the
declared type of the intent, even in the presence of implicit
invocation via intents.  It verifies that for any sending intent
method call and any receiving intent method declaration that can be
invoked by the call site, the intent argument of the caller is
compatible with that of the corresponding callee.  In addition, the
checker verifies that the intent payload is used consistently at each
site.

For simplicity in this manual, we abstract all methods that send intents as the
method sendIntent, and all methods that receive an intent as the method call
onReceive. The methods supported are listed below:

\begin{itemize}
\item
onBind()
\item
onRebind()
\item
onStart()
\item
onStartCommand()
\item
onTaskRemoved()
\item
onUnBind()
\item
onReceive()
\item
peekService()
\item
getIntent()
\end{itemize}
%\todo{Need a complete list of all methods currently supported.}



\section{Component map}
To precisely analyze the types of data sent through intents, our analysis
requires sendIntent calls to be matched to the declarations of the onReceive
methods they implicitly invoke. A sendIntent call may be paired
with more than one onReceive declaration. One such pair indicates that 
components a and b, possibly from different apps, may communicate through 
intents. 

A component map is used to represent the communication between components of an
application. A component map file expresses a 
component map, as a list of $\flow{\|sendIntent(intent)|}{\|onReceive|^*}$ pairs.
The \<intent> sent may consist of an \<Action>, set of
\<Categories> and a \<Data>.
The set of pairs of communicating components is
conservative, that is it includes all possible pairs of methods that might
communicate. In order to compute these pairs, all apps that might be
communicating are analyzed using the tools \code{APKParser}, \code{Dare}, and
\code{Epicc}. The procedure to generate a component map is detailed in section
\ref{component-map-generation}.


\subsection{Syntax of a component map file}
Each line of a component map specifies the inter-component communication of
an application. For example, \code{ActivityA(Action1) -> com.package.ActivityB} 
implies that every implicit intent sent from ActivityA where the String value of
the action is \code{Action1} will
be sent to the component whose fully qualified class name is com.package.ActivityB.
%\todo{The semantic section should talk about the action, too}
%\todo{The syntax isn't clear.  Must ActivityB be the fully qualified class name of the activity?
%Is the action the name of the constant that represents that action or the string value?} 

%\todo{Mention that this can be generated and explain how it is generated.  Be sure to cite the tools used}

\section{IntentMap and Extra annotations}
An Intent contains a map from string keys to arbitrary values. Data can be added
to this map by the sender with \<intent.putExtra("key",value)> and then
retrieved by the receiver with \<intent.getExtra("key",default)>. 
The \<@IntentMap> represents the types
of the key/value mappings that are permitted to be accessed. The Intent object
may contain more mappings than stated in its type, but those other keys may not
be accessed. The intent object is not required to contain all the given
mappings, but if a key is present and accessed 
then the type of the corresponding value must be consistent with the 
stated type. 

An \<@IntentMap> annotation contains a set of \<@Extra> annotations. An
\<@Extra> annotation contains a key K and a type T. This means that the key K 
maps to a value of type T. In the case of the information flow system, the type
T is a pair of set of sources and set of sinks which constrains the possible 
flows. \todo{Please check if this paragraph is clear. -Paulo}
%\todo{This last sentence isn't clear,
%What do you mean by represents data?  How is that different for the IFC than other checkers?}
%\todo{This paragraph says that an @Extra has a key K and a type T, but in reality annotation has a key key 
%and a source and a sink.  This is confusing.  Either discuss the semantics of the types, using key K and type T 
%without using the concrete annotations or discuss the semantics using the actual syntax. }
%\todo{Where are the sub typing rules?}
%\todo{How do you annotation receivers or senders that are in other apps?}

\subsection{Subtyping and intent map access rules}

\subsubsection{Subtyping}
Intent type \<T1> is a subtype of intent type \<T2> if the key set of 
\<T2> is a subset of the key set of \<T1> and, for each key \<k> in both 
\<T1> and \<T2>, \<k> is mapped to the exact same type, that is, 
\<T1[k]> = \<T2[k]>. The use of a subtyping requirement \<T1[k]> <: \<T2[k]> 
instead of equality \<T1[k]> = \<T2[k]> would lead to unsoundness 
in the presence of aliasing.


\subsubsection{Copyable}
Copyable is a subtyping-like relationship with the weaker requirement: 
\<T1[k]> <: \<T2[k]>. It may be used only when aliasing is not possible, which
occurs when onReceive is invoked by the Android system.

\subsubsection{putExtra and getExtra}
Consider the following annotated intent and strings:

\<@IntentMap(@Extra(key="key",source=({A,B}),sink=({C,D})))
	Intent intent;>


\<@Source({A}) @Sink({C,D}) String val1 = getValue();>


\<@Source({A,B,C}) @Sink({C,D}) String val2 = getValue();>



%
Calls intent.putExtra(key,value) type-check if:
%
\begin{itemize}
\item
 key is in an \<@Extra> in the intent's \<@IntentMap> annotation.
\item
 value is a subtype of the type of the \<@Extra> annotation with key in the
	intent's \<@IntentMap> annotation. 


\end{itemize}

%\todo{It would be better to have an example annotation before discussing the individual rules} 	
	
\begin{itemize}
\item
intent.putExtra("key",\<val1>) is allowed 
%\todo{It's confusing to have annotations in the method call.  It would be better to should the declaration 
%of value with the annotations and then show it used in  a put extra call}
\item
intent.putExtra("key",\<val2>) is not allowed

\end{itemize}


The return type of intent.getExtra(key,defaultValue) is the type of the \<@Extra>
annotation with key in the intent's \<@IntentMap> annotation.
%

Calls intent.getExtra(key,defaultValue) type-check if:
\begin{itemize}
\item
key is in an \<@Extra> in the intent's \<@IntentMap> annotation.
\end{itemize}
		
\begin{itemize}
\item
	\<@Source({A,B}) @Sink({C,D})> String val1 = intent.getExtra("key", defaultValue) is allowed. 
\item
    \<@Source({A,B}) @Sink({C,D})> String val2 = intent.getExtra("new\_key",
	defaultValue) is not allowed. 
\end{itemize}

\subsection{Type-checking sendIntent()}
An \<@IntentMap(A)> is copyable to \<@IntentMap(B)> if every key in the set of
@Extra in \<@IntentMap(A)> can be found in the set of \<@Extra> in
\<@IntentMap(B)> and the type of value of the \<@Extra> entry with key \<K> in
\<@IntentMap(B)> is a subtype of the type of value with key \<K> in
\<@IntentMap(A)>.


A call sendIntent() is interpreted by the Android system as a call to one or
more onReceive methods. A sendIntent call type-checks if its intent argument is
copyable to the formal parameter of each corresponding onReceive methods.
%\todo{Why is it copyable and not a subtype? Give the reasoning behind the rules.}


%%  LocalWords:  sendIntent onReceive typeof callee
