\htmlhr

\newcommand{\tp}[1]{\mathit{typeof}}
\newcommand{\Fix}[1]{\textbf{[[}{\color{red} #1}\textbf{]]}}
\newcommand{\theIntentChecker}{the Intent Checker\xspace}
\newcommand{\TheIntentChecker}{The Intent Checker\xspace}
\newcommand{\sendIntent}{sendIntent}
\newcommand{\onReceive}{onReceive}


\chapter{Intent Checker\label{intent-checker}}

This chapter describes \theIntentChecker{}, an extension to \theFlowChecker{},
which analyzes the information flows across communicating components.

Android intents are the standard inter-component communication
mechanism in Android.  They are used for communication within an app,
among apps, and with the Android system. An Android component can
send or broadcast intents and can register interest in receiving
intents.

Intents can be seen as messages exchanged through components; the
payloads of these messages are maps. Sensitive data can flow in and
out of intent objects. Consequently, to detect forbidden flows derived
from inter-component communication, \theFlowChecker{} must correctly identify
the information flow types of the values encapsulated in intent maps.

\TheIntentChecker{} use new type annotations for intent
declarations, providing support to \theFlowChecker{} in order to
ensure that the type of data stored within an intent conforms to the
declared type of the intent. It verifies that for any sending intent method
call and its matching receiving intent method declarations,
the intent argument of the caller is compatible with that of the corresponding
callee. In addition, the checker verifies that the intent payload is used 
consistently at each site.

For simplicity in this manual, we abstract all methods that send intents as the
method call \sendIntent{}, and all methods that receive an intent as the method
declaration \onReceive{}.

\section{Component map}
A component map contains information about the inter-component communication of
an app. A component map file is expressed as a list of \sendIntent{} method 
location
and receiver component pairs: \flow{\sendIntent{}Location*}{ReceiverComponent*}.

\subsection{Semantics of a component map}
To precisely analyze the types of data sent through intents, our
analysis requires \sendIntent{} calls to be matched to the declarations of the
\onReceive{} methods they implicitly invoke. A \sendIntent{} call may be paired
with more than one \onReceive{} declaration. One such pair indicates that
both components, possibly from different apps, may communicate through
intents. The set of pairs of communicating components is
conservative, that is it includes all possible pairs of methods that might
communicate. In order to compute these pairs, all apps that might be
communicating are analyzed using the tools \code{APKParser}, \code{Dare}, and
\code{Epicc}. The procedure to generate a component map is detailed in section
\ref{component-map-generation}.


\subsection{Syntax of a component map file}
Each line of a component map file specifies a set of receiver components for 
every intent sent from a particular method in the app.

For example, the following line

\code{com.package.ActivityA.foo() -> com.package.ActivityB,
com.package.ActivityC} 

implies that every intent sent in the method \code{foo()} from 
\code{ActivityA} will be received by the components whose fully qualified class 
names are \code{com.package.ActivityB} and \code{com.package.ActivityC}.

\subsection{Using a component map file}
To use a component map file when invoking \theIntentChecker{} from the command
line you can pass the option to ant:

\code{ant -DcomponentMap=mycomponentmapfile check-intent}

If the component is named \code{component-map} and is located the top level app
directory, the ant target will use it automatically.

\section{IntentMap and Extra annotations}
An intent contains a map from string keys to arbitrary values. Consider an
intent variable declared as \<i>. Data can be added to the map of \<i> by
the sender component with \<i.putExtra("key",val)> and then retrieved by the
receiver component with \<i.getExtra("key",default)>. 
An intent type is a map type: that is, it is a sound approximation to the keys
that may be in the intent object at run time and to the type of the values that
those keys may map to.

\subsection{Syntax}
The type qualifier \<@IntentMap> on an intent variable's type indicates the 
types of the key/value mappings that are permitted to be accessed.
An \<@IntentMap> type qualifier contains a set of \<@Extra> type qualifiers. An
\<@Extra> type qualifier contains a key \<K>, a source type \<SOURCE>, and a 
sink type \<SINK>. This means that the key \<K> maps to a value of source type 
\<SOURCE> and sink type \<SINK>.

\subsection{Semantics}
If variable \<i> is declared to have an intent type \<T>, then two facts must be
true. (1) The value referenced by variable \<i> contains no more keys than are
listed in \<T>. That is, the keys of the value of \<i> is a subset of \<T>'s
keys. It is
permitted for the run-time value of variable \<i> to have fewer keys than those
permitted by its type. (2) For any key \<k> that is a key in the run-time value
of \<i>, the value mapped by \<k> in the value has the type mapped by \<k> in
\<T>. This can be more concisely expressed as $\forall k.i[k] <: T[k]$. As permitted by
object-oriented typing, the run-time class of \<i[k]> may be a subtype of \<T>.

As an example, consider the declaration and statements below

\begin{Verbatim}
@IntentMap({@Extra(key = "k1", source = {FILESYSTEM}, sink = {INTERNET}),
            @Extra(key = "k2", source = {FILESYSTEM}, sink = {DISPLAY})}) 
    Intent i = new Intent();

void fillIntent(Intent i) {
    i.putExtra("k1", getFile());     // Legal
    i.putExtra("k2", getLocation()); // Violation!
    i.putExtra("k3", getFile());     // Violation!
}

@Source(FILESYSTEM) @Sink(INTERNET) File getPicture() {...}
@Source(ACCESS_FINE_LOCATION) @Sink(INTERNET) String getLocation() {...}

\end{Verbatim}

\noindent
The type of variable \<i> indicates that this object must contain up to two
elements in its map which
will be accessed, one with key \<"k1">, source type \<FILESYSTEM>, and sink type
\<INTERNET>, and another with key \<"k2">, source type \<FILESYSTEM>, and sink
type \<DISPLAY>. This object may contain more elements but they cannot be
accessed. The statements below the declaration shows that it is only valid to
invoke putExtra if the the value passed as argument is a subtype of the declared
type for the corresponding key.


For local variables the type qualifiers \<@IntentMap> and \<@Extra> must be used
as cast types. Below is the \<i> variable in the example above declared as
a local variable

\begin{Verbatim}
void foo() {
    Intent i = (@IntentMap({
            @Extra(key = "k1", source = {FILESYSTEM}, sink = {INTERNET}),
            @Extra(key = "k2", source = {FILESYSTEM}, sink = {DISPLAY})}) Intent)
                new Intent();
}
\end{Verbatim}



\section{Subtyping, sending an intent, and intent map access rules}

\subsection{Subtyping}
Intent type \<T1> is a subtype of intent type \<T2> if the key set of 
\<T2> is a subset of the key set of \<T1> and, for each key \<k> in both 
\<T1> and \<T2>, \<k> is mapped to the exact same type, that is, 
\<T1[k]> = \<T2[k]>. The use of a subtyping requirement \<T1[k]> <: \<T2[k]> 
instead of equality \<T1[k]> = \<T2[k]> would lead to unsoundness 
in the presence of aliasing.


\subsection{Copyable and \sendIntent{} calls}
Copyable is a subtyping-like relationship with the weaker requirement: 
\<T1[k]> <: \<T2[k]> instead of \<T1[k]> = \<T2[k]>.
It may be used only when aliasing is not possible, which
occurs when \onReceive{} is invoked by the Android system. A call to
\sendIntent{} is interpreted by the Android system as a call to one or more
\onReceive{} methods. A \sendIntent{} call type-checks if its intent argument is
copyable to the formal parameter of each corresponding \onReceive{} methods.
This is sound because the Android system passes a copy of the intent argument to
\onReceive{}, so aliasing is not a concern.

\subsection{putExtra and getExtra calls}

Consider the following annotated intent and strings:

\begin{Verbatim}
@IntentMap(@Extra(key="key",source=({A,B}),sink=({C,D}))) Intent intent;
@Source({A}) @Sink({C,D}) String val1 = getValue();
@Source({A,B,C}) @Sink({C,D}) String val2 = getValue2();
\end{Verbatim}

Calls \<intent.putExtra("key",val)> type-check if:
\begin{itemize}
\item
 \<"key"> is in an \<@Extra> in the intent's \<@IntentMap> annotation.
\item
 \<val>'s type is a subtype of the type of the \<@Extra> annotation with 
 \<"key"> in the intent's \<@IntentMap> annotation. 
\end{itemize}

\noindent
\<intent.putExtra("key",val1) is allowed>

\noindent
\<intent.putExtra("key",val2) is not allowed>

\vspace{1mm}
The return type of \<intent.getExtra("key",defaultValue)> is the type of the
\<@Extra> annotation with key in the intent's \<@IntentMap> annotation.

Calls \<intent.getExtra("key",defaultValue)> type-check if:
\begin{itemize}
\item
\<"key"> is in an \<@Extra> in the intent's \<@IntentMap> annotation.

\end{itemize}

\noindent
\<@Source({A,B}) @Sink({C,D}) String val1 = intent.getExtra("key",
    defaultValue) is allowed.>

\noindent
\<@Source({A,B}) @Sink({C,D}) String val2 = intent.getExtra("new\_key",
    defaultValue) is not allowed.>


\subsection{Declarations of \onReceive{}}
The normal Java overriding rules do not apply to declarations of \onReceive{}. The
type of the formal parameter of \onReceive{} is not restricted by the type of the
parameter in the overridden declaration. This is allowable because by convention
\onReceive{} is never called directly but rather is only called by the Android
system. The type checker prohibits direct calls to \onReceive{} methods.

\onReceive{} methods can be overridden and their \<Intent> parameter must be
annotated with an \<@IntentMap> type. An example of the declaration of the 
\onReceive{} method for activities, \<setIntent()>, is annotated below:

\begin{Verbatim}
@Override
public void setIntent( @IntentMap({
        @Extra(key = "k5", source = {ACCESS_FINE_LOCATION }, sink = {})})
        Intent newIntent) {
    super.setIntent(newIntent);
}
\end{Verbatim}

%%  LocalWords:  \sendIntent{} \onReceive{} typeof callee
