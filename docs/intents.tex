\htmlhr

\newcommand{\tp}[1]{\mathit{typeof}}
\newcommand{\Fix}[1]{\textbf{[[}{\color{red} #1}\textbf{]]}}


\chapter{Intent Checker\label{intent-checker}}

Android intents are the standard inter-component communication
mechanism in Android.  They are used for communication within an app,
among apps, and with the Android system.  An Android component can
send or broadcast intents and can register interest in receiving
intents.

Intents can be seen as messages exchanged through components; the
payloads of these messages are maps.  Sensitive data can flow in and
out of intent objects.  Consequently, to prevent manifestations of
forbidden flows, \theFlowChecker{} needs to be aware of the
information flow types associated to the various data elements
encapsulated in intent maps.

\TheFlowChecker{} provides support to
ensure that the type of data stored within an intent conforms to the
declared type of the intent, even in the presence of implicit
invocation via intents.  It verifies that for any sending intent
method call and any receiving intent method declaration that can be
invoked by the call site, the intent argument of the caller is
compatible with that of the corresponding callee.  In addition, the
checker verifies that the intent payload is used consistently at each
site.

For simplicity in this manual, we abstract all methods that send intents as the
method sendIntent, and all methods that receive an intent as the method call
onReceive. The methods supported are listed below:

\begin{itemize}
\item
onBind()
\item
onRebind()
\item
onStart()
\item
onStartCommand()
\item
onTaskRemoved()
\item
onUnBind()
\item
onReceive()
\item
peekService()
\item
getIntent()
\end{itemize}
%\todo{Need a complete list of all methods currently supported.}



\section{Component map}
To precisely analyze the types of data sent through intents, our analysis
requires sendIntent calls to be matched to the declarations of the onReceive
methods they implicitly invoke. A sendIntent call may be paired
with more than one onReceive declaration. One such pair indicates that 
components a and b, possibly from different apps, may communicate through 
intents. 

A component map is used to represent the communication between components of an
application. A component map file expresses a 
component map, as a list of $\flow{\|sendIntent(intent)|}{\|onReceive|^*}$ pairs.
The \<intent> being may consist of an \<Action>, set of
\<Categories> and a \<Data>.
The set of pairs of communicating components is
conservative, that is it includes all possible pairs of methods that might
communicate. In order to compute these pairs, all apps that might be
communicating are analyzed using the tools APKParser, Dare, and Epicc. The
procedure to generate a component map is detailed in section
\ref{component-map-generation}.


\subsection{Syntax of a component map file}
Each line of a component map specifies the inter-component communication of
an application. For example, \code{ActivityA(Action1) -> com.package.ActivityB} 
implies that every implicit intent sent from ActivityA where the String value of
the action is \code{Action1} will
be sent to the component whose fully qualified class name is com.package.ActivityB.
%\todo{The semantic section should talk about the action, too}
%\todo{The syntax isn't clear.  Must ActivityB be the fully qualified class name of the activity?
%Is the action the name of the constant that represents that action or the string value?} 

%\todo{Mention that this can be generated and explain how it is generated.  Be sure to cite the tools used}

\section{IntentMap and Extra annotations}
An Intent contains a map from string keys to arbitrary values. Data can be added
to this map by the sender with \<intent.putExtra("key",value)> and then
retrieved by the receiver with \<intent.getExtra("key",default)>. 
The \<@IntentMap> represents the types
of the key/value mappings that are permitted to be accessed. The Intent object
may contain more mappings than stated in its type, but those other keys may not
be accessed. The Intent object is not required to contain all the given
mappings, but if a key is present \todo{where is the key present in the type or in the intent?}, then the type of the corresponding value must
be consistent with the stated type. 

An \<@IntentMap> annotation contains a set of \<@Extra> annotations. An
\<@Extra> annotation contains a key K and a type T. This means that the key K 
maps to a value of type T. In the case of the information flow system, the type T
represents data and constrains its possible flows. \todo{This last sentence isn't clear,
What do you mean by represents data?  How is that different for the IFC than other checkers?}
\todo{This paragraph says that an @Extra has a key K and a type T, but in reality annotation has a key key 
and a source and a sink.  This is confusing.  Either discuss the semantics of the types, using key K and type T 
without using the concrete annotations or discuss the semantics using the actual syntax. }
\todo{Where are the sub typing rules?}
\todo{How do you annotation receivers or senders that are in other apps?}

\subsection{putExtra and getExtra rules}

\subsubsection{putExtra}
Calls intent.putExtra(key,value) type-check if:
\begin{itemize}
\item
 key is in an \<@Extra> in the intent's \<@IntentMap> annotation.
\item
 value is a subtype of the type of the \<@Extra> annotation with key in the
	intent's \<@IntentMap> annotation. 


\end{itemize}
For example:

\<@IntentMap(@Extra(key="key",source=({A,B}),sink=({C,D})))
	Intent intent>
\todo{It would be better to have an example annotation before discussing the individual rules} 	
	
\begin{itemize}
\item
intent.putExtra("key",\<@Source({A}) @Sink({C,E})> obj value) is allowed 
\todo{It's confusing to have annotations in the method call.  It would be better to should the declaration 
of value with the annotations and then show it used in  a put extra call}
\todo{I don't think this example is correct, because value isn't allowed to flow to sink D, 
but the type of key in the @Extra annotation allowed it.}
\item
intent.putExtra("key",\<@Source({A,B,E}) @Sink({C})> obj value) is not allowed

\end{itemize}

\subsubsection{getExtra}
The return type of intent.getExtra(key,defaultValue) is the type of the \<@Extra>
annotation with key in the intent's \<@IntentMap> annotation.
Calls intent.getExtra(key,defaultValue) type-check if:
\begin{itemize}
\item
key is in an \<@Extra> in the intent's \<@IntentMap> annotation.
\end{itemize}
For example:
		
\<@IntentMap(@Extra(key="key",source=({A,B}),sink=({C,D})))
		Intent getIntent()>
\begin{itemize}
\item
	Obj x = intent.getExtra("key", defaultValue) is allowed. 
	The type of x is \<@Source(A,B) @Sink(C,D) Obj>. 
	\todo{Don't say what the type is, show the declaration. and use a real Java type, not Obj.}
\item
	Obj x = intent.getExtra("key2", defaultValue) is not allowed.
\end{itemize}

\subsection{Type-checking sendIntent()}
An \<@IntentMap(A)> is copyable to \<@IntentMap(B)> if every key in the set of
@Extra in \<@IntentMap(A)> can be found in the set of \<@Extra> in
\<@IntentMap(B)> and the type of value of the \<@Extra> entry with key \<K> in
\<@IntentMap(B)> is a subtype of the type of value with key \<K> in
\<@IntentMap(A)>.


A call sendIntent() only type-checks if the sender's Intent type is copyable to
each possible receiver's Intent type according the component map. 
\todo{Why is it copyable and not a subtype? Give the reasoning behind the rules.}


%%  LocalWords:  sendIntent onReceive typeof callee
