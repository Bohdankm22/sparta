\htmlhr


\newcommand{\method}[1]{\paragraph{#1}}
\newcommand{\annomethod}[1]{\small{\texttt{#1}}\newline}
\chapter{Tutorial\label{tutorial}}

This chapter demonstrates how to annotate an existing app, ContactManger,
 where the annotator did not develop the app and the app is assumed to be benign.
   ContactManger allows the user to view and create contacts that are associate 
   with different accounts.  


\section{Set up}
Download the ContactManager app here: \url{http://types.cs.washington.edu/sparta/tutorial/ContactManager.tgz}
Install the Information Flow Checker and set up ContactManger to use the Information Flow Checker. 
See \secref{sec:antsetup}  and \secref{sec:install} for instructions. Also, install the inference framework
see \secref{} for details.

Infer types, \<ant infer>.
Then, run the Information Flow Checker, \<ant check-flow-pp>, if the output is similar to 
the output shown below, then your setup is correct.  (You should get 33 warnings.)

\begin{Verbatim}
Buildfile: .../ContactManager/build.xml
...
check-flow-pp:
Compiling 4 source files to /Users/smillst/Downloads/ContactManager/bin/classes
javac 1.8.0-jsr308-1.8.2
.../ContactAdder.java:64: warning: [forbidden.flow]
    private @Source({}) @Sink({}) ArrayList<@Source({FlowPermission.ANY}) @Sink({FlowPermission.CONTENT_PROVIDER}) Integer> mContactEmailTypes;
                                            ^
  flow forbidden by flow-policy
  found:  { ANY  ->  CONTENT_PROVIDER }  Integer
  forbidden flows:
    ANY -> CONTENT_PROVIDER
\end{Verbatim} 

\section{Drafting a flow policy}

The Information Flow Checker outputs a file, \<sparta-out/forbiddenFlows.txt>, that lists all the flows
 it found in the app that are not allowed by the current flow policy.  For this app, 
 \<forbiddenFlows.txt> is shown below. 

\begin{Verbatim} 
# Flows currently forbidden
 ANY -> CONTENT_PROVIDER
 CONTENT_PROVIDER -> DISPLAY
 USER_INPUT -> WRITE_LOGS, CONTENT_PROVIDER
\end{Verbatim} 
Because this app does not yet have a flow policy, this file lists all the flows that the 
Information Flow Checker was able to detect.  This is not a complete list of flows in the program,
because the Information Flow Checker issued warnings, but it offers a good starting point 
for the flow policy.  Because some of the inserted annotations are too permissive, so of the forbidden
flows involve \perm{ANY}.  

Create a file named \<flow-policy> in the ContactManger directory.  Copy all the flows that   
do not flow to or from \perm{ANY}.  These flows should not be copied because 
they are too permissive.  So, for this app the initial flow policy is shown below.
\begin{Verbatim} 
 CONTENT_PROVIDER -> DISPLAY
 USER_INPUT -> WRITE_LOGS, CONTENT_PROVIDER
\end{Verbatim}

 Run the Information Flow Checker again.  (Because you named your flow policy 
\<flow-policy>, the Information Flow Checker will automatically read it.)  The Information Flow Checker should
now only report 17 warnings.  The \<forbiddenFlows.txt> file should also have changed as shown
below.

\begin{Verbatim}
# Flows currently forbidden
 ANY -> CONTENT_PROVIDER
\end{Verbatim}
 
 Since this flow contains \perm{ANY}, there is nothing to add 
 to the flow policy.  
 
Because \flow{USER\_INPUT}{CONTENT\_PROVIDER} and \flow{CONTENT\_PROVIDER}{DISPLAY} are legal flows,
  the Information Flow Checker reports a possible transitive flow, \flow{USER\_INPUT}{DISPLAY} see \secref{}. 
 
\begin{Verbatim}
warning: FlowPolicy: Found transitive flow
  [USER_INPUT]->[DISPLAY]
  Please add them to the flow policy
\end{Verbatim} 

Add  \flow{USER\_INPUT}{DISPLAY} to the flow policy.

\section{Correcting Annotations}
Inference sometimes inserts annotations that are correct, but too permissive.  
They use the \perm{ANY} instead of a more specific permission.  Because we did
not add any flow with \perm{ANY} to the flow policy, all uses of these types will 
issue a forbidden flow warning.  

Run the Information Flow Checker and filter for forbidden flows.

\begin{Verbatim}
ant check-flow -DcfOpts=-AmsgFilter=forbidden.flow
\end{Verbatim}

\begin{Verbatim}
.../ContactAdder.java:64: warning: [forbidden.flow]
    private @Source({}) @Sink({}) ArrayList<@Source({FlowPermission.ANY}) @Sink({FlowPermission.CONTENT_PROVIDER}) Integer> mContactEmailTypes;
                                            ^
  flow forbidden by flow-policy
  found: @Sink(FlowPermission.CONTENT_PROVIDER) @Source(FlowPermission.ANY) Integer
  forbidden flows:
    ANY -> CONTENT_PROVIDER
.../ContactAdder.java:68: warning: [forbidden.flow]
    private @Source({}) @Sink({}) ArrayList<@Source({FlowPermission.ANY}) @Sink({FlowPermission.CONTENT_PROVIDER}) Integer> mContactPhoneTypes;
                                            ^
  flow forbidden by flow-policy
  found: @Sink(FlowPermission.CONTENT_PROVIDER) @Source(FlowPermission.ANY) Integer
  forbidden flows:
    ANY -> CONTENT_PROVIDER
\end{Verbatim}

Remove \<@Source({FlowPermission.ANY})> from both locations. 


\section{Adding Annotations}

Next, annotate the code to ensure the flow policy correctly represents the flows
in the app.  One way to annotate an unfamiliar app, is to work through each warning
one by one. Correct it by adding annotations, re-running the Information Flow Checker, 
and then correct the next warning.  In general, 
Information Flow Checker warnings are written as shown below.

\begin{Verbatim}  
../SomeClass.java:line number: warning: some types are incompatible 
             source code causing warning
                     a caret (^) pointing to the location of the warning.
   found   : Qualified type found by the Information Flow Checker
   required: Qualified type that the Information Flow Checker was expecting.
\end{Verbatim}
 
In order to correct a warning and correctly capture the app behavior, answer 
the following questions for each warning.
\begin{enumerate}
\item Why are the found and required annotations those listed in the warning message?
   \begin{itemize}
    \item Is the annotation explicitly written in the source code? 
    \item Is the annotation from an API method that was annotated in stub file? \secref{sec:apispecs}
    \item Is the annotation inferred? \secref{sec:type-inference}
    \item Is the annotation defaulted? \secref{sec:unannotated-types}
    \end{itemize}
\item Why is the found type not a subtype of the required type? \secref{sec:subtyping}
  \begin{itemize}
   \item Does the found type have more or different found sources than required?
   \item Does the found type have less or different found sinks than required? 
   \end{itemize}
\item What annotation or annotations correctly capture the behavior of the app at
  this location? (In other words, what annotation will make the found type a 
  subtype of the required type?)
   \begin{itemize}
   \item Add only a source or a sink annotation
   \end{itemize}
\end{enumerate}

This tutorial only covers incompatibility warnings; see section \secref{errors} for 
other warnings and how to handle them.

\subsection{Warning }

\begin{enumerate}
\item Why are the found and required annotations those listed in the warning message?
   \begin{itemize}
    \item Is the annotation explicitly written in the source code? 
    \item Is the annotation from an API method that was annotated in stub file? \secref{sec:apispecs}
    \item Is the annotation inferred? \secref{sec:type-inference}
    \item Is the annotation defaulted? \secref{sec:unannotated-types}
    \end{itemize}
\item Why is the found type not a subtype of the required type? \secref{sec:subtyping}
  \begin{itemize}
   \item Does the found type have more or different found sources than required?
   \item Does the found type have less or different found sinks than required? 
   \end{itemize}
\item What annotation or annotations correctly capture the behavior of the app at
  this location? (In other words, what annotation will make the found type a 
  subtype of the required type?)
   \begin{itemize}
   \item Add only a source or a sink annotation
   \end{itemize}
\end{enumerate}

\subsection{Warning 1}
Run the Information Flow Checker again.

\begin{Verbatim}  
.../ContactAdder.java:96: warning: [assignment.type.incompatible] incompatible types in assignment.
        mContactPhoneTypes = new ArrayList<Integer>();
                             ^
  found   :  {   ->  ANY } ArrayList< {   ->   }  Integer>
  required:  {   ->   } ArrayList< { USER_INPUT  ->  CONTENT_PROVIDER }  Integer>
\end{Verbatim}
This is an ``incompatible types in assignment'' error.  It means that the type
of the left hand side, the found type, is not a subtype of the right hand side,
the required type.
 
\begin{enumerate}

\item \textbf{Where do the found  and required types come from?}

The type of \<new ArrayList\textless Integer\textgreater()> is the \emph{found} type and the type of \<mContactPhoneTypes> is
the \emph{required} type.  


 \begin{itemize}
    \item Was it explicitly annotated in the source code?  \<mContactPhoneTypes> was, but \<new ArrayList\textless Integer\textgreater()> was not.
    \item Is it from an API method that was annotated in stub file? No
    \item Was it inferred from an assignment? No
    \item Was it defaulted? Yes, \<new ArrayList\textless Integer\textgreater()> 
    \end{itemize}

 According to the defaulting rules explained in \secref{sec:unannotated-types} constructor results
 are annotated with \<@Source(\{\}) @Sink(\{\})> and type arguments are annotated 
 with \<@Source(\{\}) @Sink(\{\})> by 
 default. Notice that the source annotation on \<mContactPhoneTypes> has been defaulted based on the 
 flow policy.  \perm{USER\_INPUT} is the only source allowed to flow to \perm{CONTENT_PROVIDER}. 

 \item\textbf{ Why is the found type not a subtype of the required type?}
The primary qualifiers on \<mContactPhoneTypes>, \<@Source(\{\}) @Sink(\{\})> 
is a super type of the primary qualifiers on \<new ArrayList\textless Integer\textgreater()>,
 \<@Source(\{\}) @Sink(ANY)>.  The qualifiers on the type arguments must be the same. 
For more details, see
\url{http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#generics}.

\item\textbf{What annotation or annotations would make the found type a subtype of the required?}
Because the annotations on \<mContactPhoneTypes> were inferred,  annotations should be add to 
\<new ArrayList\textless Integer\textgreater()> so that the type argument matches  \<mContactPhoneTypes> 

 \annomethod{  mContactEmailTypes = new ArrayList<\textbf{@Sink(CONTENT_PROVIDER)} Integer>(); }
 
 The source annotation will be defaulted to \<@Source(USER\_INPUT) >.
 \end{enumerate}
 Run the Information Flow Checker again.  Only three warnings should be issued.
 
 \subsection{Warning 2}
 \begin{Verbatim}
[jsr308.javac] /Users/smillst/Downloads/ContactManager/src/com/example/android/contactmanager/ContactAdder.java:101: warning: [assignment.type.incompatible] incompatible types in assignment.
[jsr308.javac]         mContactEmailTypes = new ArrayList<Integer>();
[jsr308.javac]                              ^
[jsr308.javac]   found   :  {   ->  ANY } ArrayList< {   ->   }  Integer>
[jsr308.javac]   required:  {   ->   } ArrayList< { USER_INPUT  ->  CONTENT_PROVIDER }  Integer>
\end{Verbatim} 
This warning is nearly identical to the previous warning and can be corrected the same way.
 
   Run the Information Flow Checker again.  Only two errors should be issued.


  \subsection{Warning 3 }
   \begin{Verbatim}
[jsr308.javac] /Users/smillst/Downloads/ContactManager/src/com/example/android/contactmanager/ContactAdder.java:282: warning: [return.type.incompatible] incompatible types in return.
[jsr308.javac]                 return dictionary[i];
[jsr308.javac]                                  ^
[jsr308.javac]   found   :  {   ->   }  AuthenticatorDescription
[jsr308.javac]   required:  {   ->  ANY }  AuthenticatorDescription
\end{Verbatim} 
This is an ``incompatible types in return'' warning.  It means that the type
of the returned expression, the found type, is not a subtype of the declared  
return type of the method, the required type.

 \begin{enumerate}

\item\textbf{Where do the found and required types come from?}
 The found type is the type an index of the array \<dictionary> which is declared in the method signature, \<@Source(\{\}) the sink is defaulted to \<@Sink({})>
 
 and the required type is .


       \annomethod{public void onCheckedChanged(CompoundButton buttonView, \textbf{@Source(USER\_INPUT)} boolean isChecked)}
 \end{enumerate}

Run the Information Flow Checker; there should be 2 warnings.
  
  \subsection{Warning 4 }
   \begin{Verbatim}
.../ContactManager/src/com/example/android/contactmanager/ContactManager.java:77: 
warning: incompatible types in assignment.
                 mShowInvisible = isChecked;
                                  ^
   found   : @Sink({CONDITIONAL, WRITE_LOGS, CONTENT_PROVIDER}) @Source(USER_INPUT) boolean
   required: @Sink({CONDITIONAL, DISPLAY, WRITE_LOGS, CONTENT_PROVIDER}) @Source(LITERAL) boolean
    \end{Verbatim} 

 \begin{enumerate}

\item\textbf{Where do the found and required types come from?}
   The found type is a parameter that is annotated and the required type is a field that was 
   defaulted.
\item  \textbf{ Why is the found type not a subtype of the required type?}
  The found source is \perm{USER\_INPUT} and the required source is \perm{LITERAL}. 
\item  \textbf{What annotation or annotations would make the found type a subtype of the required?}
  The required type has already been annotated, so it should not be changed; therefore, the
  found type should be annotated with \<@Source(USER\_INPUT)>.\newline
  
  \annomethod{private \textbf{@Source(USER\_INPUT)} boolean mShowInvisible;}
  
   \end{enumerate}

Run the Information Flow Checker; there should be 3 warnings.  Two of the warnings are because of the
annotation that was just added.

  \subsection{Warning 5}
   \begin{Verbatim}
.../ContactManager/src/com/example/android/contactmanager/ContactManager.java:63: 
warning: incompatible types in assignment.
         mShowInvisible = false;
                          ^
   found   : @Sink({CONDITIONAL,DISPLAY, WRITE_LOGS, CONTENT_PROVIDER}) @Source(LITERAL) boolean
   required: @Sink({CONDITIONAL, WRITE_LOGS, CONTENT_PROVIDER}) @Source(USER_INPUT) boolean
    \end{Verbatim} 

 \begin{enumerate}

\item\textbf{Where do the found and required types come from?}
   The found type is from the boolean literal.  The required type is from an annotated field.
  \item\textbf{ Why is the found type not a subtype of the required type?}
  The found source is \perm{LITERAL} and the required type is \perm{USER\_INPUT}
  \item\textbf{What annotation or annotations would make the found type a subtype of the required?}
  The annotation on the boolean literal cannot be changed, so the annotation of the field must be changed.  The annotation is \<@Source(USER\_INPUT)>, so we can add the 
  \perm{LITERAL} to the list of sources.\newline
  
    \annomethod{    private \textbf{@Source(\{USER\_INPUT, LITERAL\})} boolean mShowInvisible;}
      \end{enumerate}

    Run the Information Flow Checker; there should be 1 warning.  The last change fixed two warnings.
    
  \subsection{Warning 6}
   \begin{Verbatim}
.../ContactManager/src/com/example/android/contactmanager/ContactManager.java:118: 
warning: incompatible types in return.
         return managedQuery(uri, projection, selection, selectionArgs, sortOrder);
                            ^
   found   : @Sink({CONDITIONAL, DISPLAY, WRITE_LOGS, CONTENT_PROVIDER}) @Source(CONTENT_PROVIDER) Cursor
   required: @Sink({CONDITIONAL, DISPLAY, WRITE_LOGS, CONTENT_PROVIDER}) @Source(LITERAL) Cursor
    \end{Verbatim} 

 \begin{enumerate}

\item\textbf{Where do the found and required types come from?}
   The found type is from the return type of an API method that was annotated in a stub file.  The required type is the return type of this method, \<getContacts()>, which is defaulted. 
  \item\textbf{ Why is the found type not a subtype of the required type?}
  The found source is \<@Source(CONTENT\_PROVIDER)> and the required source is 
  \<@Source(LITERAL>.
  \item\textbf{What annotation or annotations would make the found type a subtype of the required?}
  Because the found type is from a stub file annotation, it cannot be changed. So, the return type of this method, \<getContacts()> must be annotated with 
  \<@Source(CONTENT\_PROVIDER>.\newline
  
             \annomethod{ private \textbf{@Source(CONTENT\_PROVIDER)}
             Cursor getContacts()}
              \end{enumerate}

    Run the Information Flow Checker; there should be no warnings.
  \section{Correctly annotated app}  
     Now that the Information Flow Checker no longer reports any warnings, it guarantees that
     ContactManger only contains the information flows in the flow policy.  

 
%
%
%
%
