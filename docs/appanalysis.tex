\htmlhr
\chapter{Android App Analysis\label{appanalysis}}

This is a brief guide on how to analyze a new unannotated Android application and
find security vulnerabilities. This document gives a high-level view
of the process, including how various tools relate to one another.

For details about how to install and run the code analysis tools, see \chapref{installation}.


\section{Task:  set up the tools for the new application}

Checking applications

It is required to set three environment variables:

\begin{itemize}
\item
\<CHECKERS> pointing to the
\<.../checker-framework/checkers> directory

\item
\<SPARTA\_CODE> pointing to the \<.../sparta-code> directory

\item
\<ANDROID\_HOME> pointing to the \<.../android-sdk> directory

\end{itemize}


The SPARTA project needs to be updated to your development environment, so that the path to the Android SDK is correct and the correct version of Android is use. (More details about updating a project are available here: \url{http://developer.android.com/tools/projects/projects-cmdline.html#UpdatingAProject}.)To update the project with your Android settings run the following:

\begin{alltt}
ant -buildfile $SPARTA_CODE/build.local.xml
\end{alltt}

Alternatively, you can run:

\begin{alltt}
$ANDROID_HOME/tools/android update project -{}-path . -{}-target android-15
\end{alltt}

Edit the \<build.xml> file of the project under analysis to add the
SPARTA build targets at the end (right before the ``$<$/project$>$''):
% TODO: how does using lt and gt in TT mode work?

\begin{alltt}
<property environment="env"/>
<dirname property="checkers_dir" file="\$\{env.CHECKERS\}"/>
<basename property="checkers_base" file="\$\{env.CHECKERS\}"/>
<dirname property="sparta-code_dir" file="\$\{env.SPARTA_CODE\}"/>
<basename property="sparta-code_base" file="\$\{env.SPARTA_CODE\}"/>
<import file="\$\{sparta-code_dir\}/\$\{sparta-code_base\}/build.include.xml" optional="true"/>
\end{alltt}



To use Eclipse to look at and build the code, perform these simple
steps:
\begin{itemize}
\item
Using Eclipse, import the projects (this requires the app to have a
.project and .classpath file)
  \begin{itemize}
    \item
    Make sure
    \<Project Properties $\rightarrow$ Android $\rightarrow$ Android
    version \#> is checked

    \item
    Check that
    \<Project Properties $\rightarrow$ Java Build Path $\rightarrow$
    Libraries $\rightarrow$ Android version \#> appears

    \item
    Add the sparta-code project to
    \<Project Properties $\rightarrow$ Java Build Path $\rightarrow$ Projects>
    
  \end{itemize}

\item Compile via command line (\<ant clean>, \<ant flowtest>)

\item If it compiles, or the errors are exclusively about annotations,
  it's working correctly.
\end{itemize}

Most Android apps will rely on an auto-generated \<R.java> file
in the \</gen> directory of the project. This will only be generated
if there are no errors in the project. There may be errors in the
resources (\<.../res> directory) that could cause \<R.java> to not be
generated.

Additionally, if the app depends on an external \<.jar> file (often
located in the \<lib/> directory), it will compile in Eclipse but not
with Ant. To fix this, in ant.properties, add ``\<jar.libs.dir=lib>''
(or wherever the \<.jar> is located).


\section{Task: get a basic understanding of the application}

Look at the AndroidManifest.xml file and:
\begin{itemize}
\item Determine which permissions the app uses.
  Look for ``uses-permission'' entries to understand the used
  permissions.
\item Determine the entry points into the source code. (This may also give
  a hint about the architecture or overall modular structure of the
  application.)
  Look for ``activity'', ``intent-filter'', ``service'', ``receiver'', and
  ``provider'' to see the entry points, intent messages it responds to,
  etc.
\end{itemize}


\section{Task: see where permissions are used in the application}

Run \<ant reqperms>  to see a list of the app's methods
that use calls that require certain Android permissions. You can use
this to gain an understanding of where sensitive information may come
from/go to in the application. This command produces errors like the following:
\begin{alltt}
error: Call additionally requires permissions [android.permission.INTERNET], 
   but caller only provides []!
\end{alltt}
You can remove the error by writing
\<@RequiredPermissions({android.Manifest.permission.\emph{PERMISSION}})> in front of the method header in the source code.

Once all methods in the subject application are correctly annotated,
\<ant reqperms> will not issue any warnings.
Grep for \<@RequiredPermissions> to find the required permissions
in the application.


% TODO: The required permission information is based on Android 2.2
% information. Explain the caveat of Android 4.0 changes and the issue
% with "entry-method" checks versus correct checking on all
% possible paths into an API.



\section{Task: see what precise APIs are used where in the application}

Run \<ant reportusage>, \<ant reportusage-json>, or \<ant
reportusage-text> to get a report of the used APIs. The
\<reportusage>  only reports about Android APIs that appear in two files:
\<sparta-code/src/sparta/checkers/report.astub> and \<reflection.astub>. 
%TODO: I think this belongs in the next section
%Additional \<.astub> files can be passed as \<-Astubs=...> argument in the
%build file.


\section{Task: ensure that the used APIs are annotated with flow information\label{flow-task-annotate-apis}}

File \<sparta-code/src/sparta/checkers/flow.astub> provides library
annotations.  You may need to enhance it, if you find that your application
uses APIs that are not yet annotated.
(The  more APIs get annotated, the less work you will have to do in this
step for each new app.)
%Note that the \emph{fully qualified name} is required for \<FlowSources> and 
%\<FlowSinks> annotations in the \<flow.astub> file.
For details, see chapter
``Annotating libraries'' in the Checker Framework manual.

An example from \<flow.astub> is:

\begin{Verbatim}
package android.telephony;

class TelephonyManager {
    public @FlowSources(FlowSource.PHONE_NUMBER) String getLine1Number();
    public @FlowSources(FlowSource.IMEI) String getDeviceId();
}
\end{Verbatim}

\noindent
The above annotates two methods in class \<TelephonyManager>.
It indicates that the \<getLine1Number> function returns a String which is a
phone number.  For more examples, look into the \<flow.astub> file.

For every API method used by this app (i.e., those output by \<ant
reportusage>) that does \emph{not} already appear in file
\<sparta-code/src/sparta/checkers/flow.astub>, do the following.
\begin{itemize}
\item
Read the Javadoc
\item
Decide what flow properties the method has.
\item
Add the method to the \<flow.astub> file, with
appropriate flow properties expressed as \<@FlowSinks(...)> and
\<@FlowSources(...)> annotations.
It would be unusual for an API method to contain both a \<@FlowSources>
and a \<@FlowSinks> annotation.

If the method has no flow, you can write  
\<@FlowSources(...)> \<@FlowSinks(...)>  on each parameter and the return type, 
\emph{or} you can write a single 
\<@NoFlow> declaration annotation on the method.
This annotation is short-hand for annotating the return type and each
parameter as not having any flow.
It is important to mark API methods that have no flow, so that the method
appears in the \<flow.astub> file and the next person looking at that
API does not need to perform the same analysis again.
\end{itemize}


Note: you have not yet added any annotations to the app itself.


\section{Task: visualize the existing flow in the application}

You do not have to run this step -- you can skip it if you
prefer.

Run \<ant flowshow> or \<ant flowshow-json> to get a report of the
existing flow.
For every type use in the application, it indicates the flow sources
and sinks for that variable. This is exactly the annotations written
in the program, plus possibly some additional annotations that are
inferred by the Checker Framework.
The \<-json> version creates file flowshow.json that can be visualized
separately.

This step does not perform type-checking; it only visualizes the flow
information written in the program or libraries as annotations, or
inferred from those annotations.

The report is interesting exactly when a given type use contains both
a \<@FlowSource> and a \<@FlowSink> annotation. This is an information flow,
and the analyst must decide whether it is desirable or undesirable.

For an unannotated program, the report will not be informative: it
only contains API annotations that are propagated to local
variables. The report will become more informative as you add more and
more annotations to the application. So, you can periodically rerun
this step. 


\section{Task: check the flow in the application}

Run \<ant flowtest> on the application.
Eliminate each warning in one of two ways.
\begin{enumerate}
\item Add annotations to method signatures and fields in the application, as
required by the type-checker. This essentially propagates the flow
information required by the APIs through the application.

\item Use \<@SuppressWarnings> to indicate safe uses that are safe for reasons
that are beyond the capabilities of the type system. Always write a
comment that justifies that it is safe.
\end{enumerate}
A prime example is a String literal that should be allowed to be sent
over the network. By default, every literal has \<@FlowSinks()>
(i.e., nothing) and \<@FlowSources()>.

\begin{alltt}
    @SuppressWarnings("flow") // manually verified to not contain secret data
    @FlowSinks(FlowSink.NETWORK) String url = "http://bazinga.com/";
\end{alltt}

Without suppression the assignment raises an error, because string literals
are assumed to be annotated with @NoFlow. By adding the suppression, you
assert that it's OK to send this string to the network. 

Focus on the most interesting flow sources and try to connect the flow
sources and sinks in the application. Instead of trying to completely
annotate only the sources or only the sinks, skim over all the reports
and use your intuition to decide which parts of the application to
focus on. Try to focus on the parts with the (most) connections
between sources and sinks.

Most types will only use either a \<@FlowSources> or \<@FlowSinks>
annotation.
The goal is to find places where you need both annotations, e.g. to
express that information that comes from the camera may go to the
network:

\begin{alltt}
    @FlowSources(FlowSource.CAMERA)
    @FlowSinks(@FlowSink.NETWORK) Picture data;
\end{alltt}

Such a type connects sources and sinks and one needs to carefully
decide whether this is a desired information flow or not.
\begin{itemize}
\item If this is good information flow, then write both the \<@FlowSources>
  and the \<@FlowSinks> annotations at the same place. You will not
  receive any more error messages, but you can find all these places
  with grep or (better) with \<ant flowshow>.
\item If this is bad information flow, then either leave it unannotated,
  or annotate it but record both in the source code and elsewhere that
  you have found a security flaw.
\end{itemize}

You can continue to use \<ant flowshow> to visualize the annotation
progress.

Once all warnings were resolved, run \<ant -Dstricter=true flowtest> on
the application.
Providing the \<stricter> option enables additional checks that are
required for soundness, but would be disruptive to enable initially.
In particular, the tests for casts and array subtyping are stricter.
See the discussion in \chapterpageref{flow-checker}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  App xml env basename sparta dir
