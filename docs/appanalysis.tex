\htmlhr
\chapter{How to Analyze an Unannotated App\label{analyze-unannotated-app}}

If you are presented with an unannotated app and wish to confirm that it
contains no malware, then you need to perform three tasks:
\begin{itemize}
\item
  Look for obvious malware.
\item
  Run reverse-engineering tools to understand the application.
\item
  Write and check information-flow type qualifiers to ensure that the
  program has no undesired information flow.
\end{itemize}


More specifically, the recommended workflow is:

\begin{enumerate}
\item Set up the app for analysis by the SPARTA tools; see \secref{sec:antsetup}
\item Write the flow policy; see \secref{sec:write-flow-policy}
\item Run reverse-engineering tools; see \secref{sec:reverse-engineering}
\item Write and check information flow type qualifiers; see \secref{verify-information-flow-security}
\end{enumerate}

% \noindent 
% The tools should be run in the following order. 
% 
% \begin{enumerate}
% \item ant reportsuspicious (also runs sparta-code/suspicious.pl)
% \item ant reqperms
% \item ant reportapiusage
% \item ant flowtest
% \end{enumerate}
% 
% \noindent 
% The rest of this chapter gives more details about each step in the analysis process.




\section{Write a flow-policy file\label{sec:write-flow-policy}}

Write a flow-policy file.  \secref{sec:flow-policy} describes flow policies.

\subsection{Read the app description}
\label{sec:read-the-app-description}

Read the App description and user documentation, looking for clues about
the permissions , sensitive sources, and sinks and how information
flows between them.  For example,
if this is a map app, does the description say anything about sending your location data over the
 network?  If so, then you should add \<LOCATION\flowsto NETWORK> to the flow-policy file.  Where
else does the description say LOCATION data can go?   

Theoretically, you should be able to write a complete Flow Policy from the
description if the description is well-written and the app does not contain
malware.  In practice, you will have to add flows to the policy file as you
more fully annotate the app, but you should ensure that they are reasonable
and make note of what additional flows you had to add.
 

\subsection{Read the manifest file}

Look at the \<AndroidManifest.xml> file and:
\begin{itemize}
\item Determine which permissions the app uses --- the ``uses-permission''
  entries in the manifest file.

  (If you are short on time, you could start with reading the manifest file
  rather than first reading the app description as recommended in
  \secref{sec:read-the-app-description}.  But determining the permissions
  from the documentation will be more effective in finding problems in
  either the documentation or the code.)
\item Compare the used permissions with the description of the
  application and determine whether or not they are well justified.
  If an application uses certain permissions that are not justified
  in the description, this indicates suspicious code. 
  (To determine where these permissions are used in the application,
   see \ref{sec:appanalysis/reqperms})

  (Permissions are not one-to-one with sinks and sources, but the name of the permission should give 
  a clue about which sources and sinks are involved.)  For example, if the SEND\_SMS permission is 
  requested, then SMS should be listed as a flow sink somewhere in the policy file.  If this is not the 
  case, do not add it to the policy file, but pay close attention to how this permission is used in the 
  code.

\item Determine the entry points into the source code. (This may also give
  a hint about the architecture or overall modular structure of the
  application.)
  Look for ``activity'', ``intent-filter'', ``service'', ``receiver'', and
  ``provider'' to see the entry points, intent messages it responds to,
  etc.

  \todo{What is the point of this step?  Does it inform the creation of
  the flow policy?  Or should it be moved later into the reverse
  engineering steps of \secref{sec:reverse-engineering}? }
\end{itemize}



\section{Run reverse-engineering tools\label{sec:reverse-engineering}}



\subsection{Review suspicious code and API uses}
\label{sec:appanalysis/suspicious}

Run

\begin{Verbatim}
  ant reportsuspicious
\end{Verbatim}

\noindent
to get a list of the most suspicious code
locations. 
The code may be innocuous, but a human should examine it.

This target reports
\begin{itemize}
\item
  uses of potentially dangerous APIs, including reflection, randomness,
  thread spawning, and the ACTION VIEW intent.

  The file \<sparta-code/src/sparta/checkers/suspicious.astub> contains the classes and methods that are considered suspicious.

The following example from the \<suspicious.astub> file reports all calls
of the \verb|invoke| method and, additionally, all constructor calls 
of the class \verb|java.util.Random|:

\begin{Verbatim}
package java.lang.reflect;                                             
class Method {                                                         
    @ReportCall                                                        
    public Object invoke(Object obj, Object [] objs) {}                
}                                                                      
                                                                       
package java.util;                                                     
@ReportCreation                                                        
class Random {}
\end{Verbatim}

\item
  suspicious String patterns (e.g., hard-coded URIs and IP and MAC addresses) 
  in \verb|.java| and \verb|strings.xml| files.  The searched-for patterns
  appear in the script \<sparta-code/suspicious.pl>.

\todo{ This level of implementation detail is not appropriate for this manual.
It should appear in the documentation of the script itself.
Generally, the \<sparta-code/suspicious.pl> script takes two arguments:
 \begin{enumerate}
  \item root-dir: The directory in which the script recursively 
        searches for the given patterns (built-in or argument\#2)
  \item pattern (optional): Search pattern to use instead of the
 built-in ones. 
 \end{enumerate} 
 }

\end{itemize}

If you learn of additional suspicious API uses or String patterns, please
inform the SPARTA developers so they can add them to the
\<suspicious.astub> or \<suspicious.pl> file.


\subsection{Review where permissions are used in the application}
\label{sec:appanalysis/reqperms}

\todo{:what does \<@RequiredPermissions> mean?  That should appear both in
its Javadoc (which is currently missing) and here.  Why do we care?  What
benefits do \<@RequiredPermissions> bring to the analyst?  Given
\<@RequiredPermissions> annotations in Android libraries, could they be
automatically inferred in other libraries and in the app itself, rather
than requiring a human to write them all?}

Run

\begin{Verbatim}
  ant reqperms
\end{Verbatim}

\noindent
to see where the application calls API methods that require an Android permission.  

The \<ant reqperms> tool will help you gain an understanding of how your
app first obtains information from a sensitive source, or how your app
finally sends information to a sensitive sink.  This may help you decide
what parts of the app to further investigate, or where to start your
annotation work.

The command produces output like the following:
\begin{alltt}
error: Call additionally requires permissions [android.permission.INTERNET], 
   but caller only provides []!
\end{alltt}
You can eliminate the error by writing
\<@RequiredPermissions({android.Manifest.permission.\emph{PERMISSION}})> in
front of the method header in the source code, if you would like to propagate the
required permission up the call stack. 

Once all methods in the subject application are correctly annotated with
\<@RequiredPermissions>, then \<ant reqperms> will not produce any output.
Then, you can search for \<@RequiredPermissions> to find the required
permissions in the application.

Any permission that is required should already be listed in the
\<AndroidManifest.xml> file.

The permissions required by the Android API appear in file
\<src/sparta/checkers/permission.astub>, expressed as
\<@RequiredPermissions> annotations.



\todo{ The required permission information is based on Android 2.2
 information. Explain the caveat of Android 4.0 changes and the issue
 with "entry-method" checks versus correct checking on all
 possible paths into an API.}


\subsection{Review what APIs are used where in the application}

Run

\begin{alltt}
  ant reportapiusage
\end{alltt}

\noindent
to get a report of Android and other APIs used in the application.
These APIs are not
suspicious in general (see \ref{sec:appanalysis/suspicious} for reports
about suspicious API use). However, they do help the analyst to better
understand the structure of the code not just with respect to its standard
module structure, but in terms of how it interacts with Android interfaces.

The
\<ant reportapiusage> target only reports about APIs that appear in the file:
\<sparta-code/src/sparta/checkers/apiusage.astub>.
Additional \<.astub> files can be passed using the \<-Astubs=...> argument in the
build file.

The following example from \<apiusage.astub> causes \<ant reportapiusage>
to report the use of all entities in the package 
\verb|com.android|:

\begin{Verbatim}
@ReportUse                                                         
package com.android;
\end{Verbatim}

As you work, enhance the \<apiusage.astub> to add the entities that are
most crucial to understand the behavior of an application.  Contact the
SPARTA developers to tell them of additions that should appear in the file.


\section{Verify information flow security\label{verify-information-flow-security}}

It is most effective to write information flow annotations from the bottom
up:  first annotate libraries your code uses, then your packages and
classes that use those libraries, and so forth up to the entry points of
your application.
\secref{flow-task-annotate-apis} describes how to annotate libraries, and
the remainder of this section describes how to annotate your own code.


\subsection{Write information flow types for library APIs\label{flow-task-annotate-apis}}

When the Flow Checker type-checks your code that calls a library API, the
Flow Checker needs to know the effect of that call.  
Stub files in \<sparta-code/src/sparta/checkers/flowstubfiles/> provide
that information.  You may need to enhance those stub files, if they do not
yet contain information about the library APIs that your application uses.
(Over time, the stub files will become more complete, and you will have to
do less work in this step for each new app.)

For every API method used by this app (including all those output by \<ant
reportapiusage>), do the following:
\begin{itemize}
\item
If the API method already appears in some stub file, there is nothing to
do; continue to the next API method.

\todo{  Have an ant target or other tool that reports only
\emph{un-annotated} APIs, so that the user has a list of APIs to annotate
without having to search through all the stub files.}
\item
Read the Javadoc.
\item
Decide what flow properties the method has.  Take care with this step,
because your decision will be trusted, not checked.  If you make a mistake,
the Flow Checker's results will not be sound.
\item
Add the method to the stub file that corresponds to the class package, with
appropriate flow properties expressed as \<@FlowSources(...)> and
\<@FlowSinks(...)> annotations.
It would be unusual for an API method to contain both a \<@FlowSources>
and a \<@FlowSinks> annotation.

If the method does is not directly related to information flow (its inputs
and outputs could be anything and are not required to have a specific
\<@FlowSources> annotation), then annotate its parameters and return type
with \<@PolyFlowSources @PloyFlowSinks>, which essentially says that the
output can have all the flow sources and sinks of the inputs.
\todo{There is some more concise way to specify this, without having to
annotate each parameter and return type individually.}
\end{itemize}

\noindent
\textbf{Important:}
After changing or adding stub files, run \<ant jar> to rebuild \<sparta.jar>.



The stub files can include any third-party library that is not compiled
along with your application.  You can add a new \<.astub> file to the
\<flowstubfiles/> directory.
Alternately, you can put a new \<.astub> file elsewhere and then pass this
file to the \<ant flowtest> target:

\begin{alltt}
ant -Dstubs=\emph{path/myAnnoLib.astub} flowtest
\end{alltt}

Here is an example from a stub file:

\begin{Verbatim}
package android.telephony;

class TelephonyManager {
    public @FlowSources(FlowSource.PHONE_NUMBER) String getLine1Number();
    public @FlowSources(FlowSource.IMEI) String getDeviceId();
}
\end{Verbatim}

\noindent
The above annotates two methods in class \<TelephonyManager>.
It indicates that the \<getLine1Number> function returns a String that is a
phone number.  For more examples, look into the stub files. Also, see 
the
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries}}{Annotating
  Libraries}'' chapter in the Checker Framework Manual\ifhevea\else\ (\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.pdf})\fi.


When creating a new stub file, see the section
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#stub-creating}}{Creating
  a stub file}'' in the Checker Framework Manual to learn how to create an
initial file and prevent a great deal of repetitive cut-and-paste editing.


It is usually a good idea to annotate an entire API class at a time, rather
than to just annotate the specific methods that your app uses.  Annotating
an entire class lets you think about it once, which takes less time in the
long run.  It also reduces confusion for people who will later wonder
whether a particular method was intended to be unannotated or had not yet
been annotated.


Note: at the end of this step, you have not yet added any annotations to
the app itself, only to libraries.


\subsection{Task: visualize the existing flow in the application}

You do not have to run this step --- you can skip it if you
prefer.

\todo{Why would I want to perform this step?  What would be the benefits?}

Run \<ant flowshow> to get a report of the
existing flow.
For every type use in the application, it indicates the flow sources
and sinks for that variable. This is exactly the annotations written
in the program, plus possibly some additional annotations that are
inferred by the Checker Framework.

%We don't support this
%The \<-json> version creates file flowshow.json that can be visualized
%separately.

This step does not perform type-checking; it only visualizes the flow
information written in the program or libraries as annotations, or
inferred from those annotations.


For an unannotated program, the report will not be informative: it
only contains API annotations that are propagated to local
variables. The report will become more informative as you add more and
more annotations to the application. So, you can periodically rerun
this step. 


\subsection{Write information flow types for the app\label{flow-task-annotate-app}}

Write information flow annotations for your application, in the same way as
you did for the libraries.  Read the documentation, decide on the types,
and write those.  A fast and effective way to do this is to grep the source
code for words related to information flow properties, such as ``camera''
or ``network''.  These words might appear in documentation or in source
code.  Wherever the words appear, you may be able to write information flow
type qualifiers.  This approach is both faster and less error-prone than
iteratively running the type-checker and fixing the errors that it reports
one-by-one.

\todo{provide a tool that does this grepping.  Also tell the user how to
take advantage of the \<@RequiredPermissions> annotations and other tool
output.}


Focus on the most interesting flow sources and try to connect the flow
sources and sinks in the application. Instead of trying to completely
annotate only the sources or only the sinks, skim over all the reports
and use your intuition to decide which parts of the application to
focus on. Try to focus on the parts with the (most) connections
between sources and sinks.

Most types will only use either a \<@FlowSources> or \<@FlowSinks>
annotation.
The goal is to find places where you need both annotations, e.g. to
express that information that comes from the camera may go to the
network:

\begin{alltt}
    @FlowSources(FlowSource.CAMERA)
    @FlowSinks(FlowSink.NETWORK) Picture data;
\end{alltt}

Such a type connects sources and sinks and one needs to carefully
decide whether this is a desired information flow or not.
\begin{itemize}
\item If this is good information flow, then write both the \<@FlowSources>
  and the \<@FlowSinks> annotations at the same place. You will not
  receive any more error messages, but you can find all these places
  with grep or (better) with \<ant flowshow>.
\item If this is bad information flow, then either leave it unannotated,
  or annotate it but record both in the source code and elsewhere that
  you have found a security flaw.
\end{itemize}


Once you have written as many type qualifiers as possible, proceed to
type-checking (\secref{sec:run-type-checker}).



\subsection{Type-check the information flow types in the application\label{sec:run-type-checker}}

Run

\begin{Verbatim}
  ant flowtest
\end{Verbatim}

Eliminate each warning in one of two ways.
\begin{enumerate}
\item Add annotations to method signatures and fields in the application, as
required by the type-checker. This essentially propagates the flow
information required by the APIs through the application.

\item Use \<@SuppressWarnings> to indicate safe uses that are safe for reasons
that are beyond the capabilities of the type system. Always write a
comment that justifies that the code is safe, and why the type system
cannot recognize that fact.

An example is a String literal that should be allowed to be sent
over the network. By default, every literal has \<@FlowSinks()>
(i.e., nothing) and \<@FlowSources()>.

\begin{alltt}
    @SuppressWarnings("flow") // manually verified to not contain secret data
    @FlowSinks(FlowSink.NETWORK) String url = "http://bazinga.com/";
\end{alltt}

Without warning suppression the assignment raises an error, because string literals
are assumed to be annotated with \<FlowSources(FlowSource.LITERAL)>. By adding the suppression, you
assert that it's OK to send this string to the network. 

\end{enumerate}

After you have corrected some of the errors, re-run \<ant flowtest>.
Repeat the process until there are no more errors, or until you find bad
code (malicious, or buggy and prone to abuse).

You can continue to use \<ant flowshow> to visualize the annotation
progress.  \todo{Why?  How does this help you?}


\subsection{Type-check with stricter checking}

Once all warnings were resolved, run 

\begin{Verbatim}
  ant -Dstricter=true flowtest
\end{Verbatim}

\noindent
Providing the \<stricter> option enables additional checks that are
required for soundness, but would be disruptive to enable initially.
In particular, the tests for casts and array subtyping are stricter.
See the discussion in \chapterpageref{flow-checker}.

This option will also use the stricter conditional rule. (LITERAL
\flowsto{} CONDITIONAL rather than the relaxed ANY \flowsto{} CONDITIONAL)


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  App xml env basename sparta dir app flowtest Dstrict SDK
%  LocalWords:  reportsuspicious reqperms reportapiusage buildfile dirname
%  LocalWords:  AndroidManifest classpath java flowpolicy enum astub app's
%  LocalWords:  RequiredPermissions FlowSources FlowSinks apiusage Dstubs
%  LocalWords:  flowstubfiles TelephonyManager getLine1Number flowshow url
%  LocalWords:  PolyFlowSources PloyFlowSinks FlowSink FlowSource grep
%  LocalWords:  Dstricter
