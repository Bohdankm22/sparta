\htmlhr
\chapter{How to Analyze an Unannotated App\label{analyze-unannotated-app}}

If you are presented with an unannotated app and wish to confirm that it
contains no malware, then you need to perform three tasks:
\begin{itemize}
\item
  Look for obvious malware.
\item
  Run reverse-engineering tools to understand the application.
\item
  Write and check information-flow type qualifiers to ensure that the
  program has no undesired information flow.
\end{itemize}


More specifically, the recommended workflow is:

\begin{enumerate}
\item Set up the app for analysis by the SPARTA tools; see \secref{sec:antsetup}
\item Write the flow policy; see \secref{sec:write-flow-policy}
\item Run reverse-engineering tools; see \secref{sec:reverse-engineering}
\item Write and check information flow type qualifiers; see \secref{verify-information-flow-security}
\end{enumerate}

% \noindent 
% The tools should be run in the following order. 
% 
% \begin{enumerate}
% \item ant report-suspicious (also runs sparta-code/suspicious.pl)
% \item ant report-permissions
% \item ant reportapiusage
% \item ant check-flow
% \end{enumerate}
% 
% \noindent 
% The rest of this chapter gives more details about each step in the analysis process.




\section{Write a flow-policy file\label{sec:write-flow-policy}}

Write a flow-policy file.  \secref{sec:flow-policy} describes flow policies.

\subsection{Read the app description}
\label{sec:read-the-app-description}

Read the App description and user documentation, looking for clues about
the permissions, sensitive sources, and sinks and how information
flows between them.  For example,
if this is a map app, does the description say anything about sending your location data over the
 network?  If so, then you should add \<LOCATION\flowsto INTERNET> to the flow-policy file.  Where
else does the description say location data can go?   

Theoretically, you should be able to write a complete Flow Policy from the
description if the description is well-written and the app does not contain
malware.  In practice, you will have to add flows to the policy file as you
more fully annotate the app, but you should ensure that they are reasonable
and make note of what additional flows you had to add.
 

\subsection{Read the manifest file}

Look at the \<AndroidManifest.xml> file and:
\begin{itemize}
\item Determine which permissions the app uses --- the ``uses-permission''
  entries in the manifest file.

  (If you are short on time, you could start with reading the manifest file
  rather than first reading the app description as recommended in
  \secref{sec:read-the-app-description}.  But determining the permissions
  from the documentation will be more effective in finding problems in
  either the documentation or the code.)
\item Compare the used permissions with the description of the
  application and determine whether or not they are well justified.
  If an application uses certain permissions that are not justified
  in the description, this indicates suspicious code. 
  (To determine where these permissions are used in the application,
   see \ref{sec:appanalysis/report-permissions})


\item Determine the entry points into the source code. (This may also give
  a hint about the architecture or overall modular structure of the
  application.)
  Look for ``activity'', ``intent-filter'', ``service'', ``receiver'', and
  ``provider'' to see the entry points, intent messages it responds to,
  etc.

  \todo{What is the point of this step?  Does it inform the creation of
  the flow policy?  Or should it be moved later into the reverse
  engineering steps of \secref{sec:reverse-engineering}? }
\end{itemize}



\section{Run reverse-engineering tools\label{sec:reverse-engineering}}



\subsection{Review suspicious code and API uses}
\label{sec:appanalysis/suspicious}

Run

\begin{Verbatim}
  ant report-suspicious
\end{Verbatim}

\noindent
to get a list of the most suspicious code
locations. 
The code may be innocuous, but a human should examine it.

This target reports
\begin{itemize}
\item
  uses of potentially dangerous APIs, including reflection, randomness,
  thread spawning, and the ACTION VIEW intent.

  The file \<sparta-code/src/sparta/checkers/suspicious.astub> contains the classes and methods that are considered suspicious.

The following example from the \<suspicious.astub> file reports all calls
of the \verb|invoke| method and, additionally, all constructor calls 
of the class \verb|java.util.Random|:

\begin{Verbatim}
package java.lang.reflect;                                             
class Method {                                                         
    @ReportCall                                                        
    public Object invoke(Object obj, Object [] objs) {}                
}                                                                      
                                                                       
package java.util;                                                     
@ReportCreation                                                        
class Random {}
\end{Verbatim}

\item
  suspicious String patterns (e.g., hard-coded URIs and IP and MAC addresses) 
  in \verb|.java| and \verb|strings.xml| files.  The searched-for patterns
  appear in the script \<sparta-code/suspicious.pl>.

\todo{ This level of implementation detail is not appropriate for this manual.
It should appear in the documentation of the script itself.
Generally, the \<sparta-code/suspicious.pl> script takes two arguments:
 \begin{enumerate}
  \item root-dir: The directory in which the script recursively 
        searches for the given patterns (built-in or argument\#2)
  \item pattern (optional): Search pattern to use instead of the
 built-in ones. 
 \end{enumerate} 
 }

\end{itemize}

If you learn of additional suspicious API uses or String patterns, please
inform the SPARTA developers so they can add them to the
\<suspicious.astub> or \<suspicious.pl> file.


\subsection{Review where permissions are used in the application}
\label{sec:appanalysis/report-permissions}


Run

\begin{Verbatim}
  ant report-permissions
\end{Verbatim}

\noindent
to see where the application calls API methods that may require some Android permissions.  
The \<ant report-permissions> tool will help you gain an understanding of how your
app first obtains information from a sensitive source, or how your app
finally sends information to a sensitive sink.  This may help you decide
what parts of the app to further investigate, or where to start your
annotation work.

There are three possible types of errors you will see. The first error:

\begin{Verbatim}
MainActivity.java:35: 
error: Call require permission(s) [android.permission.SET_WALLPAPER], 
but caller only provides []!
			clearWallpaper();
			              ^
\end{Verbatim}
This error means the method requires one or more permissions which the caller does not have.
The second error:

\begin{Verbatim}
MediaPlayerActivity.java:218:
error: Call may additionally require permission(s) 
[android.Manifest.permission.WAKE_LOCK], but caller only provides []! 
Notes: WAKE_LOCK is required if MediaPlayer.setWakeMode has been called first.
			          stop();
			              ^
\end{Verbatim}

This error means the method may or may not require one or more permissions which the caller
does not have. An explanation for the current error can be seen on the \<Notes>. 

\begin{Verbatim}
HelloWorldActivity.java:83: warning: If the constant DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED 
is passed to an intent it will require following permission(s): [android.permission.BIND_DEVICE_ADMIN]! 
i.setAction(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED);
            ^
\end{Verbatim}

This error means that the constant used depends on one or more permissions.

You can eliminate the first 2 errors by writing
\<@RequiredPermissions({android.Manifest.permission.\emph{PERMISSION}})> or
\<@MayRequiredPermissions({android.Manifest.permission.\emph{WAKE\_LOCK}})> in
front of the method header in the source code, if you would like to propagate the
required permission up the call stack. 
You should use 
\<@MayRequiredPermissions( value={android.Manifest.permission.\emph{PERMISSION}},
notes=java.lang.String)> in case the permission may be required and you should 
explain the reason on the \<notes> argument.
However, it is not necessary to eliminate all the errors from RequiredPermissions.   
The \<report-permissions> tool is only a tool to guide your annotation and manual analysis effort. 

Any permission that is required should already be listed in the
\<AndroidManifest.xml> file.

The permissions required by the Android API appear in file
\<src/sparta/checkers/permission.astub>, expressed as
\<@RequiredPermissions> and \<@MayRequiredPermissions> annotations.



\todo{ The required permission information is based on Android 2.2
 information. Explain the caveat of Android 4.0 changes and the issue
 with "entry-method" checks versus correct checking on all
 possible paths into an API.}

\section{Verify information flow security\label{verify-information-flow-security}}

When the goal is to completely annotate an application it is
most effective to write information flow annotations in a bottom up approach:
first annotate libraries your code uses, then your packages and classes
that use those libraries, and so forth up to the entry points of your application.
Alternatively, when the goal is to investigate specific information flows, it is
more effective to trace and annotate only the flows of interest.
Libraries should still be annotated first for all flows types.
A bottom up approach can be used as a first pass to annotate large portions of an
application while tracing can be then used to find and fix remaining Information Flow Checker warnings.
Both approaches use the flow-policy create in \secref{sec:write-flow-policy}.

\secref{flow-task-annotate-apis} describes how to annotate libraries,
\secref{flow-task-annotate-app} and \secref{sec:run-type-checker} describe how to
annotate your own code in a bottom up approach, and \secref{sec:trace-types} describes
how to iteratively trace sensitive sources in your application.


\subsection{Write information flow types for library APIs\label{flow-task-annotate-apis}}

When the Information Flow Checker type-checks your code that calls a library API, the
Information Flow Checker needs to know the effect of that call.  
Stub files in \<sparta-code/src/sparta/checkers/flowstubfiles/> provide
that information.  You may need to enhance those stub files, if they do not
yet contain information about the library APIs that your application uses.
(Over time, the stub files will become more complete, and you will have to
do less work in this step for each new app.)

Run \<ant check-flow> to create the \<missingAPI.astub> file. For each method in the 
file do the following.  
\begin{itemize}
\item
Read the Javadoc.
\item
Decide what flow properties the method has.  Take care with this step,
because your decision will be trusted, not checked.  If you make a mistake,
the Information Flow Checker's results will not be sound.
\item
Add the method to the stub file that corresponds to the class package, with
appropriate flow properties expressed as \<@Source(...)> and
\<@Sink(...)> annotations.
It would be unusual for an API method to contain both a \<@Source>
and a \<@Sink> annotation.

If the method does is not directly related to information flow (its inputs
and outputs could be anything and are not required to have a specific
\<@Source> annotation), then either added the method to the stub file with no 
annotations, which is the same as annotating the returns and parameters with
\<@Source(LITERAL)> or to annotate it with \<@PolyFlow> or \<@PolyFlowReceiver>, 
which essentially says that the
output can have all the flow sources and sinks of the inputs..
(See Section \secref{sec:addtionalanno} for more details.)

\end{itemize}

\noindent
\textbf{Important:}
After changing or adding stub files, run \<ant jar> to rebuild \<sparta.jar>.



The stub files can include any third-party library that is not compiled
along with your application.  You can add a new \<.astub> file to the
\<flowstubfiles/> directory.
Alternately, you can put a new \<.astub> file elsewhere and then pass this
file to the \<ant check-flow> target:

\begin{alltt}
ant -Dstubs=\emph{path/myAnnoLib.astub} check-flow
\end{alltt}

Here is an example from a stub file:

\begin{Verbatim}
package android.telephony;

class TelephonyManager {
    public @Source(FlowPermission.PHONE_NUMBER) String getLine1Number();
    public @Source(FlowPermission.IMEI) String getDeviceId();
}
\end{Verbatim}

\noindent
The above annotates two methods in class \<TelephonyManager>.
It indicates that the \<getLine1Number> function returns a String that is a
phone number.  For more examples, look into the stub files. Also, see 
the
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries}}{Annotating
  Libraries}'' chapter in the Checker Framework Manual\ifhevea\else\ (\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.pdf})\fi.


When creating a new stub file, see the section
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#stub-creating}}{Creating
  a stub file}'' in the Checker Framework Manual to learn how to create an
initial file and prevent a great deal of repetitive cut-and-paste editing.


It is usually a good idea to annotate an entire API class at a time, rather
than to just annotate the specific methods that your app uses.  Annotating
an entire class lets you think about it once, which takes less time in the
long run.  It also reduces confusion for people who will later wonder
whether a particular method was intended to be unannotated or had not yet
been annotated.


Note: at the end of this step, you have not yet added any annotations to
the app itself, only to libraries.

%
%\subsection{Task: visualize the existing flow in the application}
%
%You do not have to run this step --- you can skip it if you
%prefer.
%
%\todo{Why would I want to perform this step?  What would be the benefits?}
%
%Run \<ant flowshow> to get a report of the
%existing flow.
%For every type use in the application, it indicates the flow sources
%and sinks for that variable. This is exactly the annotations written
%in the program, plus possibly some additional annotations that are
%inferred by the Checker Framework.
%
%%We don't support this
%%The \<-json> version creates file flowshow.json that can be visualized
%%separately.
%
%This step does not perform type-checking; it only visualizes the flow
%information written in the program or libraries as annotations, or
%inferred from those annotations.
%
%
%For an unannotated program, the report will not be informative: it
%only contains API annotations that are propagated to local
%variables. The report will become more informative as you add more and
%more annotations to the application. So, you can periodically rerun
%this step. 


\subsection{Write information flow types for the app\label{flow-task-annotate-app}}

Write information flow annotations for your application, in the same way as
you did for the libraries.  Read the documentation, decide on the types,
and write those.  A fast and effective way to do this is to grep the source
code for words related to information flow properties, such as ``camera''
or ``network''.  These words might appear in documentation or in source
code.  Wherever the words appear, you may be able to write information flow
type qualifiers.  This approach is both faster and less error-prone than
iteratively running the type-checker and fixing the errors that it reports
one-by-one.

\todo{provide a tool that does this grepping.  Also tell the user how to
take advantage of the \<@RequiredPermissions> annotations and other tool
output.}


Focus on the most interesting flow sources and try to connect the flow
sources and sinks in the application. Instead of trying to completely
annotate only the sources or only the sinks, skim over all the reports
and use your intuition to decide which parts of the application to
focus on. Try to focus on the parts with the (most) connections
between sources and sinks.

Most types will only use either a \srcsome or \sinksome
annotation.
The goal is to find places where you need both annotations, e.g. to
express that information that comes from the camera may go to the
network:

\begin{alltt}
    @Source(CAMERA)
    @Sink(INTERNET) Picture data;
\end{alltt}

Such a type connects sources and sinks and one needs to carefully
decide whether this is a desired information flow or not.
\begin{itemize}
\item If this is good information flow, then write both the \<@Source>
  and the \<@Sink> annotations at the same place. You will not
  receive any more error messages, but you can find all these places
  with grep or (better) with \<ant flowshow>.
\item If this is bad information flow, then either leave it unannotated,
  or annotate it but record both in the source code and elsewhere that
  you have found a security flaw.
\end{itemize}


Once you have written as many type qualifiers as possible, proceed to
type-checking (\secref{sec:run-type-checker}).

\subsubsection{Syntax for Parameterized Annotations\label{sec:parameterized-syntax}}
When using @FineSource and @FineSink annotations, they must be embedded in their
respective @Source and @Sink annotations, under attributes finesources and finesinks, respetively.
For example, if a Picture had an information flow of FILESYSTEM("/home/pics")->INTERNET("mydomain.org"),
then the annotation should have the syntax:

\begin{Verbatim}
  @Source(finesources={@FineSource(value=FILESYSTEM, params={"/home/pics"})})
  @Sink(finesinks={@FineSink(value=INTERNET, params={"mydomain.org"})}) Picture data;
\end{Verbatim}

\subsection{Type-check the information flow types in the application\label{sec:run-type-checker}}

Run the Information Flow Checker:

\begin{Verbatim}
  ant check-flow
\end{Verbatim}

Eliminate each warning in one of two ways.
\begin{enumerate}
\item Add annotations to method signatures and fields in the application, as
required by the type-checker. This essentially propagates the flow
information required by the APIs through the application.

\item Use \<@SuppressWarnings> to indicate safe uses that are safe for reasons
that are beyond the capabilities of the type system. Always write a
comment that justifies that the code is safe, and why the type system
cannot recognize that fact.

An example is a String literal that should be allowed to be sent
over the network. By default, every literal has \<@Sink(CONDITIONAL)> 
and \<@Source(LITERAL)>.

\begin{alltt}
    @SuppressWarnings("flow") // manually verified to not contain secret data
    @Sink(INTERNET) String url = "http://bazinga.com/";
\end{alltt}

Without warning suppression the assignment raises an error, because string literals
have a default annotation of \<Source(LITERAL)>. By adding the suppression, you
assert that it's OK to send this string to the network. 

\end{enumerate}

After you have corrected some of the errors, re-run \<ant check-flow>.
Repeat the process until there are no more errors, or until you find bad
code (malicious, or buggy and prone to abuse).

Note: If you want to suppress the \<NOT\_REVIEWED> warnings you can run the Information Flow Checker
in the following ways:

\begin{alltt}
    ant check-flow-ignorenr
\end{alltt}
or
\begin{alltt}
    ant -Dignorenr=on check-flow
\end{alltt}


\subsection{Trace information flows\label{sec:trace-types}}

On execution, the Information Flow Checker creates a file called \<forbiddenFlows.txt> in the current
working directory. This file contains a summary of all of the information flows
in the app that did not have a flow-policy entry when the Information Flow Checker was ran.
\<forbiddenFlows.txt> is recreated on every execution.

The Information Flow Checker caches the warning for each use of a forbidden flow.
This cache of flow warnings can be filtered, called flow-filtering, using the command:

\begin{Verbatim}
  ant filter-flows -Dfilter="SOURCE -> SINK"
\end{Verbatim}

\begin{itemize}

\item \<SOURCE> and \<SINK> should be replaced with the desired sensitive flow
permission to search for.

\item \<SOURCE> and \<SINK> can be the exact name of a flow permission or a regular
expression.

\item The -> is required. However only one of \<SOURCE> or \<SINK> are required.
\end{itemize}

To start tracing information flows, begin by running the Information Flow Checker:

\begin{Verbatim}
  ant check-flow
\end{Verbatim}

Next, inspect the \<forbiddenFlows.txt> file. Concrete flows are flows that do not have
\<\{\}> or \<CONDITIONAL> sinks. Each concrete flow should be evaluated:

\begin{itemize}
\item
If the flow is a desired information flow, add it to the flow-policy file.
\item
If the flow is a undesired information flow, do not add it to the flow-policy,
but record both in the source code and elsewhere that you have found a security flaw.
\end{itemize}

After evaluating concrete flows, select a source from the \<forbiddenFlows.txt> to trace.
\<LITERAL> sources should be traced last because the unannotated variables have
a default source of \<LITERAL> which may be revised. Use flow filtering to display
all forbidden flow locations for the selected source.

For example, if \<forbiddenFlows.txt> contains an entry \<CAMERA\flowsto \{\}>
this would indicate that a type \<@Source(CAMERA)> flows to a type that had no declared sinks,
\<@Sink(\{\})>. \<CAMERA> would be a candidate for tracing. The following command
could be used to perform flow-filtering for any flow with a source \<CAMERA>.

\begin{Verbatim}
  ant command filter-flows -Dflow-filter="CAMERA ->"
\end{Verbatim}

Flow-filtering displays the source code locations of forbidden flows in the app.
Inspect each source location and resolve the forbidden flow by adding annotations
or suppressing warnings as described in \secref{sec:run-type-checker}.

Iteratively run the flow-checker, check the \<forbiddenFlows.txt> file, and use flow-filtering
to trace forbidden flows throughout the app.  Eventually the selected source will flow
to one or more concrete sinks. Again, determine if these flow should be added to the flow-policy
or marked as malicious.

After adding a flow to the flow-policy and rerunning the Information Flow Checker, the flow
will no longer appear in the \<forbiddenFlows.txt> file. Select another sensitive
source file to trace and begin the process again.

Repeat the tracing process until there are no more errors, or until you find bad code
(malicious, or buggy and prone to abuse).

\subsection{Review sensitive sources used in conditionals}
\begin{Verbatim}
  ant check-conditionals
\end{Verbatim}
This ant target prints a warning for every non-literal source used in a conditional regardless
of the flow policy.  Review each warning a determine whether or not the code is leaking a 
sensitive value to a sensitive source. 

\subsection{Type-check with stricter checking}

Once all warnings were resolved, run 

\begin{Verbatim}
  ant -Dsound=true check-flow
\end{Verbatim}

\noindent
Providing the \<sound> option enables additional checks that are
required for soundness, but would be disruptive to enable initially.
In particular, the tests for casts and array subtyping are stricter.
See the discussion in \chapterpageref{flow-checker}.

This option will also use the stricter conditional rule. (\<LITERAL
\flowsto{} CONDITIONAL> rather than the relaxed \<ANY \flowsto{} CONDITIONAL>)


\subsection{Component map generation\label{component-map-generation}}
To generate a component map for an application, the \<generate-cm> script, which 
can be found in the sparta-code folder, is used.
It receives as arguments the path of the application's apk and the output
path of the component map. The second one is optional and the component map
will be output to a file named component-map in the same folder as the apk if 
it is not specified. The apk of the application must be built without
annotations.
\begin{alltt}
generate-cm [path to app's .apk] [component map path]
\end{alltt}

The \<generate-cm> script reads a file named \<filter-map> 
located at \<src/sparta/checkers/intents/componentmap/filter-map>. 
This file contains
information about every android system component and using it the intent
analysis can identify if a component from the analyzed app might interact
with one of the android system components. It uses the intent filters
from the manifest file of the application to find this information.

The filter-map can be auto-generated and include information about other
apps that might interact with the current app being analyzed. To generate
the filter-map file, create a folder with  every .apk of the apps
that might interact with the app being analyzed and run the \<generate-filters>
 script located at the sparta-code folder as follows:
 
\begin{alltt}
generate-filters [path to a folder containing .apk files]
\end{alltt}

Currently the component map generation does not differentiate intent filters
with same action and categories but different data (URI). Every communication
that might involve URIs will be shown commented in the component map so that
the developer can uncomment the ones he think in fact occur after manually
analyzing the code.


%\todo{Why does the path have to be fully qualified? Can't we change the script so it can be relative?}
%\todo{Also, it would be nice if the script could be run from any directory.} 
%\todo{Add the caveat that the apk must be build with out annotations}
%\todo{Explain the generate-filter script} 
%\todo{Explain the URI limitation}

\subsection{Annotating components from other applications}
In case the application being analyzed communicates with components from
other apps, these components need to be correctly annotated and added in the 
\<annotated-intent-receivers> folder.

\subsection{Running the intent analysis with \TheFlowChecker{}}

Run \theFlowChecker{} in the command line with \<check-intent> instead of
\<check-flow> like the following command: 


\begin{alltt}
ant -DflowPolicy=myflowpolicy -DcomponentMap=mycomponentmap check-intent
\end{alltt}

Alternatively, it is possible to omit the \<-DComponentMap> parameter if the 
path of the component map is in the 
build.xml file of the application. This can be done by adding the following 
line to the build.xml file where component-map will contain the path of the file:

\begin{alltt}
<property name="componentMap" value="component-map"/>
\end{alltt}
\todo{Isn't that the way how the flow policy is defaulted to flow-policy?}

If the Information Flow Checker produces any errors or warnings, then the app
has not been properly annotated and should be rejected.

Below there are a few common warnings and errors from the intent analysis and 
how to solve them:

\subsubsection{Error: could not find receivers}

\begin{Verbatim}
error: Could not find receivers for class: ActivityA(action1,[cat1,cat2])
\end{Verbatim}

To solve this error you need to add an entry in the component map from 
ActivityA to one or more components. For example:

\begin{Verbatim}
ActivityA(action1,[cat1,cat2]) -> com.example.ActivityB
\end{Verbatim}

\subsubsection{Warning: getintent.not.found}

\begin{Verbatim}
warning: [getintent.not.found] 
 startActivity(senderIntent1);
               ^
Could not find the receiver component: com.example.ActivityB or it has not
overridden the getIntent() method.
\end{Verbatim}

To solve this warning you need to override the getIntent() method in ActivityB.
This can be done, for example, as follows:

\begin{Verbatim}
@Override
    public @IntentMap({ @Extra(key = "k5", source = { ACCESS_FINE_LOCATION },
		sink = {}) }) 
	Intent getIntent() {
		@SuppressWarnings("")
		@IntentMap({ @Extra(key = "k5", source = {
			ACCESS_FINE_LOCATION }, sink = {}) }) 
		      Intent output = super.getIntent();
		      return output;
	}
\end{Verbatim}

\subsubsection{Warning: intent.type.incompatible}

\begin{Verbatim}
ActivityTest.java:57: warning: [intent.type.incompatible] 
[jsr308.javac]         i1.putExtra("k2", getVal());
[jsr308.javac]                    ^
[jsr308.javac]   The @IntentMap annotation of i1 contains an element with Key k2
that is incompatible with the type it is receiving. Expected a subtype of:
Source:
@sparta.checkers.quals.Source({sparta.checkers.quals.FlowPermission.ACCESS_FINE_LOCATION}).
Sink:
@sparta.checkers.quals.Sink({sparta.checkers.quals.FlowPermission.DISPLAY}).
Received: Source:
@sparta.checkers.quals.Source({sparta.checkers.quals.FlowPermission.FILESYSTEM}).
Sink:
@sparta.checkers.quals.Sink({sparta.checkers.quals.FlowPermission.INTERNET}).
\end{Verbatim}

The type of i1 is: 
\begin{Verbatim}
@IntentMap({@Extra(key = "k2", source = {ACCESS_FINE_LOCATION}, sink = {DISPLAY})
})
\end{Verbatim}

To solve this warning you need to change the type of i1 to:

\begin{Verbatim}
@IntentMap({@Extra(key = "k2", source = {FILESYSTEM}, sink = {INTERNET})})
\end{Verbatim}

\subsubsection{Warning: send.intent}

\begin{Verbatim}
warning: [send.intent] 
startActivity(senderIntent2);
                ^
Forbidden communication. 
Intent type found:
@sparta.checkers.quals.IntentMap({@sparta.checkers.quals.Extra(key="k5",
source={sparta.checkers.quals.FlowPermission.ANY}, sink={})}). 
[jsr308.javac]    
Intent type required:
@sparta.checkers.quals.IntentMap({@sparta.checkers.quals.Extra(key="k5",
source={sparta.checkers.quals.FlowPermission.ACCESS_FINE_LOCATION}, sink={})}). 
\end{Verbatim}

To solve this warning you need to change either the type of the sender intent
or the receiver intent so that the sender is copyable to the receiver. The
sender intent is \<senderIntent2> and the receiver can be found in the component
map.



\subsubsection{Warning: intent.key.notfound}

\begin{Verbatim}
warning: [intent.key.notfound] 
String s4 = i1.getStringExtra("k4");
                              ^
Key k4 missing from @IntentMap annotation of i1!
\end{Verbatim}

To solve this warning you need to add an \<@Extra> in the \<@IntentMap> from
\<i1> containing \<k4> as a key.



\subsubsection{Warning: intent.key.variable}
\begin{Verbatim}
warning: [intent.key.variable] 
i1.putExtra(VALUE_KEY, getVal());
             ^
Key VALUE_KEY cannot be resolved at compile time.
\end{Verbatim}

To solve this warning you need to replace \<VALUE\_KEY> with its   
String value.





%\todo{Show some examples of IntentChecker warnings and how to correct them}






%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  App xml env basename sparta dir app check-flow Dstrict SDK
%  LocalWords:  report-suspicious report-permissions reportapiusage buildfile dirname
%  LocalWords:  AndroidManifest classpath java flowpolicy enum astub app's
%  LocalWords:  RequiredPermissions Source Sink apiusage Dstubs
%  LocalWords:  flowstubfiles TelephonyManager getLine1Number flowshow url
%  LocalWords:  PolySource PloySink FlowPermission FlowPermission grep
%  LocalWords:  Dstricter
