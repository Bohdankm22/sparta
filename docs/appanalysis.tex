\htmlhr
\chapter{How to Analyze an Unannotated App\label{analyze-unannotated-app}}

If you are presented with an unannotated app and wish to confirm that it
contains no malware, then you need to perform three tasks:
\begin{itemize}
\item
  Look for obvious malware.
\item
  Run reverse-engineering tools to understand the application.
\item
  Write and check information-flow type qualifiers to ensure that the
  program has no undesired information flow.
\end{itemize}


More specifically, the recommended workflow is:

\begin{enumerate}
\item Set up the app for analysis by the SPARTA tools; see \secref{sec:antsetup}
\item Write the flow policy; see \secref{sec:write-flow-policy}
\item Run reverse-engineering tools; see \secref{sec:reverse-engineering}
\item Write and check information flow type qualifiers; see \secref{verify-information-flow-security}
\end{enumerate}

% \noindent 
% The tools should be run in the following order. 
% 
% \begin{enumerate}
% \item ant report-suspicious (also runs sparta-code/suspicious.pl)
% \item ant report-permissions
% \item ant reportapiusage
% \item ant check-flow
% \end{enumerate}
% 
% \noindent 
% The rest of this chapter gives more details about each step in the analysis process.




\section{Write a flow-policy file\label{sec:write-flow-policy}}

Write a flow-policy file.  \secref{sec:flow-policy} describes flow policies.

\subsection{Read the app description}
\label{sec:read-the-app-description}

Read the App description and user documentation, looking for clues about
the permissions, sensitive sources, and sinks and how information
flows between them.  For example,
if this is a map app, does the description say anything about sending your location data over the
 network?  If so, then you should add \<LOCATION\flowsto INTERNET> to the flow-policy file.  Where
else does the description say location data can go?   

Theoretically, you should be able to write a complete Flow Policy from the
description if the description is well-written and the app does not contain
malware.  In practice, you will have to add flows to the policy file as you
more fully annotate the app, but you should ensure that they are reasonable
and make note of what additional flows you had to add.
 

\subsection{Read the manifest file}

Look at the \<AndroidManifest.xml> file and:
\begin{itemize}
\item Determine which permissions the app uses --- the ``uses-permission''
  entries in the manifest file.

  (If you are short on time, you could start with reading the manifest file
  rather than first reading the app description as recommended in
  \secref{sec:read-the-app-description}.  But determining the permissions
  from the documentation will be more effective in finding problems in
  either the documentation or the code.)
\item Compare the used permissions with the description of the
  application and determine whether or not they are well justified.
  If an application uses certain permissions that are not justified
  in the description, this indicates suspicious code. 
  (To determine where these permissions are used in the application,
   see \ref{sec:appanalysis/report-permissions})


\item Determine the entry points into the source code. (This may also give
  a hint about the architecture or overall modular structure of the
  application.)
  Look for ``activity'', ``intent-filter'', ``service'', ``receiver'', and
  ``provider'' to see the entry points, intent messages it responds to,
  etc.

  \todo{What is the point of this step?  Does it inform the creation of
  the flow policy?  Or should it be moved later into the reverse
  engineering steps of \secref{sec:reverse-engineering}? }
\end{itemize}



\section{Run reverse-engineering tools\label{sec:reverse-engineering}}

\subsection{Review constant strings used}
\label{sec:appanalysis/strings}

Run

\begin{Verbatim}
  ant report-strings
\end{Verbatim}
\noindent
to get a list of all constant strings used in the the program grouped by
category.  A file, \<found-strings.txt> ,  in the sparta-out directory, lists a
summary of all strings used in the app grouped by category.   Categories are
URLs, content URIs, class names, file or path names, SQL statements, messages
to the user, and no category.  Each string is only assigned to one category.
This ant target also reports where in the code the string was found. For
example,
 
\begin{Verbatim}
.../MapActivity.java:41: warning: [found.url] 
 	 intent.setData(Uri.parse("http://darknessmap.com"));
 	                         ^
   Possible URL string: http://darknessmap.com 
\end{Verbatim}
\noindent
shows where a URL string is found in the found.  

\subsection{Review suspicious code and API uses}
\label{sec:appanalysis/suspicious}

Run

\begin{Verbatim}
  ant report-suspicious
\end{Verbatim}

\noindent
to get a list of the most suspicious code
locations. 
The code may be innocuous, but a human should examine it.

This target reports
\begin{itemize}
\item
  uses of potentially dangerous APIs, including reflection, randomness,
  thread spawning, and the ACTION VIEW intent.

  The file \<sparta-code/src/sparta/checkers/suspicious.astub> contains the classes and methods that are considered suspicious.

The following example from the \<suspicious.astub> file reports all calls
of the \verb|invoke| method and, additionally, all constructor calls 
of the class \verb|java.util.Random|:

\begin{Verbatim}
package java.lang.reflect;                                             
class Method {                                                         
    @ReportCall                                                        
    public Object invoke(Object obj, Object [] objs) {}                
}                                                                      
                                                                       
package java.util;                                                     
@ReportCreation                                                        
class Random {}
\end{Verbatim}

\item
  suspicious String patterns (e.g., hard-coded URIs and IP and MAC addresses) 
  in \verb|.java| and \verb|strings.xml| files.  The searched-for patterns
  appear in the script \<sparta-code/suspicious.pl>.

\todo{ This level of implementation detail is not appropriate for this manual.
It should appear in the documentation of the script itself.
Generally, the \<sparta-code/suspicious.pl> script takes two arguments:
 \begin{enumerate}
  \item root-dir: The directory in which the script recursively 
        searches for the given patterns (built-in or argument\#2)
  \item pattern (optional): Search pattern to use instead of the
 built-in ones. 
 \end{enumerate} 
 }

\end{itemize}

If you learn of additional suspicious API uses or String patterns, please
inform the SPARTA developers so they can add them to the
\<suspicious.astub> or \<suspicious.pl> file.


\subsection{Review where permissions are used in the application}
\label{sec:appanalysis/report-permissions}


Run

\begin{Verbatim}
  ant report-permissions
\end{Verbatim}

\noindent
to see where the application calls API methods that may require some Android permissions.  
The \<ant report-permissions> tool will help you gain an understanding of how your
app first obtains information from a sensitive source, or how your app
finally sends information to a sensitive sink.  This may help you decide
what parts of the app to further investigate, or where to start your
annotation work.

There are three possible types of errors you will see. The first error:

\begin{Verbatim}
MainActivity.java:35: 
error: Call require permission(s) [android.permission.SET_WALLPAPER], 
but caller only provides []!
			clearWallpaper();
			              ^
\end{Verbatim}
This error means the method requires one or more permissions which the caller does not have.
The second error:

\begin{Verbatim}
MediaPlayerActivity.java:218:
error: Call may additionally require permission(s) 
[android.Manifest.permission.WAKE_LOCK], but caller only provides []! 
Notes: WAKE_LOCK is required if MediaPlayer.setWakeMode has been called first.
			          stop();
			              ^
\end{Verbatim}

This error means the method may or may not require one or more permissions which the caller
does not have. An explanation for the current error can be seen on the \<Notes>. 

\begin{Verbatim}
HelloWorldActivity.java:83: warning: If the constant DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED 
is passed to an intent it will require following permission(s): [android.permission.BIND_DEVICE_ADMIN]! 
i.setAction(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED);
            ^
\end{Verbatim}

This error means that the constant used depends on one or more permissions.

You can eliminate the first 2 errors by writing
\<@RequiredPermissions({android.Manifest.permission.\emph{PERMISSION}})> or
\<@MayRequiredPermissions({android.Manifest.permission.\emph{WAKE\_LOCK}})> in
front of the method header in the source code, if you would like to propagate the
required permission up the call stack. 
You should use 
\<@MayRequiredPermissions( value={android.Manifest.permission.\emph{PERMISSION}},
notes=java.lang.String)> in case the permission may be required and you should 
explain the reason on the \<notes> argument.
However, it is not necessary to eliminate all the errors from RequiredPermissions.   
The \<report-permissions> tool is only a tool to guide your annotation and manual analysis effort. 

Any permission that is required should already be listed in the
\<AndroidManifest.xml> file.

The permissions required by the Android API appear in file
\<src/sparta/checkers/permission.astub>, expressed as
\<@RequiredPermissions> and \<@MayRequiredPermissions> annotations.



\todo{ The required permission information is based on Android 2.2
 information. Explain the caveat of Android 4.0 changes and the issue
 with "entry-method" checks versus correct checking on all
 possible paths into an API.}

\section{Verify information flow security\label{verify-information-flow-security}}

When the goal is to completely annotate an application it is
most effective to write information flow annotations in a bottom up approach:
first annotate libraries your code uses, then your packages and classes
that use those libraries, and so forth up to the entry points of your application.
Alternatively, when the goal is to investigate specific information flows, it is
more effective to trace and annotate only the flows of interest.
Libraries should still be annotated first for all flows types.
A bottom up approach can be used as a first pass to annotate large portions of an
application while tracing can be then used to find and fix remaining Information Flow Checker warnings.
Both approaches use the flow-policy create in \secref{sec:write-flow-policy}.

\secref{flow-task-annotate-apis} describes how to annotate libraries,
\secref{flow-task-annotate-app} and \secref{sec:run-type-checker} describe how to
annotate your own code in a bottom up approach, and \secref{sec:trace-types} describes
how to iteratively trace sensitive sources in your application.


\subsection{Write information flow types for library APIs\label{flow-task-annotate-apis}}

When the Information Flow Checker type-checks your code that calls a library API, the
Information Flow Checker needs to know the effect of that call.  
Stub files in \<sparta-code/src/sparta/checkers/flowstubfiles/> provide
that information.  You may need to enhance those stub files, if they do not
yet contain information about the library APIs that your application uses.
(Over time, the stub files will become more complete, and you will have to
do less work in this step for each new app.)

Run \<ant check-flow> to create the \<missingAPI.astub> file. For each method in the 
file do the following.  
\begin{itemize}
\item
Read the Javadoc.
\item
Decide what flow properties the method has.  Take care with this step,
because your decision will be trusted, not checked.  If you make a mistake,
the Information Flow Checker's results will not be sound.
\item
Add the method to the stub file that corresponds to the class package, with
appropriate flow properties expressed as \<@Source(...)> and
\<@Sink(...)> annotations.
It would be unusual for an API method to contain both a \<@Source>
and a \<@Sink> annotation.

If the method does is not directly related to information flow (its inputs
and outputs could be anything and are not required to have a specific
\<@Source> annotation), then either added the method to the stub file with no 
annotations, which is the same as annotating the returns and parameters with
\<@Source(LITERAL)> or to annotate it with \<@PolyFlow> or \<@PolyFlowReceiver>, 
which essentially says that the
output can have all the flow sources and sinks of the inputs..
(See Section \secref{sec:addtionalanno} for more details.)

\end{itemize}

\noindent
\textbf{Important:}
After changing or adding stub files, run \<ant jar> to rebuild \<sparta.jar>.



The stub files can include any third-party library that is not compiled
along with your application.  You can add a new \<.astub> file to the
\<flowstubfiles/> directory.
Alternately, you can put a new \<.astub> file elsewhere and then pass this
file to the \<ant check-flow> target:

\begin{alltt}
ant -Dstubs=\emph{path/myAnnoLib.astub} check-flow
\end{alltt}

Here is an example from a stub file:

\begin{Verbatim}
package android.telephony;

class TelephonyManager {
    public @Source(FlowPermission.PHONE_NUMBER) String getLine1Number();
    public @Source(FlowPermission.IMEI) String getDeviceId();
}
\end{Verbatim}

\noindent
The above annotates two methods in class \<TelephonyManager>.
It indicates that the \<getLine1Number> function returns a String that is a
phone number.  For more examples, look into the stub files. Also, see 
the
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries}}{Annotating
  Libraries}'' chapter in the Checker Framework Manual\ifhevea\else\ (\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.pdf})\fi.


When creating a new stub file, see the section
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#stub-creating}}{Creating
  a stub file}'' in the Checker Framework Manual to learn how to create an
initial file and prevent a great deal of repetitive cut-and-paste editing.


It is usually a good idea to annotate an entire API class at a time, rather
than to just annotate the specific methods that your app uses.  Annotating
an entire class lets you think about it once, which takes less time in the
long run.  It also reduces confusion for people who will later wonder
whether a particular method was intended to be unannotated or had not yet
been annotated.


Note: at the end of this step, you have not yet added any annotations to
the app itself, only to libraries.

%
%\subsection{Task: visualize the existing flow in the application}
%
%You do not have to run this step --- you can skip it if you
%prefer.
%
%\todo{Why would I want to perform this step?  What would be the benefits?}
%
%Run \<ant flowshow> to get a report of the
%existing flow.
%For every type use in the application, it indicates the flow sources
%and sinks for that variable. This is exactly the annotations written
%in the program, plus possibly some additional annotations that are
%inferred by the Checker Framework.
%
%%We don't support this
%%The \<-json> version creates file flowshow.json that can be visualized
%%separately.
%
%This step does not perform type-checking; it only visualizes the flow
%information written in the program or libraries as annotations, or
%inferred from those annotations.
%
%
%For an unannotated program, the report will not be informative: it
%only contains API annotations that are propagated to local
%variables. The report will become more informative as you add more and
%more annotations to the application. So, you can periodically rerun
%this step. 


\subsection{Write information flow types for the app\label{flow-task-annotate-app}}

Write information flow annotations for your application, in the same way as
you did for the libraries.  Read the documentation, decide on the types,
and write those.  A fast and effective way to do this is to grep the source
code for words related to information flow properties, such as ``camera''
or ``network''.  These words might appear in documentation or in source
code.  Wherever the words appear, you may be able to write information flow
type qualifiers.  This approach is both faster and less error-prone than
iteratively running the type-checker and fixing the errors that it reports
one-by-one.

\todo{provide a tool that does this grepping.  Also tell the user how to
take advantage of the \<@RequiredPermissions> annotations and other tool
output.}


Focus on the most interesting flow sources and try to connect the flow
sources and sinks in the application. Instead of trying to completely
annotate only the sources or only the sinks, skim over all the reports
and use your intuition to decide which parts of the application to
focus on. Try to focus on the parts with the (most) connections
between sources and sinks.

Most types will only use either a \srcsome or \sinksome
annotation.
The goal is to find places where you need both annotations, e.g. to
express that information that comes from the camera may go to the
network:

\begin{alltt}
    @Source(CAMERA)
    @Sink(INTERNET) Picture data;
\end{alltt}

Such a type connects sources and sinks and one needs to carefully
decide whether this is a desired information flow or not.
\begin{itemize}
\item If this is good information flow, then write both the \<@Source>
  and the \<@Sink> annotations at the same place. You will not
  receive any more error messages, but you can find all these places
  with grep or (better) with \<ant flowshow>.
\item If this is bad information flow, then either leave it unannotated,
  or annotate it but record both in the source code and elsewhere that
  you have found a security flaw.
\end{itemize}


Once you have written as many type qualifiers as possible, proceed to
type-checking (\secref{sec:run-type-checker}).

\subsubsection{Syntax for Parameterized Annotations\label{sec:parameterized-syntax}}
When using @FineSource and @FineSink annotations, they must be embedded in their
respective @Source and @Sink annotations, under attributes finesources and finesinks, respetively.
For example, if a Picture had an information flow of FILESYSTEM("/home/pics")->INTERNET("mydomain.org"),
then the annotation should have the syntax:

\begin{Verbatim}
  @Source(finesources={@FineSource(value=FILESYSTEM, params={"/home/pics"})})
  @Sink(finesinks={@FineSink(value=INTERNET, params={"mydomain.org"})}) Picture data;
\end{Verbatim}

\subsection{Type-check the information flow types in the application\label{sec:run-type-checker}}

Run the Information Flow Checker:

\begin{Verbatim}
  ant check-flow
\end{Verbatim}

Eliminate each warning in one of two ways.
\begin{enumerate}
\item Add annotations to method signatures and fields in the application, as
required by the type-checker. This essentially propagates the flow
information required by the APIs through the application.

\item Use \<@SuppressWarnings> to indicate safe uses that are safe for reasons
that are beyond the capabilities of the type system. Always write a
comment that justifies that the code is safe, and why the type system
cannot recognize that fact.

An example is a String literal that should be allowed to be sent
over the network. By default, every literal has \<@Sink(CONDITIONAL)> 
and \<@Source(LITERAL)>.

\begin{alltt}
    @SuppressWarnings("flow") // manually verified to not contain secret data
    @Sink(INTERNET) String url = "http://bazinga.com/";
\end{alltt}

Without warning suppression the assignment raises an error, because string literals
have a default annotation of \<Source(LITERAL)>. By adding the suppression, you
assert that it's OK to send this string to the network. 

\end{enumerate}

After you have corrected some of the errors, re-run \<ant check-flow>.
Repeat the process until there are no more errors, or until you find bad
code (malicious, or buggy and prone to abuse).

Note: If you want to suppress the \<NOT\_REVIEWED> warnings you can run the Information Flow Checker
in the following ways:

\begin{alltt}
    ant check-flow-ignorenr
\end{alltt}
or
\begin{alltt}
    ant -Dignorenr=on check-flow
\end{alltt}

\subsection{Type-check information flow types across communicating components}
This section explains how to generate a component map file for an app, how to
run \theIntentChecker{} for this app and remove the raised false warnings.

\subsubsection{Component map file generation\label{component-map-generation}}
The component map contains information about inter-component communication of
an app. To type-check information flow types across communicating components of
an app, a component map file must be generated for that app. The steps to
generate a component map file are listed below:

\begin{enumerate}

\item
Build the target app by running \<ant debug> in the app's project folder. This
creates an .apk file inside the project \<bin/> directory, named
\<project\_name-debug.apk>.

\item
Create a folder containing the target app's .apk file and all .apk files from
the apps that may communicate with the target app. If there are no apps
communicating with the target app, skip to step 4.

\item
Run the
\<generate-filters> script located in the \<sparta-code> folder as follows:
 \begin{alltt}
 generate-filters   \textit{path\_to\_folder\_containing\_.apk\_files}
 \end{alltt}
\item
Run the \<generate-cm> script, which is located in the \<sparta-code> folder. It
receives as argument the \<path> of the application's .apk and it outputs a file
named \<component-map> into the \<path/sparta-out/> directory.
\begin{alltt}
generate-cm   \textit{path\_to\_app's\_.apk}
\end{alltt}
\end{enumerate}

Example of a generated component map file:
\begin{alltt}
com.VideoActivity.onOptionsItemSelected(MenuItem) -> com.VideoActivity.PictureListActivity
com.VideoActivity.GCMRegistrar.internalRegister(String[]) -> com.gtalkservice.PushMessaging

#Broadcast Receivers:
#com.VideoActivity.AboutUs.onDestroy(Bundle) -> BroadcastReceiver registered in
                                com.VideoActivity.DisplayService.onBind(Intent)

#Unresolved Intents:
com.VideoActivity.AboutUs.onCreate(Bundle) -> unknown

#The following communication occurs with uses of URIs:
#com.VideoGame.DisplayService\$3.run() -> com.VideoActivity.MyBringBack
#com.VideoGame.DisplayService\$3.run() -> com.VideoActivity.SoundListActivity

\end{alltt}

After the component map file is generated, it is possible to refine it if
receiver components could not be resolved in some cases. To check if your
\<component-map> can be refined, open it and look for the comments:
\begin{itemize}
\item
\<\#Broadcast Receivers:> BroadcastReceivers can be dynamically registered to
receive intents. The generated component map shows where a BroadcastReceiver
is registered, so the user can manually inspect it to replace the 
location with a component. The example above suggests that the user must inspect
the method \<onBind(Intent)> from the class \<DisplayService> to find out which
BroadcastReceiver is registered in that method that receives an intent sent at
\<AboutUs.onDestroy(Bundle)>.
\item
\<\#Unresolved Intents:> The receiver component could not be statically
resolved and a manual inspection is needed to refine these cases. In the
example above the \<onCreate(Bundle)> method of the class \<AboutUs>
must be inspected to find out the correct receiver components of this intent.
\item
\<\#The following communication occurs with uses of URIs:> The component map
generation does not differentiate intent filters with the same action and
categories but different data (URI). Every communication that uses URIs will be
shown commented in the component map file so that the developer can uncomment
the ones he think in fact occur after manually inspecting the code.
\end{itemize}

\subsubsection{Annotating components from other applications}
In case the app being analyzed communicates with components from
other apps, these components need to be correctly annotated and you need to add
their .java files in the \<sparta-code/annotated-intent-receivers>, or in the
target app's source code directory. You should stick with the first option if the
component you are adding is an Android system component, so it can be used in
future analyses.

\subsubsection{Running \theIntentChecker{} with \theFlowChecker{}}

\TheIntentChecker{} type-checks information flow types across communicating
components and within components. To run \theIntentChecker{} with
\theFlowChecker{} from the command line use the command \<check-intent> instead
of \<check-flow>:

\begin{alltt}
    ant [-DflowPolicy=myflowpolicy] [-DcomponentMap=mycomponentmap] check-intent
\end{alltt}

\subsubsection{Common warnings and errors in \theIntentChecker{}}

Below there is a description of each warning and error from \theIntentChecker{}
and how to solve it:
\subsubsection{Error: intent.receiver.notfound}

This error occurs when type-checking a \sendIntent{} call whose method in which
it is called is not in the component map file. This happens when the component
map file wasn't correctly generated or when it is necessary to do a manual
inspection to add the correct receivers of an intent.

\begin{Verbatim}
error: Could not find receivers for the intent sent in method: com.package.ActivityA.foo().
Please add an entry in the component map file from this method to one or more components.
\end{Verbatim}

\todo{add this in the warning message}
To solve this error, you must first make sure the component map file was
correctly generated. In case it was, you need to manually inspect the method
stated in the error message and add an entry in the component map file from this
method to one or more components. For example:

\begin{Verbatim}
com.package.ActivityA.foo() -> com.package.ActivityB
\end{Verbatim}

\subsubsection{Warning: intent.getintent.notfound}
This warning occurs when type-checking a \<setIntent> declaration in a component
that has not overridden the \<getIntent> method. As explained in the bottom of
Section \ref{override-onreceive}, every Activity that calls the method
\<getIntent> must override both methods \<setIntent> and \<getIntent>.

\begin{Verbatim}
ReceiverIntentTest.java:25: warning: [intent.getintent.notfound] 
     public void setIntent(@IntentMap({ @Extra(key = "k5", source = 
                              { ACCESS_FINE_LOCATION }, sink = {}) }) 
                 ^
Could not find getIntent() method implementation in the same component of this setIntent call.
Please override the getIntent() method in this component.
\end{Verbatim}

To solve this warning you need to override the \<getIntent> method in 
\<ReceiverIntentTest.java> and annotate its return type with a supertype of the
\<setIntent> parameter:

\begin{Verbatim}
@Override
public @IntentMap({ @Extra(key = "k5", source = { ACCESS_FINE_LOCATION },
                                        sink = {})} Intent getIntent() {
    return super.getIntent();
}
\end{Verbatim}

\subsubsection{Warning: send.intent.missing.key}
This warning occurs when either a key is missing from the sender's intent type
or should not be present in the intent type of the receiver.

\begin{Verbatim}
tests/intent/ActivityTest.java:128: warning: [send.intent.missing.key] 
            startActivity(senderIntent1);
                          ^
The key "k5" is either missing from the intent type of senderIntent1, or should
not be present in the intent type of 
com.package.ActivityReceiver.receiveIntent.setIntent()'s intent parameter.
\end{Verbatim}

To solve this warning you need to verify how this key is used in the receiver
component, to make sure that it makes sense for the receiver to have it in its
intent type. If that is the case, you need to add an \<@Extra> with this key in the
sender's intent type, otherwise remove the \<@Extra> with this key from the
receiver's intent type.

\subsubsection{Warning: send.intent.incompatible.types}
This warning occurs when an \<@Extra> from the sender's intent type has
\<@Source> and/or \<@Sink> types that are not subtypes of the receiver's
\<@Extra> with same key.

\begin{Verbatim}
tests/intent/ActivityTest.java:130: warning: [send.intent.incompatible.types] 
            startActivity(senderIntent2);
                          ^
senderIntent2 is not copyable to tests.ServiceReceiverStub.onStartCommand()'s 
intent parameter. The @Extra with key "k5" in the @IntentMap of senderIntent2 must be a
subtype of the @Extra with same key in the @IntentMap of 
tests.ServiceReceiverStub.onStartCommand()'s intent parameter.

senderIntent2's intent type:@sparta.checkers.quals.IntentMap({@sparta.checkers.quals.Extra(
key="k5", source={sparta.checkers.quals.FlowPermission.ANY}, sink={})}).

tests.ServiceReceiverStub.onStartCommand()'s intent parameter intent type:@sparta.checkers.
quals.IntentMap({@sparta.checkers.quals.Extra(key="k5", source={sparta.checkers.quals.
FlowPermission.ACCESS_FINE_LOCATION}, sink={})}).
\end{Verbatim}

To solve this warning you must first understand what should be the correct
intent type of both intent variables by checking how the key mentioned in the
warning is used in each component. You will need to either modify the intent type of
the sender, or the intent type of the receiver such that the \<@Extra> with the
key mentioned in the warning has the same type in both intent types. For the
example above, you could either modify the \<@Source> type of the \<@Extra> with
key \<"k5"> in \<senderIntent2>'s intent type to \<ACCESS\_FINE\_LOCATION>, or
modify the \<@Source> type of the \<@Extra> with key \<"k5"> 
in \<onStartCommand()'s intent parameter>'s intent type to \<ANY>.

\subsubsection{Warning: intent.key.notfound}
This warning occurs when a key \<"k"> is missing from the intent
type of an intent variable \<i> and either \<i.putExtra("k",val)> or
\<i.getExtra("k",default)> is called.

\begin{Verbatim}
 tests/intent/ConstCheckerTest.java:44: warning: [intent.key.notfound] 
         String test1 = i1.getStringExtra(k2OrPhoneNumber);
                                         ^
Key k2OrPhoneNumber missing from @IntentMap annotation of i1.
\end{Verbatim}

To solve this warning you need to add an \<@Extra> in the intent type of
\<i1> containing \<k2OrPhoneNumber>'s value as a key.

\subsubsection{Warning: intent.key.variable}
This warning occurs when a key is not a compile time constant.

\begin{Verbatim}
warning: [intent.key.variable] 
i1.putExtra(VALUE_KEY, getVal());
             ^
Key VALUE_KEY is not a compile time constant.
\end{Verbatim}

To solve this warning you need to replace \<VALUE\_KEY> by its compile time
constant value.

\subsubsection{Warning: argument.type.incompatible}
This warning occurs when an object is inserted into an intent's map but it
does not have the expected \<@Source> and/or \<@Sink> type according the
intent type.

\begin{Verbatim}
 IntentMapBottomTest.java:60: warning: [argument.type.incompatible] 
 incompatible types in argument.
         intentMapBottom1.putExtra("RandomKey1", getFile());
                                                        %^
found   : @IntentMap @Sink(FlowPermission.INTERNET) @Source(FlowPermission.FILESYSTEM) String
required: @IntentMap @Sink(finesinks=@sparta.checkers.quals.
    FineSink(value=sparta.checkers.quals.FlowPermission.ANY, 
    params={"*"}), value={}) @Source(finesources={}, value={}) String
\end{Verbatim}

To solve this warning you must first understand the \<@Source> and \<@Sink>
types of the object that is being inserted in the intent and annotate it
correctly. After that, you should modify the \<@Extra> of the
intent type with that key so that the type of \<@Extra> will match the object's
type. Considering the example above, you could either modify the \<@Extra> with
key \<"RandomKey1"> to have its \<@Source> as \<FILESYSTEM> and its \<@Sink> as
\<INTERNET>, or annotate the return type of
\<getFile()> with \<@Source({})> and \<@Sink(ANY)>. The first option is the best one
because it doesn't require a flow with \<@Sink(ANY)> in the flow-policy, which
is too permissive.


\subsection{Trace information flows\label{sec:trace-types}}

On execution, the Information Flow Checker creates a file called \<forbiddenFlows.txt> in the current
working directory. This file contains a summary of all of the information flows
in the app that did not have a flow-policy entry when the Information Flow Checker was ran.
\<forbiddenFlows.txt> is recreated on every execution.

The Information Flow Checker caches the warning for each use of a forbidden flow.
This cache of flow warnings can be filtered, called flow-filtering, using the command:

\begin{Verbatim}
  ant filter-flows -Dfilter="SOURCE -> SINK"
\end{Verbatim}

\begin{itemize}

\item \<SOURCE> and \<SINK> should be replaced with the desired sensitive flow
permission to search for.

\item \<SOURCE> and \<SINK> can be the exact name of a flow permission or a regular
expression.

\item The -> is required. However only one of \<SOURCE> or \<SINK> are required.
\end{itemize}

To start tracing information flows, begin by running the Information Flow Checker:

\begin{Verbatim}
  ant check-flow
\end{Verbatim}

Next, inspect the \<forbiddenFlows.txt> file. Concrete flows are flows that do not have
\<\{\}> or \<CONDITIONAL> sinks. Each concrete flow should be evaluated:

\begin{itemize}
\item
If the flow is a desired information flow, add it to the flow-policy file.
\item
If the flow is a undesired information flow, do not add it to the flow-policy,
but record both in the source code and elsewhere that you have found a security flaw.
\end{itemize}

After evaluating concrete flows, select a source from the \<forbiddenFlows.txt> to trace.
\<LITERAL> sources should be traced last because the unannotated variables have
a default source of \<LITERAL> which may be revised. Use flow filtering to display
all forbidden flow locations for the selected source.

For example, if \<forbiddenFlows.txt> contains an entry \<CAMERA\flowsto \{\}>
this would indicate that a type \<@Source(CAMERA)> flows to a type that had no declared sinks,
\<@Sink(\{\})>. \<CAMERA> would be a candidate for tracing. The following command
could be used to perform flow-filtering for any flow with a source \<CAMERA>.

\begin{Verbatim}
  ant command filter-flows -Dflow-filter="CAMERA ->"
\end{Verbatim}

Flow-filtering displays the source code locations of forbidden flows in the app.
Inspect each source location and resolve the forbidden flow by adding annotations
or suppressing warnings as described in \secref{sec:run-type-checker}.

Iteratively run the flow-checker, check the \<forbiddenFlows.txt> file, and use flow-filtering
to trace forbidden flows throughout the app.  Eventually the selected source will flow
to one or more concrete sinks. Again, determine if these flow should be added to the flow-policy
or marked as malicious.

After adding a flow to the flow-policy and rerunning the Information Flow Checker, the flow
will no longer appear in the \<forbiddenFlows.txt> file. Select another sensitive
source file to trace and begin the process again.

Repeat the tracing process until there are no more errors, or until you find bad code
(malicious, or buggy and prone to abuse).

\subsection{Review sensitive sources used in conditionals}
\begin{Verbatim}
  ant check-conditionals
\end{Verbatim}
This ant target prints a warning for every non-literal source used in a conditional regardless
of the flow policy.  Review each warning a determine whether or not the code is leaking a 
sensitive value to a sensitive source. 

\subsection{Type-check with stricter checking}

Once all warnings were resolved, run 

\begin{Verbatim}
  ant -Dsound=true check-flow
\end{Verbatim}

\noindent
Providing the \<sound> option enables additional checks that are
required for soundness, but would be disruptive to enable initially.
In particular, the tests for casts and array subtyping are stricter.
See the discussion in \chapterpageref{flow-checker}.

This option will also use the stricter conditional rule. (\<LITERAL
\flowsto{} CONDITIONAL> rather than the relaxed \<ANY \flowsto{} CONDITIONAL>)

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  App xml env basename sparta dir app check-flow Dstrict SDK
%  LocalWords:  report-suspicious report-permissions reportapiusage buildfile dirname
%  LocalWords:  AndroidManifest classpath java flowpolicy enum astub app's
%  LocalWords:  RequiredPermissions Source Sink apiusage Dstubs
%  LocalWords:  flowstubfiles TelephonyManager getLine1Number flowshow url
%  LocalWords:  PolySource PloySink FlowPermission FlowPermission grep
%  LocalWords:  Dstricter
