\htmlhr
\chapter{How to Analyze an Unannotated App\label{analyze-unannotated-app}}

\section{Description of tools, to work in}

These three tools are used to find potentially malicious code
 locations in an Android app.


\subsection{Suspicious API Tool\label{sec:suspicioustool}}

This tool reports uses of potentially dangerous APIs. These include uses of reflection, randomness, thread spawning, the ACTION VIEW intent, hard-coded strings such as URIs, and so forth. These APIs may be innocuous, but a human should examine their use.  The file \<src/sparta/checkers/suspicious.astub> contains the classes and methods that are considered suspicious.
 
\begin{alltt}
ant reportsuspicious
\end{alltt}

\subsection{Permission Tool\label{sec:permtool}}
  
This tool indicates every API call in the Android app that might require a permission.  The file src/sparta/checkers/permission.astub contains the Android API that has been annotated with \<@RequiredPermissions> and is used by this tool.

 \begin{alltt}
ant reqperms
\end{alltt}


\subsection{Android API Tool\label{sec:generaltool}}

This tool reports uses of Android and other APIs. These APIs are not suspicious in general. However, they do help the analyst to better understand the structure of the code not just with respect to its standard module structure, but in terms of how it interacts with Android interfaces. 


\begin{alltt}
ant reportapiusage
\end{alltt}


\section{Summary}

The recommended work flow is:  

\begin{enumerate}
\item Set up the app for analysis by the SPARTA tools; see \secref{sec:antsetup}
\item Read Description
\item Check Permissions in \<AndroidManifest.xml>
\item Write Flow Policy
\item Run Tools
\item Annotate Relevant APIs
\item After all errors are gone, run \<ant -Dstrict flowtest>
\end{enumerate}

\noindent 
The tools should be run in the following order. 

\begin{enumerate}
\item ant reportsuspicious (also runs sparta-code/suspicious.pl)
\item ant reqperms
\item ant reportapiusage
\item ant flowtest
\end{enumerate}

\noindent 
The rest of this chapter gives more details about each step in the analysis process.




\section{Task: get a basic understanding of the application}
Read the description of the application.  
Look at the AndroidManifest.xml file and:
\begin{itemize}
\item Determine which permissions the app uses.
  Look for ``uses-permission'' entries to understand the used
  permissions.
\item Compare the used permissions with the description of the
  application and determine whether or not they are well justified.
  If an application uses certain permissions that are not justified
  in the description, this indicates suspicious code. 
  (To determine where these permissions are used in the application,
   see \ref{sec:appanalysis/reqperms})
\item Determine the entry points into the source code. (This may also give
  a hint about the architecture or overall modular structure of the
  application.)
  Look for ``activity'', ``intent-filter'', ``service'', ``receiver'', and
  ``provider'' to see the entry points, intent messages it responds to,
  etc.
\end{itemize}

\section{Task: write a flow-policy file}

Use your understanding of the App to write a flow-policy file.  A full description of Flow Policies can be 
found in \secref{sec:flowpolicy}.   You should also familiarize yourself with all the possible sources and sinks; 
 all FlowSources  are
members of the enum \<sparta.checkers.quals.FlowSources.FlowSource> and all FlowSinks are
members of the enum \<sparta.checkers.quals.FlowSinks.FlowSink>.

To begin, read the App description, looking for clues about the information flow.  For example,
if this is a map app, does the description say anything about sending your location data over the
 network?  If so, then you should add LOCATION \flowsto{} NETWORK to the flow-policy file.  Where
else does the description say LOCATION data can go?   

Theoretically you should be able to write a complete Flow Policy from the description 
if the App does not contain malware.  In practice, you will have to add flows to the policy file as you
 more fully annotate the app, but you should make note of what additional flows you had to add.
 
 After you have written the flows that are apparent from the description, you may want to see if the App
  has any ``use permissions'' in the AndroidManifest.xml file that are not listed in the flow policy. 
  (Permissions are not one-to-one with sinks and sources, but the name of the permission should give 
  a clue about which sources and sinks are involved.)  For example, if the SEND\_SMS permission is 
  requested, then SMS should be listed as a flow sink somewhere in the policy file.  If this is not the 
  case, do not add it to the policy file, but pay close attention to how this permission is used in the 
  code.

\section{Task: check for the most suspicious code locations and API uses}
\label{sec:appanalysis/suspicious}
Run \<ant reportsuspicious> to get a list of the most suspicious code
locations. 
This target only reports about suspicious APIs that appear 
in the file:
\<sparta-code/src/sparta/checkers/suspicious.astub>. This report
provides the most suspicious code locations and is intended to help
localizing malware in an unannotated application.

The following example from the \<suspicious.astub> file reports all calls
of the \verb|invoke| method and, additionally, all constructor calls 
of the class \verb|java.util.Random|:

\begin{Verbatim}

package java.lang.reflect;                                             
class Method {                                                         
    @ReportCall                                                        
    public Object invoke(Object obj, Object [] objs) {}                
}                                                                      
                                                                       
package java.util;                                                     
@ReportCreation                                                        
class Random {}

\end{Verbatim}

In addition to running the report checker based on the 
\<suspicious.astub> file, the \<reportsuspicious> target executes
the script \<sparta-code/suspicious.pl>, which recursively searches for 
suspicious String patterns (i.e., URIs, or IP and MAC addresses) 
in \verb|.java| and \verb|strings.xml| files.
Generally, the \<sparta-code/suspicious.pl> script takes two arguments:
\begin{enumerate}
 \item root-dir: The directory in which the script recursively 
       searches for the given patterns (built-in or argument\#2)
 \item pattern (optional): Search pattern to use instead of the
built-in ones. 
\end{enumerate}
For each match, the script reports the file name, line
number, and the found pattern.

The \<suspicious.astub> and \<suspicious.pl> files should be enhanced
with additional API uses and String patterns that turn out to be 
malicious for every analyzed application. 


\section{Task: see where permissions are used in the application}
\label{sec:appanalysis/reqperms}

Run \<ant reqperms>  to see a list of the app's methods
that use calls that require certain Android permissions. You can use
this to gain an understanding of where sensitive information may come
from/go to in the application. This command produces errors like the following:
\begin{alltt}
error: Call additionally requires permissions [android.permission.INTERNET], 
   but caller only provides []!
\end{alltt}
You can remove the error by writing
\<@RequiredPermissions({android.Manifest.permission.\emph{PERMISSION}})> in front of the method header in the source code.

Once all methods in the subject application are correctly annotated,
\<ant reqperms> will not issue any warnings.
Search for \<@RequiredPermissions> to find the required permissions
in the application.

Any permission that is required should already be listed in the AndroidManifest.xml file. 



% TODO: The required permission information is based on Android 2.2
% information. Explain the caveat of Android 4.0 changes and the issue
% with "entry-method" checks versus correct checking on all
% possible paths into an API.


\section{Task: see what precise APIs are used where in the application}

Run \<ant reportapiusage> to get a report of the used APIs. The
\<reportapiusage> target only reports about APIs that appear in the file:
\<sparta-code/src/sparta/checkers/apiusage.astub>. This report is useful
for program comprehension but not intended to provide suspicious code
locations. For suspicious API use, see
\ref{sec:appanalysis/suspicious}.
%TODO: I think this belongs in the next section
%Additional \<.astub> files can be passed as \<-Astubs=...> argument in the
%build file.

The following example from \<apiusage.astub> causes the corresponding 
checker to report the use of all entities in the package 
\verb|com.android|:

\begin{Verbatim}
@ReportUse                                                         
package com.android;
\end{Verbatim}

The \<apiusage.astub> file should be enhanced during and after the 
analysis of an application --- add the entities that are most crucial to
understand the behavior of an application.



\section{Task: ensure that the used APIs are annotated with flow information\label{flow-task-annotate-apis}}

Stub files in  \<sparta-code/src/sparta/checkers/flowstubfiles> provides Android and Java
library annotations.  You may need to enhance it, if you find that your application
uses APIs that are not yet annotated.
(The  more APIs get annotated, the less work you will have to do in this
step for each new app.) You should not annotate libraries that are unique to your application in \<flowstubfiles>;
instead, annotated them in a new *.astub file. You can pass this file to be used with 
\emph{flowtest} or any of the other ant targets.

\begin{alltt}
ant -Dstubs=\emph{path/myAnnoLib.astub} flowtest
\end{alltt}

%Note that the \emph{fully qualified name} is required for \<FlowSources> and 
%\<FlowSinks> annotations in the \<> file.


An example:

\begin{Verbatim}
package android.telephony;

class TelephonyManager {
    public @FlowSources(FlowSource.PHONE_NUMBER) String getLine1Number();
    public @FlowSources(FlowSource.IMEI) String getDeviceId();
}
\end{Verbatim}

\noindent
The above annotates two methods in class \<TelephonyManager>.
It indicates that the \<getLine1Number> function returns a String which is a
phone number.  For more examples, look into the stub files. Also, see 
the manual \url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries}

For every API method used by this app (i.e., those output by \<ant
reportapiusage>) that does \emph{not} already appear a stub file do the following.
\begin{itemize}
\item
Read the Javadoc
\item
Decide what flow properties the method has.
\item
Add the method to the stub file that corresponds to the class package, with
appropriate flow properties expressed as \<@FlowSinks(...)> and
\<@FlowSources(...)> annotations.
It would be unusual for an API method to contain both a \<@FlowSources>
and a \<@FlowSinks> annotation.
\end{itemize}

If according to the description, the method has no flow, then the parameters and return type
 should be annotated with \<@PolyFlowSources @PloyFlowSinks>
  to preserve the flow information.


Note: you have not yet added any annotations to the app itself.


\section{Task: visualize the existing flow in the application}

You do not have to run this step --- you can skip it if you
prefer.

Run \<ant flowshow> to get a report of the
existing flow.
For every type use in the application, it indicates the flow sources
and sinks for that variable. This is exactly the annotations written
in the program, plus possibly some additional annotations that are
inferred by the Checker Framework.

%We don't support this
%The \<-json> version creates file flowshow.json that can be visualized
%separately.

This step does not perform type-checking; it only visualizes the flow
information written in the program or libraries as annotations, or
inferred from those annotations.


For an unannotated program, the report will not be informative: it
only contains API annotations that are propagated to local
variables. The report will become more informative as you add more and
more annotations to the application. So, you can periodically rerun
this step. 


\section{Task: check the flow in the application}

Run \<ant flowtest> on the application.
Eliminate each warning in one of two ways.
\begin{enumerate}
\item Add annotations to method signatures and fields in the application, as
required by the type-checker. This essentially propagates the flow
information required by the APIs through the application.

\item Use \<@SuppressWarnings> to indicate safe uses that are safe for reasons
that are beyond the capabilities of the type system. Always write a
comment that justifies that it is safe.
\end{enumerate}
A prime example is a String literal that should be allowed to be sent
over the network. By default, every literal has \<@FlowSinks()>
(i.e., nothing) and \<@FlowSources()>.

\begin{alltt}
    @SuppressWarnings("flow") // manually verified to not contain secret data
    @FlowSinks(FlowSink.NETWORK) String url = "http://bazinga.com/";
\end{alltt}

\noindent
Without suppression the assignment raises an error, because string literals
are assumed to be annotated with \<FlowSources(FlowSource.LITERAL)>. By adding the suppression, you
assert that it's OK to send this string to the network. 

Focus on the most interesting flow sources and try to connect the flow
sources and sinks in the application. Instead of trying to completely
annotate only the sources or only the sinks, skim over all the reports
and use your intuition to decide which parts of the application to
focus on. Try to focus on the parts with the (most) connections
between sources and sinks.

Most types will only use either a \<@FlowSources> or \<@FlowSinks>
annotation.
The goal is to find places where you need both annotations, e.g. to
express that information that comes from the camera may go to the
network:

\begin{alltt}
    @FlowSources(FlowSource.CAMERA)
    @FlowSinks(@FlowSink.NETWORK) Picture data;
\end{alltt}

Such a type connects sources and sinks and one needs to carefully
decide whether this is a desired information flow or not.
\begin{itemize}
\item If this is good information flow, then write both the \<@FlowSources>
  and the \<@FlowSinks> annotations at the same place. You will not
  receive any more error messages, but you can find all these places
  with grep or (better) with \<ant flowshow>.
\item If this is bad information flow, then either leave it unannotated,
  or annotate it but record both in the source code and elsewhere that
  you have found a security flaw.
\end{itemize}

You can continue to use \<ant flowshow> to visualize the annotation
progress.

\section{Task: run stricter tests}
Once all warnings were resolved, run \<ant -Dstricter=true flowtest> on
the application.
Providing the \<stricter> option enables additional checks that are
required for soundness, but would be disruptive to enable initially.
In particular, the tests for casts and array subtyping are stricter.
See the discussion in \chapterpageref{flow-checker}.

This option will also use the stricter conditional rule. (LITERAL
\flowsto{} CONDITIONAL rather than the relaxed ANY \flowsto{} CONDITIONAL)


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  App xml env basename sparta dir app flowtest Dstrict SDK
%  LocalWords:  reportsuspicious reqperms reportapiusage buildfile dirname
%  LocalWords:  AndroidManifest classpath java flowpolicy enum astub app's
%  LocalWords:  RequiredPermissions FlowSources FlowSinks apiusage Dstubs
%  LocalWords:  flowstubfiles TelephonyManager getLine1Number flowshow url
%  LocalWords:  PolyFlowSources PloyFlowSinks FlowSink FlowSource grep
%  LocalWords:  Dstricter
