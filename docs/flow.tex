\htmlhr
\chapter{Flow Checker\label{flow-checker}}
This chapter describes the Flow Checker, a type-checker that 
tracks information flow through your program.
The Flow Checker does pluggable type-checking of an information flow type
system.  It is implemented using the Checker Framework.  This chapter is
logically a chapter of the 
Checker Framework Manual (\ifhevea\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html}\else\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.pdf}\fi).
Therefore, in order to understand this chapter, you should first read
chapters 1--2 of the Checker Framework Manual, and you should at least skim
chapters 18--21 (generics through libraries) and 24--25 (FAQ and
troubleshooting). 



To use the Flow Checker, a programmer must supply two types of
information:

\begin{itemize}
\item
A flow policy that expresses what information flows the program is allowed
to have. \todo{Why do we need an example here?}  For example, a program might be allowed to send location
information to the network, but not allowed to access contacts nor to send
SMS messages.  The flow policy is primarily derived from the program's user
documentation.  \secref{sec:flow-policy} describes how to write a flow
policy.
\item
\todo{The user doesn't know what a type qualifier is yet, we called them annotations in the overview}
Type qualifiers written on (some of) the variables in the program.  The
type qualifiers indicate where the variable's value came from and where it
might go to.
\end{itemize}

When you run the Flow Checker, \todo{ add reference to section that explains how to run Flow Checker}it verifies that the annotations in the
program are consistent with what the program's code does, and that the
annotations are consistent with the flow policy.  This gives a guarantee
that the program has no information flow beyond what is expressed in the
flow policy and type annotations.



After you read this chapter, see \chapref{app-annotation} for tips about
writing information-flow annotations.


\section{The information-flow type system\label{sec:flow-type-system}}

You write the annotation \<@Source> on a variable's
type to indicate what sensitive sources can affect the variable's value.
You write the annotation \<@Sink> to indicate where (part of) the
value might be output.

As an example
\footnote{This example statically imports the enum to avoid writing FlowPermission before LOCATION and INTERNET. (import static sparta.checkers.quals.FlowPermission.*;)}, suppose there is a declaration
\begin{Verbatim}
  @Source(LOCATION) @Sink(INTERNET) double latitude;
\end{Verbatim}
\noindent
The \<@Source(LOCATION)> annotation indicates that the
value of \<latitude> might have been derived from
location information.  It does not guarantee that the value came from
authentic GPS data, but only sets a bound on where the information might
have come from; this assignment is legal: \<latitude = 47.6097>.
Similarly, the annotation \<@Sink(FlowSInk.INTERNET)> marks that
the string \<latitude> might be output to the network.  It is also
possible that the data has already been output.

The argument to \<@Source> (and \<@Sink>) is an enum constant, or a
set of them to indicate that a value might combine information from
multiple sources (or might flow to multiple locations).
\todo{Will need to rewrite this section if we agree to merge the enums.  Including explaining how an enum 
constant is marked as Source, Sink or Both}
Source specifies data sources such as phone number, location, 
etc.  Sink specifies sinks, such as files, network, and so on.
The types of Source and Sink are listed in the
\<Source.java> and \<Sink.java> files in \<sparta.checkers.quals>.
Most of them correspond to Android permissions (see 
\url{http://developer.android.com/reference/android/Manifest.permission.html}),
and others are new ``permissions'' that provide finer-grained control over
the behavior of an application.


\subsection{Subtyping\label{sec:subtyping}}

\begin{figure}
\centerline{\includegraphics[width=.49\textwidth]{figures/flowsources}%
  \hfill%
  \includegraphics[width=.49\textwidth]{figures/flowsinks}}
\caption{Partial qualifier hierarchy for \<@Source> and \<@Sink>.}
\label{fig:flow-hierarchy}
\end{figure}

As with standard Java types, the type annotation hierarchy indicates which
assignments, method calls, and overriding are legal. \figref{fig:flow-hierarchy} 
shows part of the \<@Source>
qualifier hierarchy.  The top type is \<@Source(ANY)>, which is
shorthand for listing every source.  It would be legal to annotate every
variable in a program with \<@Source(ANY)>, because every variable is
derived from some subset of all flow sources.  But, such an annotation
would be imprecise.  \<@Source(\ttcbs)>  is the
bottom type, and may only
be applied to variables whose value does not depend on any sensitive
source.


\figref{fig:flow-hierarchy} shows part of the \<@Sink>
qualifier hierarchy.  The top type is \<@Sink(\ttcbs)>, which indicates
that the value is only used locally by the application and never flows to
any sensitive sink.  The bottom type, \<@Sink(Sink.ANY)>, is a
value that might be output to any location whatsoever; it can be thought of
as a completely public value.

Note the different subtyping behavior for sources and sinks.




\subsection{Conditionals\label{sec:conditionals}}

The Flow Checker considers conditional expressions to be a flow sink.  If a variable 
will be used in a conditional, then it must have a flow sink of CONDITIONAL.  By default, 
any source is allowed flow through a conditional.  That is to say that 
ANY \flowsto{} CONDITIONAL is added to the flow policy by default. 

Conditionals are treated this way because they can leak information. For example, the given a flow policy of  USER\_INPUT \flowsto{} FILESYSTEM, the following type checks.

\begin{alltt}
@Source(USER_INPUT) @Sink(FILESYSTEM)
int creditCard = getCCNumber();
final int MAX\_CC\_NUM = 9999999999999999;
for (int i = 0 ; i < MAX\_CC\_NUM ; i++)\{
   if (i == creditCard)
        sendToInternet(i);
\}
\end{alltt}

To catch this sort of information leak, pass
 \<-Alint=strict-conditional> to change the default from ANY \flowsto{} CONDITIONAL to 
 LITERAL \flowsto{} CONDITIONAL. 



\subsection{Empty Flow Sink or Flow Source\label{sec:emptyflow}}

Programmers should not use @Source(\ttcbs) or @Sink(\ttcbs) for
any types except in stub files.
These types are only needed for top/bottom types which are used in the
default types: the \<null> literal uses the bottom type in order for
it to be assignable everywhere; local variables use the top type which
will be refined by flow sensitivity.
Every value should either flow from a literal or from some sensitive
source.  Likewise, every value must flow to a sensitive sink or to a
conditional expression.  Any variable that does not have a flow source
or a flow sink does not actually affect the output of the program and
should therefore be removed.
  
This may seem overly strict, but a variable without a flow source or
flow sink that does affect the output of the program comes from an
abuse of the type system.  Most likely a variable with no source or
sink would come from an improperly suppressed warning. Therefore it is
necessary to not allow flows from and to nowhere.  (The flow policy
ensures this; see section \secref{sec:flow-policy})

Note that this does not mean you must specify both a flow source
annotation and a flow sink annotation as explained in
\secref{flow-defaults}. 

 


\section{Flow Policy\label{sec:flow-policy}}

A flow policy is a list of all the flows that are permitted to occur in an application.
A flow-policy file is a list 
 of $\langle$flow source, flow sink$\rangle$ pairs.  If a flow is not listed in the flow policy, then 
 it is forbidden to occur.  If no flow policy is specified, then no flows are permitted. 
 
\subsection{Semantics of a Flow Policy}
\label{sec:undsiredflows}
The Flow Checker guarantees that there is no information
flow except for what is explicitly permitted by the policy file. If a user writes a type that is
not permitted by the policy file, then the flow checker issues a warning
even if all types in program otherwise typecheck.

For example, this variable declaration

\begin{alltt}
@Source(CAMERA) @Sink(INTERNET) Video video = ...
\end{alltt}

\noindent
is illegal unless the the policy file contains:

\begin{alltt}
CAMERA -> INTERNET
\end{alltt}

Here is another example.
The flow policy file contains:
\begin{alltt}
  ACCOUNTS      -> EXTERNAL_STORAGE, FILESYSTEM
  ACCELEROMETER -> EXTERNAL_STORAGE, FILESYSTEM, INTERNET
\end{alltt}

The following variable declarations are permitted:
\begin{alltt}
  @Source(ACCOUNTS) @Sink(EXTERNAL_STORAGE) Account acc = ...
  @Source({ACCELEROMETER, ACCOUNTS})
  @Sink({EXTERNAL_STORAGE, FILE_SYSTEM}) int accel = ...
\end{alltt}

The following definitions would generate ``forbidden flow'' errors:
\begin{Verbatim}
  @Source(ACCOUNTS) @Sink(@INTERNET) Account acc = ...
  @Source({ACCELEROMETER, ACCOUNTS})
  @Sink({EXTERNAL_STORAGE, FILESYSTEM, INTERNET})
\end{Verbatim}


\subsection{Syntax of a Flow Policy File}

Each line of a policy file specifies a permitted flow from a source to one
or more sinks.  For example,
\code{MICROPHONE -> INTERNET} implies that
MICROPHONE data is always allowed to flow to INTERNET.
The source or sink must be a member of the enum
\<sparta.checkers.quals.FlowPermission>.  The source 
and sink names should not be preceded by the name of the enumeration which contains them.
ANY is allowed just as it is in @Source and @Sink, but empty, \ttcbs, is not allowed.

Multiple sources or sinks can appear on the same line if they are separated by commas. 
For example,
this policy file:
\begin{alltt}
   MICROPHONE -> INTERNET, LOG, DISPLAY
\end{alltt}
is equivalent to this policy file:
\begin{alltt}
   MICROPHONE -> INTERNET
   MICROPHONE -> LOG
   MICROPHONE -> DISPLAY, INTERNET
\end{alltt}

The policy file may contain blank lines and comments that begin with 
a number sign (\<\#>) character.



\subsection{Using a flow-policy file}
To use a flow-policy file when invoking the Flow Checker from the
command line pass it the option:
\begin{alltt}
-AflowPolicy=\emph{mypolicyfile}
\end{alltt}

Or if you are using the \<flowtest> ant targets, you can pass the option to ant:
\begin{alltt}
ant -DflowPolicy=\emph{mypolicyfile} flowtest
\end{alltt}


\section{Default Types\label{flow-defaults}}

\begin{table}[h]
    \begin{tabular}{ll}
    \toprule
\bf{Location}&\bf{Default Flow Type}\\
\midrule 
    Fields &  \<@Source(LITERAL)> \\ 
    Method parameters &  \<@Source(LITERAL)> \\ 
    Return values &  \<@Source(LITERAL)> \\ 
    \<null> &  \<@Source(\ttcbs) @Sink(ANY)>\\ 
    Literals & \<@Source(LITERAL) @Sink(CONDITIONAL)>\\ 
   Local variables  &   \<@Source(ANY) @Sink(\ttcbs)> \\ 
   \<@Source($\alpha$)>&\<@Source($\alpha$)>
   \<@Sink($\omega$)>,  $\omega$ is the set of  sinks allowed to flow from all sources in $\alpha$ \\ 
      \<@Sink($\omega$)>&\<@Source($\alpha$)>
      \<@Sink($\omega$)>, $\alpha$ is the set of  sources allowed to flow to all sinks in $\omega$ \\ 
      
      \bottomrule
    \end{tabular}
    \caption{Default types}\label{table:defaults}
\end{table}


To reduce the number of annotations needed, default types are
used. Table \ref{table:defaults} shows the default types used by the
flow checker.


The defaults are not applied if the programmer uses annotations.  For
example, the parameter below is of type
\<@Source(LOCATION) @Sink(INTERNET)>
rather than  \<@Source({LITERAL})>.

\begin{alltt}
public void sendToInternet(
    @Source(LOCATION) @Sink(INTERNET) String message)\{...\}
\end{alltt} 

The value \<null> has the bottom type (\<@Sink(ANY)
@Source(\ttcbs)>),
so that it can be assigned to any type. For local variables, the
default applies to the top level of the local variable type, but not
to generic type arguments and array elements, if any.

The Checker Framework supports flow-sensitive type refinement.  Assignments (such as
initializers) are used to refine the type to a more precise one.  Thus, in
general you do not have to write type annotations on local variables.  For
details, see section ``\ahref{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#type-refinement}{Automatic type refinement (flow-sensitive type
qualifier inference)}'' in the Checker Framework Manual.

If the programmer specifies only flow sources, the flow sink is defaulted
to be the
sinks that the all the specified flow sources can flow to. This is to say that 
it is the intersection of the set of sinks each source can flow to.
 In other words, if a type is annotated with 
\<@Source($\alpha$)>, where $\alpha$ is a set of sources, then the flow sinks are the set 
$\omega$ where $\omega$ is the intersection of sinks B where A \flowsto{} B and A is a flow source in 
$\alpha$.  For example, if the flow policy contains the following:

\begin{alltt}
  A -> X,Y
  B -> Y
  C -> Y
\end{alltt}
  
\noindent 
then these are equivalent:

\begin{alltt}
  @Source(A)                 ==   @Source(A) @Sink(\{X, Y\})
  @Source(B)                 ==   @Source(B) @Sink(Y)
  @Source(\{B,C\})             ==   @Source(\{B,C\}) @Sink(Y)
  @Source(A) @Sink(Y)   ==   @Source(A) @Sink(Y) 
  @Source(\{A,B\})             ==   @Source(\{A,B\}) @Sink(Y)
\end{alltt}


Similarly, if the programmer only specifies flow sinks, the flow sources are defaulted to be the sources 
that are allowed to flow to all the specified sinks.  In other words, if a type is annotated with 
\<@Sink($\omega$)>, where $\omega$ is a set of sinks, then the flow sources are the set 
$\alpha$ where $\alpha$ is the intersection of sources A where A \flowsto{} B and B is a flow sink in 
$\omega$. For example, using the same policy file as above, the following are equivalent:

\begin{alltt}
  @Sink(X)                   ==   @Source(A) @Sink(X)
  @Sink(Y)                   ==   @Source(\{A,B,C\}) @Sink(Y)
\end{alltt}


\section{Warning Suppression\label{sec:waringsuppression}}
 
Sometimes it might be necessary to suppress warnings or errors produced by
the Flow Checker.  This can be done by using the
\<@SuppressWarnings("flow")> annotation on a variable, method, or (rarely)
class declaration.  Because this annotation can be used to subvert the Flow
Checker, its use is considered suspicious.  Anytime a warning or error is
suppressed, you must write a brief comment justifying the suppression.
\<@SuppressWarnings("flow")> should only be used if there is no way to
annotate the code so that an error or warning does not occur.  Most
programs should not suppress warnings.


\section{API specifications\label{sec:apispecs}}

Files in  \<sparta-code/src/sparta/checkers/flowstubfiles> provides library
annotations.  You may need to enhance them, if you find that your application
uses APIs that are not yet annotated.  For details, see
section~\ref{flow-task-annotate-apis} of this manual, and also 
chapter
``\ahref{\url{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries}}{Annotating
  Libraries}'' in the Checker Framework Manual.


\section{Qualifier polymorphism: @PolySource  and @PolySink \label{sec:polyflowsources}}

Two additional type annotations can be used to annotate polymorphic
methods: \<@PolySource>, \<@PolySink>.

To make the type system more expressive, the flow type system supports
qualifier polymorphism, via the type qualifiers \<@PolySource> and
\<@PolySink>.  These are mostly used when annotating APIs when the
specific flow sources or flow sinks are not known or can vary. 
See section ``\ahref{http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#qualifier-polymorphism}{Qualifier polymorphism}'' in the Checker Framework Manual.  

% These range over their respective type hierarchy and can be used to
% express type dependencies, for example, that the receiver and
% parameter types have to correspond.
% The invocation of a method is used to resolve polymorphic qualifiers
% to something concrete.

\todo{these have known soundness issues and with Stuart we're working on fixing them.}


\section{Additional Annotations\label{sec:addtionalanno}}

Three additional declaration annotations can be used to annotate APIs:
\<@DefaultFlow>, \<@ConservativeFlow>, and \<@PolyFlow>. 
They change the default annotations (\secref{flow-defaults}).
 
The declaration annotations can be used on any declaration: a method,
a class, or even a whole package.
For example, the
whole \<android> package should use conservative defaults.
More specific annotations given in the rest of the file override these
defaults.

% Do these apply to the receiver type?

\subsection{@DefaultFlow}

An element annotated with \<@DefaultFlow> expresses that an enclosed
method's return type and all parameter types are \<@Source(LITERAL)
@Sink(CONDITIONAL)>.  As with all 
library annotations, it is trusted rather than checked.  Thus, it should be
used only if an external analysis has determined that it is correct for the
annotated method, class, or package.




\subsection{@ConservativeFlow}

Annotation \<@ConservativeFlow> expresses that each contained method
should have the most conservative possible annotations:
  \<@Source({}) @Sink(ANY)> on arguments, and
  \<@Source(ANY) @Sink({})> on return values.
\todo{what for fields?}
This is so conservative that it is sure to cause a type-checking failure
whenever the method is used.
When the analyst encounters such type-checking errors, the analyst can
annotate the methods more appropriately.  This is a way of knowing when a
program uses a previously-unannotated library.


\subsection{@PolyFlow\label{sec:polyflow}}

Annotation \<@PolyFlow> expresses that each contained method should be
annotated as \<@PolyFlowPermission @PolyFlowPermission> for both the return
types and all parameters.



\todo{generate some more examples.}
%\subsection{Examples}
%
%Below are some examples of policy files and code examples that
%illustrate their effects.  Only assignment operations are used
%but remember that the flow-policy applies to all information flows.
%Comments in the code examples describe a direct effect of the
%given policy file.  Fake FlowPermission and FlowPermission names are used
%to aid in clarity.
%
%Any variable definition marked "OK" indicates that this
%definition would  be allowed given the policy file
%(and consequently also allowed in the absence of any flow-policy
%file).  Any variable definition marked "FORBIDDEN" indicates that
%the definition is forbidden by the flow-policy file.
%
%Any assignment marked "OK" indicates that this assignment is valid
%(with or without the policy file).  An assignment
%marked "FORBIDDEN" indicates that the assignment will still fail
%with an error.




\section{Stricter tests\label{sec:stricter}}

By default, the flow checker is unsound.  After getting the basic checks to pass, the
 stricter checks should be enabled, by running \<ant -Dsound=true flowtest>.
This two-phase approach was chosen to reduce
the annotation effortand to give two separate phases of
the annotation effort.
 The sound checking enforces invariant 
array subtyping and type safety in downcasts.


When strict checks are turned on,
a cast \<(Object []) x>, were \<x> is of type \<Object>, will result
in a compiler warning:

\begin{alltt}
[jsr308.javac] ... warning: "@Sink @Source({ANY}) Object"
       may not be casted to the type "@Sink @Source Object"
\end{alltt}

The reason is that there is not way for the type-checker to verify
 the component type of the array. There is no static knowledge about the actual
runtime values in the array and important flow could be hidden.
The analyst should argue why the downcast is safe.

Note that the main qualifier of a cast is automatically flow-refined
by the cast expression.


\medskip

Stricter checking also enforces invariant array subtyping, which is
needed for sound array behavior in the absence of runtime checks.
Flow inference automatically refines the type of array creation
expressions depending on the left-hand side.

\section{Miscellaneous\label{sec:miscellaneous}}

Some methods that are intended to be overridden by subclasses, such as 
\<Object>'s \<equals()> and \<toString()>, are given the most general
possible return type, \<@Source(ANY) @Sink({})>.
\todo{ Is this rationale correct??}
This permits overriding methods to give them a more specific return type, which
might depend on fields of the overriding class as well as on the types of
the arguments.  In fact, an overriding method must give a more specific
return type, since \<@Sink> prevents the value from being used.

Most binary operations, such as string concatenation and integer addition,
produce a result whose type is the least upper bound of the two operand types.


%% Adding on to that, if you try to compute a @FlowPermission{something} int
%%  with a int literal (0 or 100, etc) it will resolve to another
%%  @FlowPermission{something} int. If you try the same with a
%%  @FlowPermission{something} int with an int literal, it will result in
%%  @FlowPermission{} int because it's not safe to add a flowsink to the int
%%  literal. To bypass this, you must declare a local variable with
%%  "@SuppressWarnings("flow") @FlowPermission{something} int tempZero = 0;"
%%  and then use the local variable in the calculation.
%%  Again document why the warning can be suppressed.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  Sink someData Source enum 5cm flowsources 'c'
%  LocalWords:  flowsinks realString asdf PolySource PolySink
%  LocalWords:  sparta NoFlow ConservativeFlow astub TODO jsr308
%  LocalWords:  FlowPermission
