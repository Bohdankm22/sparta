\htmlhr
\chapter{Flow Checker\label{flow-checker}}

This chapter gives a brief overview of the Flow Checker, a type-checker that 
tracks information flow through your program.  It gives a guarantee that there
is no information flow beyond what is expressed in the flow policy and
type annotations.

The Flow Checker does pluggable type-checking of an information flow type
system.  It is implemented using the Checker Framework.  To better
understand pluggable type-checking and the Checker Framework, please
consult the Checker Framework manual at
\url{http://types.cs.washington.edu/checker-framework/}.  

\section{Overview}

You write the annotation \<@FlowSources> on a variable's
type to indicate what sensitive sources can affect the variable's value.
You write the annotation \<@FlowSinks> to indicate where (part of) the
value might be output.

As an example, suppose there is a declaration
\begin{Verbatim}
  @FlowSources(FlowSource.LOCATION) @FlowSinks(FlowSink.NETWORK) double latitude;
\end{Verbatim}
\noindent
The \<@FlowSources(FlowSource.LOCATION)> annotation indicates that the
value of \<latitude> might have been derived from
location information.  It does not guarantee that the value came from
authentic GPS data, but only sets a bound on where the information might
have come from; this assignment is legal: \<latitude = 47.6097>.
Similarly, the annotation \<@FlowSinks(FlowSInk.NETWORK)> marks that
the string \<latitude> might be output to the network.  It is also
possible that the data has already been output.

The argument to \<@FlowSources> (and \<@FlowSinks>) is an enum constant, or a
set of them to indicate that a value might combine information from
multiple sources (or might flow to multiple locations).
FlowSources specifies data sources such as phone number, location, 
etc.  FlowSinks specifies sinks, such as files, network, and so on.
The types of FlowSources and FlowSinks are listed in the
\<FlowSources.java> and \<FlowSinks.java> files in \<sparta.checkers.quals>.






\section{Default Types\label{flow-defaults}}

\begin{table}[h]
    \begin{tabular}{| l | l |}
     \hline
    Field types &  \<@FlowSources(FlowSource.LITERAL)> \\ \hline
    Method parameters &  \<@FlowSources(FlowSource.LITERAL)> \\ \hline
    Return types &  \<@FlowSources(FlowSource.LITERAL)> \\ \hline
    \<null> &  \<@FlowSources @FlowSinks(FlowSink.ANY)>\\ \hline
    Literals & \<@FlowSources(FlowSource.LITERAL) @FlowSinks(FlowSink.CONDITIONAL)>\\ \hline
   Local variables  &   \<@FlowSources(FlowSource.ANY) @FlowSinks> \\ \hline
   \<@FlowSources($\alpha$)>&\<@FlowSources($\alpha$)>
   \<@FlowSinks($\beta$)>,  $\beta$ is the set of flow sinks allowed to flow from all sources in $\alpha$ \\ \hline
      \<@FlowSinks($\beta$)>&\<@FlowSources($\alpha$)>
      \<@FlowSinks($\beta$)>, $\alpha$ is the set of flow sources allowed to flow to all sinks in $\beta$ \\ \hline
    \end{tabular}
    \caption{Default types}\label{table:defaults}
\end{table}


To reduce the number of annotations needed, default types are
used. Table \ref{table:defaults} shows the default types used by the
flow checker.


The defaults are not applied if the programmer uses annotations.  For
example, the parameter below is of type
\<@FlowSources(FlowSource.LOCATION) @FlowSinks(FlowSink.NETWORK)>
rather than  \<@FlowSources({FlowSource.LITERAL})>. Note that \<@FlowSources>
means \<@FlowSources(\{\})> and \<@FlowSinks>  means \<@FlowSinks(\{\})>.
\begin{alltt}
public void sendToInternet(
    @FlowSources(FlowSource.LOCATION) @FlowSinks(FlowSink.NETWORK) String message)\{...\}
\end{alltt} 

The value \emph{null} has the bottom type (\<@FlowSinks(FlowSink.ANY)
@FlowSources>),
so that it can be assigned to any type. For local variables, the
default applies to the top level of the local variable type, but not
to generic type arguments and array elements, if any.

The Checker Framework supports flow-sensitive type refinement.  Assignments (such as
initializers) are used to refine the type to a more precise one.  Thus, in
general you do not have to write type annotations on local variables.  For
details, see section ``Automatic type refinement (flow-sensitive type
qualifier inference)'' in the Checker Framework manual.

If the programmer specifies only flow sources, the flow sink is defaulted
to be the
sinks that the all the specified flow sources can flow to. This is to say that 
it is the intersection of the set of sinks each source can flow to.
 In other words, if a type is annotated with 
\<@FlowSources($\alpha$)>, where $\alpha$ is a set of sources, then the flow sinks are the set 
$\beta$ where $\beta$ is the intersection of sinks B where A-\textgreater B and A is a flow source in 
$\alpha$.  For example, if the flow policy contains the following:

\begin{alltt}
  A->X,Y
  B->Y
  C->Y
\end{alltt}
  
\noindent 
then these are equivalent:

\begin{alltt}
  @FlowSources(A)                 ==   @FlowSources(A) @FlowSinks(\{X, Y\})
  @FlowSources(B)                 ==   @FlowSources(B) @FlowSinks(Y)
  @FlowSources(\{B,C\})             ==   @FlowSources(\{B,C\}) @FlowSinks(Y)
  @FlowSources(A) @FlowSinks(Y)   ==   @FlowSources(A) @FlowSinks(Y) 
  @FlowSources(\{A,B\})             ==   @FlowSources(\{A,B\}) @FlowSinks(Y)
\end{alltt}


Similarly, if the programmer only specifies flow sinks, the flow sources are defaulted to be the sources 
that are allowed to flow to all the specified sinks.  In other words, if a type is annotated with 
\<@FlowSinks($\beta$)>, where $\beta$ is a set of sinks, then the flow sources are the set 
$\alpha$ where $\alpha$ is the intersection of sources A where A-\textgreater B and B is a flow sink in 
$\beta$. For example, using the same policy file as above, the following are equivalent:

\begin{alltt}
  @FlowSinks(X)                   ==   @FlowSources(A) @FlowSinks(X)
  @FlowSinks(Y)                   ==   @FlowSources(\{A,B,C\}) @FlowSinks(Y)
\end{alltt}

\section{Flow Policy}
\label{sec:flowpolicy}

A flow policy is a list of all the flows that are permitted to occur in an application.
Flow policies are specified in a flow-policy file that is  a list 
 of flow source and flow sink pairs.  If a flow is not listed in the flow policy, then 
 it is forbidden to occur.  If no flow policy is specified, then no flows are permitted. 
 
\subsection{Semantics of a Flow Policy}
\label{sec:undsiredflows}
The Flow Checker guarantees that there is no information
flow except for what is explicitly permitted by the policy file. If a user writes a type that is
not permitted by the policy file, then the flow checker issues a warning
even if all types in program otherwise typecheck.

For example, this variable declaration

\begin{alltt}
@FlowSource(FlowSource.CAMERA) @FlowSink(NETWORK) Video video = ...
\end{alltt}

\noindent
is illegal unless the the policy file contains:

\begin{alltt}
CAMERA -> NETWORK
\end{alltt}

Here is another example.
The flow policy file contains:
\begin{alltt}
  ACCOUNTS      -> EXTERNAL_STORAGE, FILESYSTEM
  ACCELEROMETER -> EXTERNAL_STORAGE, FILESYSTEM, NETWORK
\end{alltt}

The following variable declarations are permitted:
\begin{alltt}
  @FlowSources(FlowSource.ACCOUNTS) @FlowSinks(FlowSink.EXTERNAL_STORAGE) Account acc = ...
  @FlowSources({FlowSource.ACCELEROMETER, FlowSource.ACCOUNTS})
  @FlowSinks({FlowSink.EXTERNAL_STORAGE, FlowSink.FILE_SYSTEM}) int accel = ...
\end{alltt}

The following definitions would generate ``forbidden flow'' errors:
\begin{Verbatim}
  @FlowSources(FlowSource.ACCOUNTS) @FlowSinks(@FlowSink.NETWORK) Account acc = ...
  @FlowSources({FlowSource.ACCELEROMETER, FlowSource.ACCOUNTS})
  @FlowSinks({FlowSink.EXTERNAL_STORAGE, FlowSink.FILESYSTEM, FlowSink.NETWORK})
\end{Verbatim}


\subsection{Syntax of a Flow Policy File}

Each line of a policy file specifies a source-to-sink(s) flow(s) that is permitted. So if 
``A $\rightarrow$ B,C'' appears in the file, then information from source A is allowed to flow
to sink B or sink C.  

For example,
\<MICROPHONE$\rightarrow$NETWORK> implies that
MICROPHONE data is always allowed to flow to NETWORK.  
The source must be a member of the enum
\<sparta.checkers.quals.FlowSources.FlowSource> and the sink must be a
member of the enum 
\<sparta.checkers.quals.FlowSinks.FlowSink>.  The source 
and sink names should not be preceded by the name of the enumeration which contains them.
ANY is allowed just as it is in @FlowSources and @FlowSinks, but empty, \{\}, is not allowed.

Multiple sources or sinks can appear on the same line if they are separated by commas. 
For example,
these two policy files have the same meaning:

\begin{alltt}
   MICROPHONE -> NETWORK, LOG, DISPLAY
\end{alltt}
is equivalent to this policy file:
\begin{alltt}
   MICROPHONE -> NETWORK
   MICROPHONE -> LOG
   MICROPHONE -> DISPLAY, NETWORK
\end{alltt}

The policy file may contain blank lines and comments that begin with 
a number sign (\<\#>) character.



\subsection{Using a flow-policy file}
To use a flow-policy file when invoking the Flow Checker from the
command line pass it the option:
\begin{alltt}
-AflowPolicy=\emph{mypolicyfile}
\end{alltt}

Or if you are using one of the ant targets, you can pass the option to ant:
\begin{alltt}
ant -DflowPolicy=\emph{mypolicyfile} flowtest
\end{alltt}

Remember, not specifying a flow policy file is equivalent to not
allowing any flows.
% TODO: is this right? What about relaxed vs. strict?



\section{Subtyping}

\begin{figure}[h]
\includeimage{flowsources}{5cm}
\caption{Partial qualifier hierarchy for \<@FlowSources>.}
\label{fig:flowsources-hierarchy}
\end{figure}

\begin{figure}[h]
\includeimage{flowsinks}{5cm}
\caption{Partial qualifier hierarchy for \<@FlowSinks>.}
\label{fig:flowsinks-hierarchy}
\end{figure}

As with standard Java types, the type annotation hierarchy indicates which
assignments, method calls, and overriding are legal. \figref{fig:flowsources-hierarchy} 
shows part of the \<@FlowSources>
qualifier hierarchy.  The top type is \<@FlowSources(ANY)>, which is
shorthand for listing every source.  It would be legal to annotate every
variable in a program with \<@FlowSources(ANY)>, because every variable is
derived from some subset of all flow sources.  But, such an annotation
would be imprecise.  \<@FlowSources(\ttcbs)> or \<@FlowSources()> is the
bottom type, and may only
be applied to variables whose value does not depend on any sensitive
source.


\figref{fig:flowsinks-hierarchy} shows part of the \<@FlowSinks>
qualifier hierarchy.  The top type is \<@FlowSinks(\ttcbs)> or
\<@FlowSinks()>, which indicates
that the value is only used locally by the application and never flows to
any sensitive sink.  The bottom type, \<@FlowSinks(FlowSinks.ANY)>, is a
value that might be output to any location whatsoever; it can be thought of
as a completely public value.

Note the different subtyping behavior for sources and sinks.




\section{Conditionals}

The Flow Checker considers conditional expressions to be a flow sink.  If a variable 
will be used in a conditional, then it must have a flow sink of CONDITIONAL.  By default, 
any source is allowed flow through a conditional.  That is to say that 
ANY -\textgreater CONDITIONAL is added to the flow policy by default. 

Conditionals are treated this way because they can leak information. For example, the given a flow policy of  USER\_INPUT -\textgreater FILESYSTEM, the following type checks.

\begin{alltt}
@FlowSources(FlowSource.USER_INPUT) @FlowSinks(FlowSink.FILESYSTEM)
int creditCard = getCCNumber();
final int MAX\_CC\_NUM=9999999999999999;
for (int i = 0 ; i < MAX\_CC\_NUM ; i++)\{
   if ( i == creditCard )
        sendToInternet(i);
\}
\end{alltt}

To catch this sort of information leak, pass
 \<-Alint=strict-conditional> to change the default from ANY -\textgreater CONDITIONAL to 
 LITERAL-\textgreater CONDITIONAL. 



\section{Empty Flow Sinks or Flow Sources}

Programmers should not use @FlowSources(\{\}) and @FlowSinks(\{\}) for
any types.
These types are only needed for top/bottom types which are used in the
default types: the \<null> literal uses the bottom type in order for
it to be assignable everywhere; local variables use the top type which
will be refined by flow sensitivity.
Every value should either flow from a literal or from some sensitive
source.  Likewise, every value must flow to a sensitive sink or to a
conditional expression.  Any variable that does not have a flow source
or a flow sink does not actually affect the output of the program and
should therefore be removed.
  
This may seem overly strict, but a variable without a flow source or
flow sink that does affect the output of the program comes from an
abuse of the type system.  Most likely a variable with no source or
sink would come from an improperly suppressed warning. Therefore it is
necessary to not allow flows from and to nowhere.  (The flow policy
ensures this; see section Section~\ref{sec:flowpolicy})

Note that this does not mean you must specify both a flow source
annotation and a flow sink annotation as explained in
Section~\ref{flow-defaults}. 

 
\section{Warning Suppression}
 
 Sometimes it might be necessary to suppress warnings or errors produced by the
  Flow Checker.  This can be done by using the  \<@SuppressWarnings("flow")> annotation
   on a declaration.  Because this annotation can be used to subvert the Flow Checker, its use
   is considered suspicious.  Anytime a warning or error is suppressed, you must 
   write a brief comment justifying the suppression.     \<@SuppressWarnings("flow")> should
   only be used if there is no way to annotate the code so that an error or warning does not occur. 
   Most programs should not suppress warnings. 


\section{API specifications}

File \<sparta-code/src/sparta/checkers/flow.astub> provides library
annotations.  You may need to enhance it, if you find that your application
uses APIs that are not yet annotated.  For details, see
section~\ref{flow-task-annotate-apis} of this manual, and also 
chapter
``Annotating libraries'' in the Checker Framework manual.


\section{Qualifier polymorphism: @PolyFlowSources  and @PolyFlowSinks}

Two additional type annotations can be used to annotate polymorphic
methods: \<@PolyFlowSources>, \<@PolyFlowSinks>.

To make the type system more expressive, the flow type system supports
qualifier polymorphism, via the type qualifiers \<@PolyFlowSources> and
\<@PolyFlowSinks>.  These are mostly used when annotating APIs when the
specific flow sources or flow sinks are not known or can vary. 
See section ``Qualifier polymorphism'' in the Checker Framework manual.  

% These range over their respective type hierarchy and can be used to
% express type dependencies, for example, that the receiver and
% parameter types have to correspond.
% The invocation of a method is used to resolve polymorphic qualifiers
% to something concrete.

% TODO: these have known soundness issues and with Stuart we're
% working on fixing them.


\section{Additional Annotations}

Three additional declaration annotations can be used to annotate APIs:
\<@NoFlow>, \<@ConservativeFlow>, and \<@PolyFlow>. 
They change the default annotations (Section~\ref{flow-defaults}).
 
The declaration annotations can be used on any declaration: a method,
a class, or even a whole package.
For example, the beginning of \<flow.astub> declares that the
whole \<android> package should use conservative defaults.
More specific annotations given in the rest of the file override these
defaults.

% Do these apply to the receiver type?

\subsection{@NoFlow}

An element annotated with \<@NoFlow> expresses that an enclosed
method's return type and all parameter types are \<@FlowSources({})
@FlowSinks({})>.  As with all 
library annotations, it is trusted rather than checked.  Thus, it should be
used only if an external analysis has determined that it is correct for the
annotated method, class, or package.

% TODO: Is noflow {} or the LITERAL default?
% Should it be renamed to @DefaultFlow?


\subsection{@ConservativeFlow}

Annotation \<@ConservativeFlow> expresses that each contained method
should have the most conservative possible annotations:
  \<@FlowSources({}) @FlowSinks(ANY)> on arguments, and
  \<@FlowSources(ANY) @FlowSinks({})> on return values.
%[TODO: what for fields?]
This is so conservative that it is sure to cause a type-checking failure
whenever the method is used.
When the analyst encounters such type-checking errors, the analyst can
annotate the methods more appropriately.  This is a way of knowing when a
program uses a previously-unannotated library.


\subsection{@PolyFlow}

Annotation \<@PolyFlow> expresses that each contained method should be
annotated as \<@PolyFlowSource @PolyFlowSink> for both the return
types and all parameters.



%TODO generate some more examples.
%\subsection{Examples}
%
%Below are some examples of policy files and code examples that
%illustrate their effects.  Only assignment operations are used
%but remember that the flow-policy applies to all information flows.
%Comments in the code examples describe a direct effect of the
%given policy file.  Fake FlowSource and FlowSink names are used
%to aid in clarity.
%
%Any variable definition marked "OK" indicates that this
%definition would  be allowed given the policy file
%(and consequently also allowed in the absence of any flow-policy
%file).  Any variable definition marked "FORBIDDEN" indicates that
%the definition is forbidden by the flow-policy file.
%
%Any assignment marked "OK" indicates that this assignment is valid
%(with or without the policy file).  An assignment
%marked "FORBIDDEN" indicates that the assignment will still fail
%with an error.




\section{Stricter tests}

By default, the flow checker is unsound.  After getting the basic checks to pass, the
 stricter checks should be enabled, by running \<ant -Dsound=true flowtest>.
This two-phase approach was chosen to reduce
the annotation effortand to give two separate phases of
the annotation effort.
 The sound checking enforces invariant 
array subtyping and type safety in downcasts.


When strict checks are turned on,
a cast \<(Object []) x>, were \<x> is of type \<Object>, will result
in a compiler warning:

\begin{alltt}
[jsr308.javac] ... warning: "@FlowSinks @FlowSources({FlowSource.ANY}) Object"
       may not be casted to the type "@FlowSinks @FlowSources Object"
\end{alltt}

The reason is that there is not way for the type-checker to verify
 the component type of the array. There is no static knowledge about the actual
runtime values in the array and important flow could be hidden.
The analyst should argue why the downcast is safe.

Note that the main qualifier of a cast is automatically flow-refined
by the cast expression.


\medskip

Stricter checking also enforces invariant array subtyping, which is
needed for sound array behavior in the absence of runtime checks.
Flow inference automatically refines the type of array creation
expressions depending on the left-hand side.

\section{Miscellaneous}

Methods like \<equals()> and \<toString()> that are inherited from
\<Object> are the most general possible, so that overriding methods
can restrict the annotations further. Thus, they
return \<FlowSource.ANY> and no flow sinks.

Binary operations like string concatenation or integer addition,
result in the least upper bound of the two component types.


%% Adding on to that, if you try to compute a @FlowSource{something} int
%%  with a int literal (0 or 100, etc) it will resolve to another
%%  @FlowSource{something} int. If you try the same with a
%%  @FlowSink{something} int with an int literal, it will result in
%%  @FlowSink{} int because it's not safe to add a flowsink to the int
%%  literal. To bypass this, you must declare a local variable with
%%  "@SuppressWarnings("flow") @FlowSink{something} int tempZero = 0;"
%%  and then use the local variable in the calculation.
%%  Again document why the warning can be suppressed.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  FlowSinks someData FlowSources enum 5cm flowsources 'c'
%  LocalWords:  flowsinks realString asdf PolyFlowSources PolyFlowSinks
%  LocalWords:  sparta NoFlow ConservativeFlow astub TODO jsr308
%  LocalWords:  FlowSource
