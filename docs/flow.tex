\htmlhr
\chapter{Flow Checker\label{flow-checker}}

This chapter gives a brief overview of the Flow Checker, one of
the main components of SPARTA\@.  The Flow Checker tracks information flow
through your program --- it gives a guarantee that there is no information
flow beyond what is expressed in type annotations.

The Flow Checker does pluggable type-checking of an information flow type
system.  It is implemented using the Checker Framework.  To better
understand pluggable type-checking and the Checker Framework, please
consult the Checker Framework manual at
\url{http://types.cs.washington.edu/checker-framework/}.  

\section{Overview}

You write the annotation \<@sparta.checkers.quals.FlowSources> on a variable's
type to indicate what sensitive sources can affect the variable's value.
You write the annotation \<@FlowSinks> to indicate where (part of) the
value might be output.

As an example, suppose there is a declaration
\begin{Verbatim}
  @FlowSources(LOCATION) double latitude;
\end{Verbatim}
\noindent
This indicates that the value of \<latitude> might have been derived from
location information.  It does not guarantee that the value came from
authentic GPS data, but only sets a bound on where the information might
have come from; this assignment is legal: \<latitude = 47.6097>.

Similarly, the type
\begin{Verbatim}
  @FlowSinks(NETWORK) String someData;
\end{Verbatim}
\noindent
marks that the string \<someData> might be output to the network, or a part
of it or its length might be output to the network.  It is also possible
that the data has already been output.

The argument to \<@FlowSources> (and \<@FlowSinks>) is an enum constant, or a
set of them to indicate that a value might combine information from
multiple sources (or might flow to multiple locations).

FlowSources specifies data sources such as phone number, location, 
etc.  FlowSinks specifies sinks, such as files, network, and so on.
The types of FlowSources and FlowSinks are listed in the
\<FlowSources.java> and \<FlowSinks.java> files in \<sparta.checkers.quals>.


\section{Subtyping}

As with standard Java types, the type annotation hierarchy indicates which
assignments, method calls, and overriding are legal.


\begin{figure}
\includeimage{flowsources}{5cm}
\caption{Partial qualifier hierarchy for \<@FlowSources>.}
\label{fig:flowsources-hierarchy}
\end{figure}

\figref{fig:flowsources-hierarchy} shows part of the \<@FlowSources>
qualifier hierarchy.  The top type is \<@FlowSources(ANY)>, which is
shorthand for listing every source.  It would be legal to annotate every
variable in a program with \<@FlowSources(ANY)>, because every variable is
derived from some subset of all flow sources.  But, such an annotation
would be imprecise.  \<@FlowSources(\ttcbs)> or \<@FlowSources()> is the
bottom type, and may only
be applied to variables whose value does not depend on any sensitive
source.


\begin{figure}
\includeimage{flowsinks}{5cm}
\caption{Partial qualifier hierarchy for \<@FlowSinks>.}
\label{fig:flowsinks-hierarchy}
\end{figure}

\figref{fig:flowsinks-hierarchy} shows part of the \<@FlowSinks>
qualifier hierarchy.  The top type is \<@FlowSinks(\ttcbs)> or
\<@FlowSinks()>, which indicates
that the value is only used locally by the application and never flows to
any sensitive sink.  The bottom type, \<@FlowSinks(FlowSinks.ANY)>, is a
value that might be output to any location whatsoever; it can be thought of
as a completely public value.

Note the different subtyping behavior for sources and sinks.


\section{Defaults\label{flow-defaults}}

The default qualifiers are \<@FlowSinks({})> and \<@FlowSources({})>.  This
default applies to field types, method parameters and return types,
manifest constants
(string literals, \<1.0>, \<true>, \<3>, \<'c'>,
\ldots), and all other locations except local variables.

This means that this variable declaration raises an error:

\begin{alltt}
@FlowSinks(NETWORK) String realString = "asdf";
\end{alltt}

The reason is that the right-hand side of the assignment has type
\<@FlowSinks({})>, which is a value that may not be output to any sink.
This is not a subtype of the left-hand type \<@FlowSinks(NETWORK)>, which
is allowed to flow to the network (but to no other sink).  If the given
string is permitted to flow to the network, then you can suppress the
warning by annotating the declaration with \<@SuppressWarnings("flow")>.

The \<@ConservativeFlow> annotation changes the default for return types;
see Section~\ref{ConservativeFlow}.

For \textbf{local variables}, the default is the top type for each
hierarchy, that is, \<@FlowSources(ANY) @FlowSinks({})>.  This applies to
the top level of the local variable type, but not to generic type arguments
and array elements, if any.

The Checker
Framework supports flow-sensitive type refinement.  Assignments (such as
initializers) are used to refine the type to a more precise one.  Thus, in
general you do not have to write type annotations on local variables.  For
details, see section ``Automatic type refinement (flow-sensitive type
qualifier inference)'' in the Checker Framework manual.


\section{Qualifier polymorphism}

To make the type system more expressive, the flow type systems support
qualifier polymorphism, via the type qualifiers \<@PolyFlowSources> and
\<@PolyFlowSinks>.
See section ``Qualifier polymorphism'' in the Checker Framework manual.

% These range over their respective type hierarchy and can be used to
% express type dependencies, for example, that the receiver and
% parameter types have to correspond.
% The invocation of a method is used to resolve polymorphic qualifiers
% to something concrete.


\section{API specifications}

File \<sparta-code/src/sparta/checkers/flow.astub> provides library
annotations.  You may need to enhance it, if you find that your application
uses APIs that are not yet annotated.  For details, see
section~\ref{flow-task-annotate-apis} of this manual, and also 
chapter
``Annotating libraries'' in the Checker Framework manual.

\label{ConservativeFlow}

Besides the qualifiers discussed so far, two additional declaration
annotations can be used in the stub file: \<@NoFlow> and \<@ConservativeFlow>.
Their effect is to change the default annotations (Section~\ref{flow-defaults}).

Annotation \<@NoFlow> expresses that each method's return type and all
parameter types are \<@FlowSources({}) @FlowSinks({})>.  As with all
library annotations, it is trusted rather than checked.  Thus, it should be
used only if an external analysis has determined that it is correct for the
annotated method, class, or package.

Annotation \<@ConservativeFlow> expresses that each method should have the
most conservative possible annotations:
  \<@FlowSources({}) @FlowSinks(ANY)> on arguments, and
  \<@FlowSources(ANY) @FlowSinks({})> on return values.
[TODO: what for fields?]
This is so conservative that it is sure to cause a type-checking failure
whenever the method is used.
When the analyst encounters such type-checking errors, the analyst can
annotate the methods more appropriately.  This is a way of knowing when a
program uses a previously-unannotated library.

These annotations can be used on any declaration: a method, a class,
or even a whole package.
For example, the beginning of \<flow.astub> declares that the
whole \<android> package should use conservative defaults.
More specific annotations given in the rest of the file override these
defaults.


\section{Stricter tests}

The default checks ensure soundness of the flow qualifiers.
It ignores two possible sources of unsoundness: covariant array
subtyping and downcasts that are not checked at runtime.
After getting the basic checks passing, the stricter checks should be
enabled, by running \<ant -Dstricter=true flowtest>.
This two-phase approach was chosen to not interfere with
the annotation effort too severely and to give two separate phases of
the annotation effort.


When strict checks are turned on,
a cast \<(Object []) x>, were \<x> is of type \<Object>, will result
in a compiler warning:

\begin{alltt}
[jsr308.javac] ... warning: "@FlowSinks @FlowSources({FlowSource.ANY}) Object"
       may not be casted to the type "@FlowSinks @FlowSources Object"
\end{alltt}

The reason is that statically the component type of the array is
simply defaulted. There is no static knowledge about the actual
runtime values in the array and important flow could be hidden.
The analyst should argue why the downcast is safe.

Note that the main qualifier of a cast is automatically flow-refined
by the cast expression.


\medskip

Stricter checking also enforces invariant array subtyping, which is
needed for sound array behavior in the absence of runtime checks.
Flow inference automatically refines the type of array creation
expressions depending on the left-hand side.

\section{Flow Policy}
\label{sec:flowpolicy}

A flow-policy file is essentially a list of sources mapped to sinks
that dictates what flows should be permitted by the FlowChecker.  A
flow-policy file serves two purposes when using the FlowChecker.
Firstly, it allows the user to specify stricter checking guidelines.
And secondly, it allows the user to automatically suppress warnings
and thereby reduce annotation overhead.  Details about how these
purposes are achieved are described below.

\subsection{Using a flow-policy file}
To use a flow-policy file when invoking the FlowChecker from the
command line pass it the option:
\begin{Verbatim}
-AflowPolicy=<my policy file>
\end{Verbatim}

\subsection{Enforcing Stricter Guarantees}
By default the FlowChecker guarantees that there is no information
flow except for what is explicitly expressed in type annotations.
These guarantees are ensured via the subtyping rules specified
in the FlowSinks and FlowSources qualifier hierarchies.
These rules allow annotations like:

\begin{Verbatim}
@FlowSource(FlowSource.CAMERA) @FlowSink(NETWORK) Video video = ...
\end{Verbatim}

But what if we do not ever want CAMERA information to flow to the
NETWORK? To enforce such a property we could use a flow-policy file.
The flow-policy file consists of a mapping of
FlowSources to FlowSinks.  When the FlowChecker encounters a type
it checks the type's FlowSources and FlowSinks.  If, for each FlowSource,
there exists a mapping from that FlowSource to all FlowSinks then
the type is considered valid.  Otherwise an error will be raised.

For the example above adding the following line to the policy
file would allow CAMERA information to flow to the NETWORK:

\begin{Verbatim}
CAMERA -> NETWORK
\end{Verbatim}

However, if this line is missing then sources with CAMERA
would never be allowed to flow to the NETWORK and the previous
definition of the variable \<video> will raise an error.

Here is another example:

\begin{Verbatim}
File flowPolicy contains:
  ACCOUNTS      -> EXTERNAL_STORAGE, FILESYSTEM
  ACCELEROMETER -> EXTERNAL_STORAGE, FILESYSTEM, NETWORK
\end{Verbatim}

The following definitions would not generate warnings using the above flow-policy file:
\begin{Verbatim}
  @FlowSources(FlowSource.ACCOUNTS) @FlowSinks(FlowSink.EXTERNAL_STORAGE) Account acc = ...
  @FlowSources({FlowSource.ACCELEROMETER, FlowSource.ACCOUNTS})
  @FlowSinks({FlowSink.EXTERNAL_STORAGE, FlowSink.FILE_SYSTEM}) int accel = ...
\end{Verbatim}

The following definitions would generate forbidden flow errors:
\begin{Verbatim}
  @FlowSources(FlowSource.ACCOUNTS) @FlowSinks(@FlowSink.NETWORK) Account acc = ...
  @FlowSources({FlowSource.ACCELEROMETER, FlowSource.ACCOUNTS})
  @FlowSinks({FlowSink.EXTERNAL_STORAGE, FlowSink.FILESYSTEM, FlowSink.NETWORK})
\end{Verbatim}

If you are using a policy file then it is important to know that unless
you explicitly list a flow from a source X to a sink Y then all
information flow from X to Y is forbidden.  For instance,
if you're policy file never mentions NETWORK as a source then, you're application
cannot read any network data without generating an error.  If it never
mentions NETWORK as a sink then, it can never write to the network without
generating an error.

\subsection{Suppressing Warnings}
Most applications are separated into modules or APIs that
provide method calls for general use.  For instance, suppose there
was a method call to send text messages as follows:
\begin{Verbatim}
public void sendTxt(@FlowSinks(FlowSink.TEXTMESSAGE)String msg, PhoneNumber num)
\end{Verbatim}

Without a flow-policy file, every time \<sendTxt(myMsg, num)> is
used with a variable \<myMsg> that contained a non-empty set of
FlowSources then a warning would have to be suppressed since method
parameter \<msg> has no FlowSources.

For example:

Given a method:
\begin{Verbatim}
  @FlowSource({FlowSource.ACCELEROMETER}) String getAccelerometerData()
\end{Verbatim}

The following line would normally produce an error due to our subtyping rules:
\begin{Verbatim}
  sendText(getAccelerometerData(), myPhysiciansNumber);
\end{Verbatim}

However, if the following line appears in the flow-policy file then, this warning is suppressed:
\begin{Verbatim}
  ACCELEROMETER -> TEXTMESSAGE
\end{Verbatim}

In order for a warning to be suppressed all of the FlowSources
on the right-hand side of an assignment (or, in this case, the
passing of parameters) must have a mapping in the flow-policy
file to all of the FlowSinks on the left-hand side of the policy
file.  In the case above, the return type of
\<getAccelerometerData()> is on the right-hand side and the
msg parameter is on the left-hand side.  An example using
assignments is given below  (fake sources/sinks are used and the
enum class names are omitted for brevity):

\begin{Verbatim}
File flowPolicy contains:
A -> A, B, C, D
B -> B, C
C -> B, C, D

@FlowSources({A, B, C}) Object srcAbc = ...
@FlowSinks({B,C}) Object sinkBc = ...
\end{Verbatim}

This following assignment would normally produce an error:
\begin{Verbatim}
sinkBc = srcAbc;
\end{Verbatim}

The assignment in the example above normally produces an error
since, the \<@FlowSinks> of \<srcAbc> are not subtypes of the
\<@FlowSinks> of \<sinkBc>.  However, the flow-policy file has a
mapping from A to B and C, from B to B and C, and from C to B
and C (i.e. all the sources from \<srcAbc> to all the sinks of
\<sinkBc>).   Therefore, in this case the warning would be
suppressed.  Note the following line in the policy file.
\begin{Verbatim}
B -> B
\end{Verbatim}

Sources are not allowed to flow to their analogous sink unless
permitted by the flow-policy.  The use of a policy file in
this manner allows us to avoid adding many FlowSources to a
commonly used API or adding suppressions on invocations of
the API.

An example that would not result in a suppressed warning
using the previous flow-policy file would be:

\begin{Verbatim}
@FlowSinks({B,C,D}) Object sinkBcd = srcAbc;
\end{Verbatim}

In the above case, since B is not mapped to D in the
policy-file the warning would not be suppressed.

An important final note:
Before the flow-policy checks flows from sources to sinks
it removes any flow that appears in the variable being assigned
(or pseudo assigned) to.  In the case above, this variable is
\<sinkBcd>.  If \<sinkBcd> were instead defined as:
\begin{Verbatim}
@FlowSource({A,B}) @FlowSink({B,C,D}) Object sinkBcd = srcAbc;
\end{Verbatim}
Then the warning on the above line would be suppressed because,
\<sinkBcd> already has a flow from B to D.  The user would have
already had to suppress a warning on \<sinkBcd> and would expect
B to flow to D in this particular instance.

\subsection{Defining a policy file}
This section covers the syntax and semantics of a policy file.

Note:  The empty bracket symbol \<\{\}> is used in flow-policy
files to denote an empty-set of FlowSources or FlowSinks.
The effects of using the \<\{\}> symbol  as well as the special
source and special sink denoted by \<ANY> is discussed in
section labelled "ANY and None".

The simplest policy file is a blank one.  A blank policy file
forbids all flows of any sort except for flows between
variables with the effective annotations of \<@FlowSource(\{\}) @FlowSink(\{\})>.
Entries in the flow policy file are separated by newlines.
Empty and lines consisting solely of white-space or comments are ignored.
A mapping from one FlowSource to N flowSinks can be written as follows:
\begin{Verbatim}
FlowSource -> FlowSink1, FlowSink2, ..., FlowSinkN
\end{Verbatim}

In this case FlowSource must be a member of the enum
\<sparta.checkers.quals.FlowSources.FlowSource> and all FlowSinks are
members of the enum \<sparta.checkers.quals.FlowSinks.FlowSink>.

Duplicate FlowSink entries for any given FlowSource will be ignored.
Duplicate FlowSource entries are merged.

\begin{Verbatim}
E.g.
   A policy file containing:
   MICROPHONE -> NETWORK, LOGCAT, DISPLAY, NETWORK

   is equivalent to:
   MICROPHONE -> NETWORK, LOGCAT, DISPLAY

   A policy file containing:
   MICROPHONE -> NETWORK
   MICROPHONE -> LOGCAT
   MICROPHONE -> DISPLAY, NETWORK

   is equivalent to:
   MICROPHONE -> NETWORK, LOGCAT, DISPLAY
\end{Verbatim}


Notice the source and sink names should not preceded by the name of the
enumeration which contains them. All of the examples above imply that
MICROPHONE data is always allowed to flow to NETWORK, LOGCAT, and DISPLAY sinks.
Any types with any other source to sink set (besides \<@FlowSource(\{\}) @FlowSinks(\{\})>)
will raise errors.  Any assignments from a type with \<@FlowSink({MICROPHONE})>
to a variable that only has one or more sinks of NETWORK, LOGCAT, or DISPLAY
types will have their warnings suppressed.

Comments start with a number sign(\<\#>) character and terminate a line at the \<\#> character.

\begin{Verbatim}
E.g.

   #This line is ignored
   MICROPHONE -> NETWORK \#, LOGCAT
   #,LOGCAT would be disregarded above
\end{Verbatim}

You can use arbitrary spacing (except for newlines) providing you do not break
the -> symbol (such as - >) and do not break any of the enumeration names.

\begin{Verbatim}
E.g.
  MICROPHONE -> NETWORK
     CAMERA  ->        NETWORK

CAMERA -> EXTERNAL_STORAGE
\end{Verbatim}

\subsection{ANY and None}

Two special types of FlowSources and FlowSinks can be found in
a flow-policy file ANY and None(denoted by \<\{\}>).  ANY sources or sinks
have a corresponding enum value in FlowSource and FlowSink.
However, they have special status in the enumeration in that
their use implies the use of all other values in FlowSource
in FlowSink.  The same principle applies to the flow-policy file.
\begin{Verbatim}
E.g.
  ANY -> MICROPHONE
  is equivalent to

  ACCOUNTS      -> MICROPHONE
  ACCELEROMETER -> MICROPHONE
  CAMERA        -> MICROPHONE
  ... and so on for all members of FlowSource  excluding ANY
\end{Verbatim}

The above example does not map MICROPHONE to None(\<\{\}>).
to MICROPHONE. \<\{\}> indicates either a FlowSources or FlowSinks
annotation is empty.
\begin{Verbatim}
E.g.
 {} -> DISPLAY
\end{Verbatim}
The above definition indicates that variables of type
\<@FlowSources(\{\}) @FlowSinks(FlowSink.DISPLAY)> have valid
types. It also indicates that variables with
\<@FlowSources(\{\})> can always be assigned to variables with
\<@FlowSinks(FlowSink.Display)>.

\begin{Verbatim}
E.g.
   Below is a valid assignment:
   Object noSourcesOrSinks = ...
   @FlowSink({FlowSink.DISPLAY}) Window window = noSourcesOrSinks;
\end{Verbatim}

\begin{Verbatim}
E.g.
   ACCELEROMETER -> {}
   NETWORK -> {}
\end{Verbatim}

The above line indicates the ACCELEROMETER and NETWORK
data can flow to variables that have no FlowSinks (and
therefore flow nowhere else).

\begin{Verbatim}
E.g.
   @FlowSource(FlowSource.NETWORK) Packet packet = ...
   Object someObj = packet;
   The above assignment is valid given the policy file.
\end{Verbatim}

Note that an important affect of using the \<\{\}> as a sink means
that assignments like the following now have their warning
suppressed:

\begin{Verbatim}
E.g.
Policy File:
ANY -> {}

@FlowSource({FlowSource.NETWORK}) Packet packet = ...
@FlowSource({FlowSource.FILESYSTEM}) Object fsObj = packet;
This is allowed because fsObj has no sensitive sinks and ANY FlowSource is allowed to flow to a variable with no sinks.
\end{Verbatim}

The following definition implies that we can write
any variable that has no data flowing from a
sensitive source can be written to any variable that
has a sensitive sink.
\begin{Verbatim}
 {} -> ANY

E.g.
 String myStr = "YO!"
 @FlowSink({ACCOUNTS, NETWORK}) String str = myStr;
 The above assignment is valid.
\end{Verbatim}

In closing you may want to add the following definitions
to your flow-policy in order to reduce the number of
warnings that occur related to unannotated variables:
\begin{Verbatim}
ANY -> {}
{} -> ANY
\end{Verbatim}

But you should be aware how this affects the
warnings produced and suppressed.

\subsection{Examples}

Below are some examples of policy files and code examples that
illustrate their effects.  Only assignment operations are used
but remember that the flow-policy applies to all information flows.
Comments in the code examples describe a direct effect of the
given policy file.  Fake FlowSource and FlowSink names are used
to aid in clarity.

Any variable definition marked "OK" indicates that this
definition would  be allowed given the policy file
(and consequently also allowed in the absent of any flow-policy
file).  Any variable definition marked "FORBIDDEN" indicates that
the definition is forbidden by the flow-policy file.

Any assignment marked "OK" indicates that this assignment is valid
(with or without the policy file).  "OK*" means the assignment itself
is valid but that one of variables in the assignment generates an
error when it is defined.  An assignment marked "SUPPRESSED"
indicates an assignment that would normally generate an error but
this error was suppressed by the policy file.  Finally, an assignment
marked "FORBIDDEN" indicates that the assignment will still fail
with an error.

In the absence of a flow-policy file all variable definitions
below are valid.  Any assignment marked with SUPPRESSED or FORBIDDEN
would generate an error in the absence of a flow-policy file.

Example 1:
\begin{Verbatim}
Policy File 1:
  A -> B, C, D, E, F
  B -> C, D, E
  C -> B

Code Examples 1:
  @FlowSource({A,B}) @FlowSink({D})   Object abToD;  //OK
  @FlowSource({A,B}) @FlowSink({D,E}) Object abToDe; //OK
  @FlowSource({A}) @FlowSink({D}) Object aToD;     //OK

  @FlowSource({A,B}) @FlowSink({D,F}) Object abToDf; //FORBIDDEN
  @FlowSource({E}) @FlowSink({F}) Object eToF;       //FORBIDDEN

  @FlowSink({B}) Object noneToB;   //FORBIDDEN
  @FlowSource({A}) Object aToNone; //FORBIDDEN
  @FlowSource({Z}) Object zToNone; //FORBIDDEN
  Object noneToNone; //OK
  Object anotherNoneToNone; //OK
  ...
  abToD  = aToD;  //OK
  abToDe = aToD;  //OK
  aToD   = abToD; //SUPPRESSED
  eToF   = aToD;        //FORBIDDEN
  noneToNone = abToDe;  //FORBIDDEN
  noneToNone = noneToB; //FORBIDDEN
  noneToNone = anotherNoneToNone; //OK
\end{Verbatim}

Example 2:
\begin{Verbatim}
Policy File 2:
  ANY -> {}
  {} -> ANY

Code Examples 2:
  @FlowSource({A}) Object aToNone; //OK
  @FlowSource({B}) Object bToNone; //OK
  @FlowSink({B}) Object noneToB;   //OK
  @FlowSource({A}) @FlowSink({A}) Object aToA; //FORBIDDEN
  @FlowSource({B}) @FlowSink({A}) Object bToA; //FORBIDDEN
  @FlowSource({ANY}) Object anyToNone; //OK
  @FlowSink({ANY}) Object noneToAny; //OK
  @FlowSource({ANY}) @FlowSink({A,B}) anyToAb; //FORBIDDEN
  Object noneToNone; //OK;
  ...
  anyToNone = aToNone; //OK
  bToNone   = aToNone; //OK
  noneToB   = bToNone; //FORBIDDEN
  anyToAb   = noneToNone; //OK*
  anyToNone = noneToAny;  //OK
\end{Verbatim}

Example 3:
\begin{Verbatim}
Policy File 3:
  ANY -> C, D, {}
  {}  -> A, B
  A -> B, D      #D is superfluous here
  B -> B, C, D   #C and D are superfluous here

Code Examples 3:
  @FlowSink({A,B}) Object noneToAb;      //OK
  @FlowSink({A,B,C}) Object noneToAbc;   //FORBIDDEN
  @FlowSink({C,D}) Object noneToCd;      //FORBIDDEN
  @FlowSink({A,B,C}) @FlowSink({C,D}) Object noneToCd; //FORBIDDEN
  @FlowSource({A,B,C}) Object abcToNone; //OK
  @FlowSource({ANY}) Object anyToNone;   //OK
  @FlowSource({A,B}) @FlowSink({B,D}) Object abToBd;    //OK
  @FlowSource({A,B,C}) @FlowSink({C,D}) Object abcToCd; //OK
  ...
  noneToAb = noneToCd; //OK
  noneToAb = abcToCd;  //FORBIDDEN
  abToBd = abcToCD;    //FORBIDDEN (nothing maps to A except {})
  abcToNone = anyToNone; //OK
\end{Verbatim}

\section{Miscellaneous}

Methods like \<equals()> and \<toString()> that are inherited from
\<Object> are the most general possible, so that overriding methods
can restrict the annotations further. Thus, they
return \<FlowSource.ANY> and no flow sinks.

Binary operations like string concatenation or integer addition,
result in the least upper bound of the two component types.


%% Adding on to that, if you try to compute a @FlowSource{something} int
%%  with a int literal (0 or 100, etc) it will resolve to another
%%  @FlowSource{something} int. If you try the same with a
%%  @FlowSink{something} int with an int literal, it will result in
%%  @FlowSink{} int because it's not safe to add a flowsink to the int
%%  literal. To bypass this, you must declare a local variable with
%%  "@SuppressWarnings("flow") @FlowSink{something} int tempZero = 0;"
%%  and then use the local variable in the calculation.
%%  Again document why the warning can be suppressed.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  FlowSinks someData FlowSources enum 5cm flowsources 'c'
%  LocalWords:  flowsinks realString asdf PolyFlowSources PolyFlowSinks
%  LocalWords:  sparta NoFlow ConservativeFlow astub TODO jsr308
%  LocalWords:  FlowSource
