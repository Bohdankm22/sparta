
package android.database;

class Cursor {
//Added by Carl Hartung
abstract @Source(FlowPermission.DATABASE) String getString(@Source({DATABASE, LITERAL}) int columnIndex);
//Returns the value of the requested column as a String.

abstract @Source(FlowPermission.DATABASE) int getColumnIndex(String columnName);
//Returns the zero-based index for the given column name, or -1 if the column doesn't exist.

abstract void close();
//Closes the Cursor, releasing all of its resources and making it completely invalid.

abstract boolean moveToFirst();
//Move the cursor to the first row.

abstract boolean moveToNext();
//Move the cursor to the next row.

abstract @Source(FlowPermission.DATABASE) int getInt(@Source({DATABASE, LITERAL}) int columnIndex);
//Returns the value of the requested column as an int.

abstract boolean isClosed();
//return true if the cursor is closed

abstract @Source(FlowPermission.DATABASE) long getLong(@Source({DATABASE, LITERAL})  int columnIndex);
//Returns the value of the requested column as a long.

abstract boolean isAfterLast();
//Returns whether the cursor is pointing to the position after the last row.

abstract @Source(FlowPermission.DATABASE) int getCount();
//Returns the numbers of rows in the cursor.

abstract boolean moveToPosition(int position);
//Move the cursor to an absolute position.

abstract void registerDataSetObserver(DataSetObserver observer);
//Register an observer that is called when changes happen to the contents of the this cursors data set, for example, when the data set is changed via requery();, deactivate();, or close();.

abstract @Source(FlowPermission.DATABASE) int getColumnIndexOrThrow(String columnName);
//Returns the zero-based index for the given column name, or throws IllegalArgumentException if the column doesn't exist.

abstract @Source(FlowPermission.DATABASE) double getDouble(@Source({DATABASE, LITERAL})  int columnIndex);
//Returns the value of the requested column as a double.

abstract boolean requery();
//This method was deprecated in API level 11. Don't use this. Just request a new cursor, so you can do this asynchronously and update your list view once the new cursor comes back.

abstract void unregisterDataSetObserver(DataSetObserver observer);
//Unregister an observer that has previously been registered with this cursor via registerContentObserver(ContentObserver);.

abstract boolean isLast();
//Returns whether the cursor is pointing to the last row.

abstract boolean isBeforeFirst();
//Returns whether the cursor is pointing to the position before the first row.

abstract @Source(FlowPermission.DATABASE) String[] getColumnNames();
//Returns a string array holding the names of all of the columns in the result set in the order in which they were listed in the result.

abstract void registerContentObserver(ContentObserver observer);
//Register an observer that is called when changes happen to the content backing this cursor.

abstract @Source(FlowPermission.DATABASE) float getFloat(@Source({DATABASE, LITERAL}) int columnIndex);
//Returns the value of the requested column as a float.

abstract void setNotificationUri(ContentResolver cr, Uri uri);
//Register to watch a content URI for changes.

abstract boolean moveToLast();
//Move the cursor to the last row.

abstract void unregisterContentObserver(ContentObserver observer);
//Unregister an observer that has previously been registered with this cursor via registerContentObserver(ContentObserver);.

abstract @Source(FlowPermission.DATABASE) short getShort(@Source({DATABASE, LITERAL}) int columnIndex);
//Returns the value of the requested column as a short.

abstract @Source(FlowPermission.DATABASE) String getColumnName(@Source({DATABASE, LITERAL}) int columnIndex);
//Returns the column name at the given zero-based column index.

abstract @Source(FlowPermission.DATABASE) int getColumnCount();
//Return total number of columns

abstract @Source(FlowPermission.DATABASE) byte[] getBlob(@Source({DATABASE, LITERAL}) int columnIndex);
//Returns the value of the requested column as a byte array.


// UNUSED AND UNANNOTATED
// abstract void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer);
// abstract void deactivate();
// abstract Bundle getExtras();
// abstract int getPosition();
// abstract int getType(int columnIndex);
// abstract boolean getWantsAllOnMoveCalls();
// abstract boolean isFirst();
// abstract boolean isNull(int columnIndex);
// abstract boolean move(int offset);
// abstract boolean moveToFirst();
// abstract boolean moveToNext();
// abstract boolean moveToPrevious();
// abstract Bundle respond(Bundle extras);

}


package android.database.sqlite;

class SQLiteClosable {
//void acquireReference();
//Acquires a reference to the object.

void close();
//Releases a reference to the object, closing the object if the last reference was released.

//void releaseReference();
//Releases a reference to the object, closing the object if the last reference was released.

//void releaseReferenceFromContainer();
//This method was deprecated in API level 16. Do not use.


//PROTECTED
//abstract void onAllReferencesReleased();
//Called when the last reference to the object was released by a call to releaseReference(); or close();.

//void onAllReferencesReleasedFromContainer();
//This method was deprecated in API level 16. Do not use.

}

class SQLiteDatabase {
    @Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy);

//Added by Philip
    @Source(FlowPermission.SQLITE_DATABASE) int delete(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String table, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String whereClause, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) [] whereArgs) @Source(FlowPermission.ANY);
    void execSQL(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String sql) @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.SQLITE_DATABASE) long insert(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String table, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String nullColumnHack, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) ContentValues values) @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE);
    @Source(FlowPermission.SQLITE_DATABASE) int update(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String table, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) ContentValues values, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String whereClause, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) [] whereArgs) @Source(FlowPermission.SQLITE_DATABASE);


    void endTransaction();
    //End a transaction.
    
    //@Source(FlowPermission.SQLITE_DATABASE) int update(@Sink(FlowPermission.SQLITE_DATABASE) String table, @Sink(FlowPermission.SQLITE_DATABASE) ContentValues values, @Sink(FlowPermission.SQLITE_DATABASE) String whereClause, @Sink(FlowPermission.SQLITE_DATABASE) String[] whereArgs);
    //Convenience method for updating rows in the database.
    
    void setTransactionSuccessful();
    //Marks the current transaction as successful.
    
    void beginTransaction();
    //Begins a transaction in EXCLUSIVE mode.
    
    @Source(FlowPermission.SQLITE_DATABASE) Cursor rawQuery(@Sink(FlowPermission.SQLITE_DATABASE) String sql, @Sink(FlowPermission.SQLITE_DATABASE) String[] selectionArgs, @Sink(FlowPermission.SQLITE_DATABASE) CancellationSignal cancellationSignal);
    //Runs the provided SQL and returns a Cursor over the result set.
    
    SQLiteStatement compileStatement(@Sink(FlowPermission.SQLITE_DATABASE) String sql);
    //Compiles an SQL statement into a reusable pre-compiled statement object.
    
    boolean isOpen();
    //Returns true if the database is currently open.
    
    static SQLiteDatabase openDatabase(String path, SQLiteDatabase.CursorFactory factory, int flags, DatabaseErrorHandler errorHandler);
    //Open the database according to the flags OPEN_READWRITE OPEN_READONLY CREATE_IF_NECESSARY and/or NO_LOCALIZED_COLLATORS.
    
    static SQLiteDatabase openDatabase(String path, SQLiteDatabase.CursorFactory factory, int flags);
    //Open the database according to the flags OPEN_READWRITE OPEN_READONLY CREATE_IF_NECESSARY and/or NO_LOCALIZED_COLLATORS.

}


class SQLiteOpenHelper {
//Added by Philip
    @Source(FlowPermission.SQLITE_DATABASE) SQLiteDatabase getReadableDatabase() @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.SQLITE_DATABASE) SQLiteDatabase getWritableDatabase() @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.ANY) @Sink({}) SQLiteOpenHelper(@Source(FlowPermission.ANY) @Sink({}) Context context, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String name, @Source(FlowPermission.ANY) @Sink({}) CursorFactory factory, @Source(FlowPermission.ANY) @Sink({}) int version);
}

class SQLiteQueryBuilder {

 @Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE) SQLiteDatabase db, @Sink(SQLITE_DATABASE) String[] projectionIn, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String sortOrder);
            void setProjectionMap(Map<String,String> columnMap);
            
//Added by Philip
    void appendWhere(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) CharSequence inWhere) @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.SQLITE_DATABASE) Cursor query(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) SQLiteDatabase db, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) [] projectionIn, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String selection, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) [] selectionArgs, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String groupBy, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String having, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String sortOrder, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String limit) @Source(FlowPermission.ANY) @Sink({});
    void setTables(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String inTables) @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.SQLITE_DATABASE) SQLiteQueryBuilder();
}