package android.view;

class ContextMenu{
        ContextMenu setHeaderTitle(CharSequence arg0);
}

class ContextThemeWrapper {

//void applyOverrideConfiguration(Configuration overrideConfiguration);
//Call to set an "override configuration" on this context -- this is a configuration that replies one or more values of the standard configuration that is applied to the context.

Resources getResources();
//Return a Resources instance for your application's package.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolyX

//Resources.Theme getTheme();
//Return the Theme object associated with this Context.

//void setTheme(int resid);
//Set the base theme for this context.

//Protected Methods
//void attachBaseContext(Context newBase);
//Set the base context for this ContextWrapper.

//void onApplyThemeResource(Resources.Theme theme, int resid, boolean first);
//Called by setTheme(int); and getTheme(); to apply a theme resource to the current Theme object.

}

class Display{
            int getPixelFormat();
            int getWidth();
            int getHeight();
             void getSize(Point outSize);
}

class LayoutInflater {


abstract LayoutInflater cloneInContext(Context newContext);
//Create a copy of the existing LayoutInflater object, with the copy pointing to a different Context than the original.

final View createView(String name, String prefix, AttributeSet attrs);
//Low-level function for instantiating a view by name.

static LayoutInflater from(Context context);
//Obtains the LayoutInflater from the given context.

Context getContext();
//Return the context we are running in, for access to resources, class loader, etc.

final LayoutInflater.Factory getFactory();
//Return the current LayoutInflater.Factory (or null);.

//final LayoutInflater.Factory2 getFactory2();
//Return the current LayoutInflater.Factory2.

//LayoutInflater.Filter getFilter();
View inflate(int resource, ViewGroup root);
//Inflate a new view hierarchy from the specified xml resource.

View inflate(XmlPullParser parser, ViewGroup root);
//Inflate a new view hierarchy from the specified xml node.

View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot);
//Inflate a new view hierarchy from the specified XML node.

View inflate(int resource, ViewGroup root, boolean attachToRoot);
//Inflate a new view hierarchy from the specified xml resource.

void setFactory(LayoutInflater.Factory factory);
//Attach a custom Factory interface for creating views while using this LayoutInflater.

void setFactory2(LayoutInflater.Factory2 factory);
//Like setFactory(LayoutInflater.Factory);, but allows you to set a LayoutInflater.Factory2 interface.

//void setFilter(LayoutInflater.Filter filter);
//Sets the LayoutInflater.Filter to by this LayoutInflater.

//Protected Methods
//View onCreateView(String name, AttributeSet attrs);
//This routine is responsible for creating the correct subclass of View given the xml element name.

//View onCreateView(View parent, String name, AttributeSet attrs);
//Version of onCreateView(String, AttributeSet); that also takes the future parent of the view being constructure.

}

class Menu {

            int addIntentOptions(int arg0, int arg1, int arg2, ComponentName arg3, Intent[] arg4, Intent arg5, int arg6, MenuItem[] arg7);

abstract MenuItem add(@Sink(DISPLAY) CharSequence title);
//Add a new item to the menu.

abstract MenuItem add(int groupId, int itemId, int order, int titleRes);
//Variation on add(int, int, int, CharSequence); that takes a string resource identifier instead of the string itself.

abstract MenuItem add(int titleRes);
//Add a new item to the menu.

abstract MenuItem add(int groupId, int itemId, int order, @Sink(DISPLAY) CharSequence title);
//Add a new item to the menu.

//abstract int addIntentOptions(int groupId, int itemId, int order, ComponentName caller, Intent[] specifics, Intent intent, int flags, MenuItem[] outSpecificItems);
//Add a group of menu items corresponding to actions that can be performed for a particular Intent.

//abstract SubMenu addSubMenu(int groupId, int itemId, int order, CharSequence title);
//Add a new sub-menu to the menu.

//abstract SubMenu addSubMenu(int groupId, int itemId, int order, int titleRes);
//Variation on addSubMenu(int, int, int, CharSequence); that takes a string resource identifier for the title instead of the string itself.

//abstract SubMenu addSubMenu(CharSequence title);
//Add a new sub-menu to the menu.

//abstract SubMenu addSubMenu(int titleRes);
//Add a new sub-menu to the menu.

abstract void clear();
//Remove all existing items from the menu, leaving it empty as if it had just been created.

//abstract void close();
//Closes the menu, if open.

abstract MenuItem findItem(int id);
//Return the menu item with a particular identifier.

//abstract MenuItem getItem(int index);
//Gets the menu item at the given index.

abstract boolean hasVisibleItems();
//Return whether the menu currently has item items that are visible.

//abstract boolean isShortcutKey(int keyCode, KeyEvent event);
//Is a keypress one of the defined shortcut keys for this window.

//abstract boolean performIdentifierAction(int id, int flags);
//Execute the menu item action associated with the given menu identifier.

//abstract boolean performShortcut(int keyCode, KeyEvent event, int flags);
//Execute the menu item action associated with the given shortcut character.

//abstract void removeGroup(int groupId);
//Remove all items in the given group.

//abstract void removeItem(int id);
//Remove the item with the given identifier.

//abstract void setGroupCheckable(int group, boolean checkable, boolean exclusive);
//Control whether a particular group of items can show a check mark.

//abstract void setGroupEnabled(int group, boolean enabled);
//Enable or disable all menu items that are in the given group.

abstract void setGroupVisible(int group, boolean visible);
//Show or hide all menu items that are in the given group.

//abstract void setQwertyMode(boolean isQwerty);
//Control whether the menu should be running in qwerty mode (alphabetic shortcuts); or 12-key mode (numeric shortcuts);.

//abstract int size();
//Get the number of items in the menu.

}


class MenuInflater{

//Add by SOM, once we have the new defaulting, then these annotations can be removed.
void inflate (@Sink(FlowPermission.CONDITIONAL) int menuRes, @Sink(FlowPermission.CONDITIONAL) Menu menu);

}

class MenuItem {

//abstract boolean collapseActionView();
//Collapse the action view associated with this menu item.

//abstract boolean expandActionView();
//Expand the action view associated with this menu item.

abstract ActionProvider getActionProvider();
//Gets the ActionProvider.

//abstract View getActionView();
//Returns the currently set action view for this menu item.

//abstract char getAlphabeticShortcut();
//Return the char for this menu item's alphabetic shortcut.

//abstract int getGroupId();
//Return the group identifier that this menu item is part of.

//abstract Drawable getIcon();
//Returns the icon for this item as a Drawable (getting it from resources if it hasn't been loaded before);.

//abstract Intent getIntent();
//Return the Intent associated with this item.

abstract int getItemId();
//Return the identifier for this menu item.

abstract ContextMenu.ContextMenuInfo getMenuInfo();
//Gets the extra information linked to this menu item.

//abstract char getNumericShortcut();
//Return the char for this menu item's numeric (12-key); shortcut.

//abstract int getOrder();
//Return the category and order within the category of this item.

//abstract SubMenu getSubMenu();
//Get the sub-menu to be invoked when this item is selected, if it has one.

//abstract CharSequence getTitle();
//Retrieve the current title of the item.

//abstract CharSequence getTitleCondensed();
//Retrieve the current condensed title of the item.

abstract boolean hasSubMenu();
//Check whether this item has an associated sub-menu.

abstract boolean isActionViewExpanded();
//Returns true if this menu item's action view has been expanded.

abstract boolean isCheckable();
//Return whether the item can currently display a check mark.

abstract boolean isChecked();
//Return whether the item is currently displaying a check mark.

//abstract boolean isEnabled();
//Return the enabled state of the menu item.

//abstract boolean isVisible();
//Return the visibility of the menu item.

abstract MenuItem setActionProvider(ActionProvider actionProvider);
//Sets the ActionProvider responsible for creating an action view if the item is placed on the action bar.

abstract MenuItem setActionView(int resId);
//Set an action view for this menu item.

abstract MenuItem setActionView(View view);
//Set an action view for this menu item.

//abstract MenuItem setAlphabeticShortcut(char alphaChar);
//Change the alphabetic shortcut associated with this item.

//abstract MenuItem setCheckable(boolean checkable);
//Control whether this item can display a check mark.

abstract MenuItem setChecked(@Sink(FlowPermission.DISPLAY) boolean checked);
//Control whether this item is shown with a check mark.

abstract MenuItem setEnabled(@Sink(FlowPermission.DISPLAY) boolean enabled);
//Sets whether the menu item is enabled.
// setting to false greys out the View

abstract MenuItem setIcon(@Sink(FlowPermission.DISPLAY) Drawable icon);
//Change the icon associated with this item.

abstract MenuItem setIcon(int iconRes);
//Change the icon associated with this item.

abstract MenuItem setIntent(Intent intent);
//Change the Intent associated with this item.

//abstract MenuItem setNumericShortcut(char numericChar);
//Change the numeric shortcut associated with this item.

//abstract MenuItem setOnActionExpandListener(MenuItem.OnActionExpandListener listener);
//Set an MenuItem.OnActionExpandListener on this menu item to be notified when the associated action view is expanded or collapsed.

abstract MenuItem setOnMenuItemClickListener(MenuItem.OnMenuItemClickListener menuItemClickListener);
//Set a custom listener for invocation of this menu item.

abstract MenuItem setShortcut(char numericChar, char alphaChar);
//Change both the numeric and alphabetic shortcut associated with this item.

abstract void setShowAsAction(int actionEnum);
//Sets how this item should display in the presence of an Action Bar.

//abstract MenuItem setShowAsActionFlags(int actionEnum);
//Sets how this item should display in the presence of an Action Bar.

abstract MenuItem setTitle(@Sink(FlowPermission.DISPLAY) CharSequence title);
//Change the title associated with this item.

abstract MenuItem setTitle(int title);
//Change the title associated with this item.

//abstract MenuItem setTitleCondensed(CharSequence title);
//Change the condensed title associated with this item.

abstract MenuItem setVisible(@Sink(FlowPermission.DISPLAY) boolean visible);
//Sets the visibility of the menu item.

}

class MotionEvent {
//final void addBatch(long eventTime, PointerCoords[] pointerCoords, int metaState);
//Add a new movement to the batch of movements in this event.

//final void addBatch(long eventTime, float x, float y, float pressure, float size, int metaState);
//Add a new movement to the batch of movements in this event.

//static int axisFromString(String symbolicName);
//Gets an axis by its symbolic name such as "AXIS_X" or an equivalent numeric constant such as "42".

//static String axisToString(int axis);
//Returns a string that represents the symbolic name of the specified axis such as "AXIS_X" or an equivalent numeric constant such as "42" if unknown.

final int findPointerIndex(int pointerId);
//Given a pointer identifier, find the index of its data in the event.

final int getAction();
//Return the kind of action being performed.

//final int getActionIndex();
//For ACTION_POINTER_DOWN or ACTION_POINTER_UP as returned by getActionMasked();, this returns the associated pointer index.

//final int getActionMasked();
//Return the masked action being performed, without pointer index information.

//final float getAxisValue(int axis);
//getAxisValue(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getAxisValue(int axis, int pointerIndex);
//Returns the value of the requested axis for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final int getButtonState();
//Gets the state of all buttons that are pressed such as a mouse or stylus button.

//final int getDeviceId();
//Gets the id for the device that this event came from.

//final long getDownTime();
//Returns the time (in ms); when the user originally pressed down to start a stream of position events.

//final int getEdgeFlags();
//Returns a bitfield indicating which edges, if any, were touched by this MotionEvent.

final @Source(FlowPermission.READ_TIME) long getEventTime();
//Retrieve the time this event occurred, in the uptimeMillis(); time base.

//final int getFlags();
//Gets the motion event flags.

//final float getHistoricalAxisValue(int axis, int pointerIndex, int pos);
//Returns the historical value of the requested axis, as per getAxisValue(int, int);, occurred between this event and the previous event for the given pointer.

//final float getHistoricalAxisValue(int axis, int pos);
//getHistoricalAxisValue(int, int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final long getHistoricalEventTime(int pos);
//Returns the time that a historical movement occurred between this event and the previous event, in the uptimeMillis(); time base.

//final float getHistoricalOrientation(int pointerIndex, int pos);
//Returns a historical orientation coordinate, as per getOrientation(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalOrientation(int pos);
//getHistoricalOrientation(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final void getHistoricalPointerCoords(int pointerIndex, int pos, MotionEvent.PointerCoords outPointerCoords);
//Populates a MotionEvent.PointerCoords object with historical pointer coordinate data, as per getPointerCoords(int, MotionEvent.PointerCoords);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalPressure(int pos);
//getHistoricalPressure(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalPressure(int pointerIndex, int pos);
//Returns a historical pressure coordinate, as per getPressure(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalSize(int pos);
//getHistoricalSize(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalSize(int pointerIndex, int pos);
//Returns a historical size coordinate, as per getSize(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalToolMajor(int pointerIndex, int pos);
//Returns a historical tool major axis coordinate, as per getToolMajor(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalToolMajor(int pos);
//getHistoricalToolMajor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalToolMinor(int pointerIndex, int pos);
//Returns a historical tool minor axis coordinate, as per getToolMinor(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalToolMinor(int pos);
//getHistoricalToolMinor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalTouchMajor(int pointerIndex, int pos);
//Returns a historical touch major axis coordinate, as per getTouchMajor(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalTouchMajor(int pos);
//getHistoricalTouchMajor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalTouchMinor(int pointerIndex, int pos);
//Returns a historical touch minor axis coordinate, as per getTouchMinor(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalTouchMinor(int pos);
//getHistoricalTouchMinor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalX(int pos);
//getHistoricalX(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalX(int pointerIndex, int pos);
//Returns a historical X coordinate, as per getX(int);, that occurred between this event and the previous event for the given pointer.

//final float getHistoricalY(int pos);
//getHistoricalY(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getHistoricalY(int pointerIndex, int pos);
//Returns a historical Y coordinate, as per getY(int);, that occurred between this event and the previous event for the given pointer.

//final int getHistorySize();
//Returns the number of historical points in this event.

//final int getMetaState();
//Returns the state of any meta / modifier keys that were in effect when the event was generated.

//final float getOrientation(int pointerIndex);
//Returns the orientation of the touch area and tool area in radians clockwise from vertical for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final float getOrientation();
//getOrientation(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final void getPointerCoords(int pointerIndex, MotionEvent.PointerCoords outPointerCoords);
//Populates a MotionEvent.PointerCoords object with pointer coordinate data for the specified pointer index.

final int getPointerCount();
//The number of pointers of data contained in this event.

final int getPointerId(int pointerIndex);
//Return the pointer identifier associated with a particular pointer data index is this event.

//final void getPointerProperties(int pointerIndex, MotionEvent.PointerProperties outPointerProperties);
//Populates a MotionEvent.PointerProperties object with pointer properties for the specified pointer index.

//final float getPressure();
//getPressure(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getPressure(int pointerIndex);
//Returns the current pressure of this event for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final float getRawX();
//Returns the original raw X coordinate of this event.

//final float getRawY();
//Returns the original raw Y coordinate of this event.

//final float getSize(int pointerIndex);
//Returns a scaled value of the approximate size for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final float getSize();
//getSize(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final int getSource();
//Gets the source of the event.

//final float getToolMajor(int pointerIndex);
//Returns the length of the major axis of an ellipse that describes the size of the approaching tool for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final float getToolMajor();
//getToolMajor(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getToolMinor();
//getToolMinor(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getToolMinor(int pointerIndex);
//Returns the length of the minor axis of an ellipse that describes the size of the approaching tool for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final int getToolType(int pointerIndex);
//Gets the tool type of a pointer for the given pointer index.

//final float getTouchMajor();
//getTouchMajor(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getTouchMajor(int pointerIndex);
//Returns the length of the major axis of an ellipse that describes the touch area at the point of contact for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

//final float getTouchMinor();
//getTouchMinor(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getTouchMinor(int pointerIndex);
//Returns the length of the minor axis of an ellipse that describes the touch area at the point of contact for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getX(int pointerIndex);
//Returns the X coordinate of this event for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getX();
//getX(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getXPrecision();
//Return the precision of the X coordinates being reported.

final float getY(int pointerIndex);
//Returns the Y coordinate of this event for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getY();
//getY(int); for the first pointer index (may be an arbitrary pointer identifier);.

//final float getYPrecision();
//Return the precision of the Y coordinates being reported.

//static MotionEvent obtain(long downTime, long eventTime, int action, int pointerCount, PointerProperties[] pointerProperties, PointerCoords[] pointerCoords, int metaState, int buttonState, float xPrecision, float yPrecision, int deviceId, int edgeFlags, int source, int flags);
//Create a new MotionEvent, filling in all of the basic values that define the motion.

//static MotionEvent obtain(long downTime, long eventTime, int action, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int deviceId, int edgeFlags);
//Create a new MotionEvent, filling in all of the basic values that define the motion.

//static MotionEvent obtain(long downTime, long eventTime, int action, int pointerCount, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int deviceId, int edgeFlags);
//This method was deprecated in API level 9. Use obtain(long, long, int, float, float, float, float, int, float, float, int, int); instead.

//static MotionEvent obtain(long downTime, long eventTime, int action, int pointerCount, int[] pointerIds, PointerCoords[] pointerCoords, int metaState, float xPrecision, float yPrecision, int deviceId, int edgeFlags, int source, int flags);
//This method was deprecated in API level 14. Use obtain(long, long, int, int, PointerProperties[], PointerCoords[], int, int, float, float, int, int, int, int); instead.

//static MotionEvent obtain(MotionEvent other);
//Create a new MotionEvent, copying from an existing one.

//static MotionEvent obtain(long downTime, long eventTime, int action, float x, float y, int metaState);
//Create a new MotionEvent, filling in a subset of the basic motion values.

//static MotionEvent obtainNoHistory(MotionEvent other);
//Create a new MotionEvent, copying from an existing one, but not including any historical point information.

//final void offsetLocation(float deltaX, float deltaY);
//Adjust this event's location.

final void recycle();
//Recycle the MotionEvent, to be re-used by a later caller.

//final void setAction(int action);
//Sets this event's action.

//final void setEdgeFlags(int flags);
//Sets the bitfield indicating which edges, if any, were touched by this MotionEvent.

final void setLocation(float x, float y);
//Set this event's location.

//final void setSource(int source);
//Modifies the source of the event.

//String toString();
//Returns a string containing a concise, human-readable description of this object.

//final void transform(Matrix matrix);
//Applies a transformation matrix to all of the points in the event.

//void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

//Protected Methods
//void finalize()
//Invoked when the garbage collector has detected that this instance is no longer reachable.

}

class SurfaceView{
//SOM
 @Sink(FlowPermission.DISPLAY) SurfaceHolder getHolder ();
}        
     
class SurfaceHolder{
//Add by SOM, once we have the new defaulting, then these annotations can be removed.
   void addCallback (@Sink(FlowPermission.CONDITIONAL) SurfaceHolder.Callback callback) @Sink(FlowPermission.DISPLAY);
   void setType (@Sink(FlowPermission.CONDITIONAL)  int type) @Sink(FlowPermission.DISPLAY);

}

interface SurfaceHolder$Callback {
    void surfaceCreated(@Sink(FlowPermission.DISPLAY) SurfaceHolder arg0);
    void surfaceChanged(@Sink(FlowPermission.DISPLAY) SurfaceHolder arg0, int arg1, int arg2, int arg3);
    void surfaceDestroyed(@Sink(FlowPermission.DISPLAY) SurfaceHolder arg0);
}

class VelocityTracker {

void addMovement(MotionEvent event);
//Add a user's movement to the tracker.

void clear();
//Reset the velocity tracker back to its initial state.

void computeCurrentVelocity(int units, float maxVelocity);
//Compute the current velocity based on the points that have been collected.

void computeCurrentVelocity(int units);
//Equivalent to invoking computeCurrentVelocity(int, float); with a maximum velocity of Float.MAX_VALUE.

//abstract T getNextPoolable();

float getXVelocity();
//Retrieve the last computed X velocity.

float getXVelocity(int id);
//Retrieve the last computed X velocity.

float getYVelocity(int id);
//Retrieve the last computed Y velocity.

float getYVelocity();
//Retrieve the last computed Y velocity.

//abstract boolean isPooled();

static VelocityTracker obtain();
//Retrieve a new VelocityTracker object to watch the velocity of a motion.

void recycle();
//Return a VelocityTracker object back to be re-used by others.

//abstract void setNextPoolable(T element);

//abstract void setPooled(boolean isPooled);

//Protected Methods
//void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

}


class View {

View(Context context);

final View findViewById(int id);
//Look for a child view with the given id.

void setVisibility(int visibility);
//Set the enabled state of this view.

ViewGroup.LayoutParams getLayoutParams();
//Get the LayoutParams associated with this view.

final Context getContext();
//Returns the context the view is running in, through which it can access the current theme, resources, etc.

final int getMeasuredWidth();
//Like getMeasuredWidthAndState();, but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK);.
//CSH:: we decided this was information about the view, not sensitive data

void setOnClickListener(View.OnClickListener l);
//Register a callback to be invoked when this view is clicked.

int getId();
//Returns this view's identifier.

int getVisibility();
//Returns the visibility status for this view.

void startAnimation(@Sink(FlowPermission.DISPLAY) Animation animation);
//Start the specified animation now.

final void measure(int widthMeasureSpec, int heightMeasureSpec);
//This is called to find out how big a view should be.

final int getMeasuredHeight();
//Like getMeasuredHeightAndState();, but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK);.

Object getTag(int key);
//Returns the tag associated with this view and the specified key.

Object getTag();
//Returns this view's tag.

final int getLeft();
//Left position of this view relative to its parent.

final int getHeight();
//Return the height of your view.

void setTag(int key, Object tag);
//Sets a tag associated with this view and a key.

void setTag(Object tag);
//Sets the tag associated with this view.

boolean onTouchEvent(MotionEvent event);
//Implement this method to handle touch screen motion events.
//CSH:: MotionEvents are user input, but they're not "typing", does that count?

final int getTop();
//Top position of this view relative to its parent.

void clearAnimation();
//Cancels any animations for this view.

boolean requestFocus(int direction, Rect previouslyFocusedRect);
//Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from.

final boolean requestFocus(int direction);
//Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading.

final boolean requestFocus();
//Call this to try to give focus to a specific view or to one of its descendants.

void setOnCreateContextMenuListener(View.OnCreateContextMenuListener l);
//Register a callback to be invoked when the context menu for this view is being built.

void setLayoutParams(ViewGroup.LayoutParams params);
//Set the layout parameters associated with this view.

void setEnabled(boolean enabled);
//Set the enabled state of this view.

void setBackgroundResource(int resid);
//Set the background to a given resource.
//CSH:: "resid" isn't shown on the screen, but the background resource (image/other) referenced by it is.

void setBackgroundColor(int color);
//Sets the background color for this view.
//CSH:: the integer "color" isn't displayed on the screen, but a particular color is (defined by the number)

final int getWidth();
//Return the width of the your view.

final int getRight();
//Right position of this view relative to its parent.

final ViewParent getParent();
//Gets the parent of this view.

final int getBottom();
//Bottom position of this view relative to its parent.

void setSelected(@Sink(FlowPermission.DISPLAY) boolean selected);
//Changes the selection state of this view.

void setFocusable(boolean focusable);
//Set whether this view can receive the focus.

void setBackgroundDrawable(@Sink(FlowPermission.DISPLAY) Drawable background);
//This method was deprecated in API level 16. use setBackground(Drawable); instead

boolean postDelayed(Runnable action, long delayMillis);
//Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses.

protected void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

void layout(int l, int t, int r, int b);
//Assign a size and position to a view and all of its descendants
//This is the second phase of the layout mechanism.

boolean isSelected();
//Indicates the selection state of this view.

boolean isEnabled();
//Returns the enabled status for this view.

IBinder getWindowToken();
//Retrieve a unique token identifying the window this view is attached to.

boolean willNotDraw();
//Returns whether or not this View draws on its own.

void setPadding(int left, int top, int right, int bottom);
//Sets the padding.

void setOverScrollMode(int overScrollMode);
//Set the over-scroll mode for this view.

void setOnTouchListener(View.OnTouchListener l);
//Register a callback to be invoked when a touch event is sent to this view.

void setOnLongClickListener(View.OnLongClickListener l);
//Register a callback to be invoked when this view is clicked and held.

void setOnKeyListener(View.OnKeyListener l);
//Register a callback to be invoked when a hardware key is pressed in this view.

void setOnFocusChangeListener(View.OnFocusChangeListener l);
//Register a callback to be invoked when focus of this view changed.

void setMinimumWidth(int minWidth);
//Sets the minimum width of the view.

void setMinimumHeight(int minHeight);
//Sets the minimum height of the view.

void setLayerType(int layerType, Paint paint);
//Specifies the type of layer backing this view.

void setLabelFor(int id);
//Sets the id of a view for which this view serves as a label for accessibility purposes.

void setImportantForAccessibility(int mode);
//Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.

void setId(int id);
//Sets the identifier for this view.

void setHasTransientState(boolean hasTransientState);
//Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible.

void setClickable(boolean clickable);
//Enables or disables click events for this view.

void setAccessibilityDelegate(View.AccessibilityDelegate delegate);
//Sets a delegate for implementing accessibility support via composition as opposed to inheritance.

void saveHierarchyState(SparseArray<Parcelable> container);
//Store this view hierarchy's frozen state into the given container.

void restoreHierarchyState(SparseArray<Parcelable> container);
//Restore this view hierarchy's frozen state from the given container.

void postOnAnimationDelayed(Runnable action, long delayMillis);
//Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses.

void postOnAnimation(Runnable action);
//Causes the Runnable to execute on the next animation time step.

void postInvalidateOnAnimation(int left, int top, int right, int bottom);
//Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame.

void postInvalidateOnAnimation();
//Cause an invalidate to happen on the next animation time step, typically the next display frame.

void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom);
//Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.

void postInvalidateDelayed(long delayMilliseconds);
//Cause an invalidate to happen on a subsequent cycle through the event loop.

void postInvalidate(int left, int top, int right, int bottom);
//Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.

void postInvalidate();
//Cause an invalidate to happen on a subsequent cycle through the event loop.

boolean performAccessibilityAction(int action, Bundle arguments);
//Performs the specified accessibility action on the view.

boolean onTrackballEvent(MotionEvent event);
//Implement this method to handle trackball motion events.

protected Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

protected void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

void onPopulateAccessibilityEvent(AccessibilityEvent event);
//Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent); giving a chance to this View to populate the accessibility event with its text content.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

protected void onCreateContextMenu(@Sink(FlowPermission.DISPLAY) ContextMenu menu);
//Views should implement this if the view itself is going to add items to the context menu.

void offsetLeftAndRight(int offset);
//Offset this view's horizontal location by the specified amount of pixels.

boolean isVerticalScrollBarEnabled();
//Indicate whether the vertical scrollbar should be drawn or not.

boolean isPressed();
//Indicates whether the view is currently in pressed state.

boolean isLongClickable();
//Indicates whether this view reacts to long click events or not.

boolean isHorizontalScrollBarEnabled();
//Indicate whether the horizontal scrollbar should be drawn or not.

boolean isFocused();
//Returns true if this view has focus

final boolean isFocusable();
//Returns whether this View is able to take focus.

boolean isClickable();
//Indicates whether this view reacts to click events or not.

boolean hasTransientState();
//Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible.

final int getScrollX();
//Return the scrolled left position of this view.

final int getScrollY();
//Return the scrolled top position of this view.

View getRootView();
//Finds the topmost view in the current view hierarchy.

Resources getResources();
//Returns the resources associated with this view.

int getOverScrollMode();
//Returns the over-scroll mode for this view.

void getLocationOnScreen(int[] location);
//Computes the coordinates of this view on the screen.

int getLayerType();
//Indicates what type of layer is currently associated with this view.

int getLabelFor();
//Gets the id of a view for which this view serves as a label for accessibility purposes.

int getImportantForAccessibility();
//Gets the mode for determining whether this View is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.

Drawable getBackground();
//Gets the background drawable

AccessibilityNodeProvider getAccessibilityNodeProvider();
//Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.

void draw(@Sink(FlowPermission.DISPLAY) Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

boolean dispatchTouchEvent(MotionEvent event);
//Pass the touch screen motion event down to the target view, or this view if it is the target.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

boolean canScrollVertically(int direction);
//Check if this view can be scrolled vertically in a certain direction.

boolean canScrollHorizontally(int direction);
//Check if this view can be scrolled horizontally in a certain direction.

void addTouchables(ArrayList<View> views);
//Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself); to views.

void addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener);
//Add a listener for attach state changes.

void addFocusables(ArrayList<View> views, int direction, int focusableMode);
//Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself); to views.

void addFocusables(ArrayList<View> views, int direction);
//Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself); to views.

void scrollTo(int x, int y);
//Set the scrolled position of your view.

final void setMeasuredDimension(int measuredWidth, int measuredHeight);
//This mehod must be called by onMeasure(int, int) to store the measured width and measured height.

int getPaddingTop();
//Returns the top padding of this view.

void setWillNotDraw(boolean willNotDraw);
//If this view doesn't do any drawing on its own, set this flag to allow further optimizations.

static int getDefaultSize(int size, int measureSpec);
//Utility to return a default size.

boolean removeCallbacks(Runnable action);
//Removes the specified Runnable from the message queue.

void refreshDrawableState();
//Call this to force a view to update its drawable state.

void playSoundEffect(int soundConstant);
//Play a sound effect for this view.
//CSH: Need a PLAY_AUDIO permission?

boolean isInTouchMode();
//Returns whether the device is currently in touch mode.

final boolean isFocusableInTouchMode();
//When a view is focusable, it may not want to take focus when in touch mode.

void invalidate(Rect dirty);
//Mark the area defined by dirty as needing to be drawn.

void invalidate(int l, int t, int r, int b);
//Mark the area defined by the rect (l,t,r,b) as needing to be drawn.

void invalidate();
//Invalidate the whole view.

final int[] getDrawableState();
//Return an array of resource IDs of the drawable states representing the current state of the view.

View findFocus();
//Find the view in the hierarchy rooted at this view that currently has focus.

int getPaddingBottom();
//Returns the bottom padding of this view.

final View findViewWithTag(Object tag);
//Look for a child view with the given tag.

int getPaddingLeft();
//Returns the left padding of this view.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

int getPaddingRight();
//Returns the right padding of this view.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

int getMinimumHeight();
//Returns the minimum height of the view.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void requestLayout();
//Call this when something has changed which has invalidated the layout of this view.

 void setPaddingRelative(int start, int top, int end, int bottom);

void destroyDrawingCache();
 boolean post(Runnable action);



// UNUSED AND UNANNOTATED

// void addChildrenForAccessibility(ArrayList<View> children);
// void addOnLayoutChangeListener(View.OnLayoutChangeListener listener);
// ViewPropertyAnimator animate();
// void announceForAccessibility(CharSequence text);
// void bringToFront();
// void buildDrawingCache();
// void buildDrawingCache(boolean autoScale);
// void buildLayer();
// boolean callOnClick();
// void cancelLongPress();
// boolean checkInputConnectionProxy(View view);
// void clearFocus();
// static int combineMeasuredStates(int curState, int newState);
// void computeScroll();
// AccessibilityNodeInfo createAccessibilityNodeInfo();
// void createContextMenu(ContextMenu menu);
// void dispatchConfigurationChanged(Configuration newConfig);
// void dispatchDisplayHint(int hint);
// boolean dispatchDragEvent(DragEvent event);
// boolean dispatchGenericMotionEvent(MotionEvent event);
// boolean dispatchKeyEvent(KeyEvent event);
// boolean dispatchKeyEventPreIme(KeyEvent event);
// boolean dispatchKeyShortcutEvent(KeyEvent event);
// void dispatchSystemUiVisibilityChanged(int visibility);
// boolean dispatchTrackballEvent(MotionEvent event);
// boolean dispatchUnhandledMove(View focused, int direction);
// void dispatchWindowFocusChanged(boolean hasFocus);
// void dispatchWindowSystemUiVisiblityChanged(int visible);
// void dispatchWindowVisibilityChanged(int visibility);
// void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags);
// View focusSearch(int direction);
// void forceLayout();
// static int generateViewId();
// float getAlpha();
// Animation getAnimation();
// IBinder getApplicationWindowToken();
// int getBaseline();
// float getCameraDistance();
// CharSequence getContentDescription();
// Display getDisplay();
// Bitmap getDrawingCache(boolean autoScale);
// Bitmap getDrawingCache();
// int getDrawingCacheBackgroundColor();
// int getDrawingCacheQuality();
// void getDrawingRect(Rect outRect);
// long getDrawingTime();
// boolean getFilterTouchesWhenObscured();
// boolean getFitsSystemWindows();
// ArrayList<View> getFocusables(int direction);
// void getFocusedRect(Rect r);
// boolean getGlobalVisibleRect(Rect r, Point globalOffset);
// final boolean getGlobalVisibleRect(Rect r);
// Handler getHandler();
// void getHitRect(Rect outRect);
// int getHorizontalFadingEdgeLength();
// boolean getKeepScreenOn();
// KeyEvent.DispatcherState getKeyDispatcherState();
// int getLayoutDirection();
// final boolean getLocalVisibleRect(Rect r);
// void getLocationInWindow(int[] location);
// Matrix getMatrix();
// final int getMeasuredHeightAndState();
// final int getMeasuredState();
// final int getMeasuredWidthAndState();
// int getMinimumWidth();
// int getNextFocusDownId();
// int getNextFocusForwardId();
// int getNextFocusLeftId();
// int getNextFocusRightId();
// int getNextFocusUpId();
// View.OnFocusChangeListener getOnFocusChangeListener();
// int getPaddingEnd();
// int getPaddingStart();
// ViewParent getParentForAccessibility();
// float getPivotX();
// float getPivotY();
// float getRotation();
// float getRotationX();
// float getRotationY();
// float getScaleX();
// float getScaleY();
// int getScrollBarDefaultDelayBeforeFade();
// int getScrollBarFadeDuration();
// int getScrollBarSize();
// int getScrollBarStyle();
// int getSolidColor();
// int getSystemUiVisibility();
// int getTextAlignment();
// int getTextDirection();
// TouchDelegate getTouchDelegate();
// ArrayList<View> getTouchables();
// float getTranslationX();
// float getTranslationY();
// int getVerticalFadingEdgeLength();
// int getVerticalScrollbarPosition();
// int getVerticalScrollbarWidth();
// ViewTreeObserver getViewTreeObserver();
// int getWindowSystemUiVisibility();
// int getWindowVisibility();
// void getWindowVisibleDisplayFrame(Rect outRect);
// float getX();
// float getY();
// boolean hasFocus();
// boolean hasFocusable();
// boolean hasOnClickListeners();
// boolean hasOverlappingRendering();
// boolean hasWindowFocus();
// static View inflate(Context context, int resource, ViewGroup root);
// void invalidateDrawable(Drawable drawable);
// boolean isActivated();
// boolean isDirty();
// boolean isDrawingCacheEnabled();
// boolean isDuplicateParentStateEnabled();
// boolean isHapticFeedbackEnabled();
// boolean isHardwareAccelerated();
// boolean isHorizontalFadingEdgeEnabled();
// boolean isHovered();
// boolean isInEditMode();
// boolean isLayoutRequested();
// boolean isOpaque();
// boolean isPaddingRelative();
// boolean isSaveEnabled();
// boolean isSaveFromParentEnabled();
// boolean isScrollContainer();
// boolean isScrollbarFadingEnabled();
// boolean isShown();
// boolean isSoundEffectsEnabled();
// boolean isVerticalFadingEdgeEnabled();
// void jumpDrawablesToCurrentState();
// void offsetTopAndBottom(int offset);
// boolean onCheckIsTextEditor();
// InputConnection onCreateInputConnection(EditorInfo outAttrs);
// boolean onDragEvent(DragEvent event);
// Handles drag events sent by the system following a call to startDrag();.
// boolean onFilterTouchEventForSecurity(MotionEvent event);
// void onFinishTemporaryDetach();
// boolean onGenericMotionEvent(MotionEvent event);
// void onHoverChanged(boolean hovered);
// boolean onHoverEvent(MotionEvent event);
// boolean onKeyDown(int keyCode, KeyEvent event);
// boolean onKeyLongPress(int keyCode, KeyEvent event);
// boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event);
// boolean onKeyPreIme(int keyCode, KeyEvent event);
// boolean onKeyShortcut(int keyCode, KeyEvent event);
// boolean onKeyUp(int keyCode, KeyEvent event);
// void onRtlPropertiesChanged(int layoutDirection);
// void onScreenStateChanged(int screenState);
// void onStartTemporaryDetach();
// void onWindowFocusChanged(boolean hasWindowFocus);
// void onWindowSystemUiVisibilityChanged(int visible);
// boolean performClick();
// boolean performHapticFeedback(int feedbackConstant);
// boolean performHapticFeedback(int feedbackConstant, int flags);
// boolean performLongClick();
// void removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener);
// void removeOnLayoutChangeListener(View.OnLayoutChangeListener listener);
// void requestFitSystemWindows();
// final boolean requestFocusFromTouch();
// void requestFocusFromTouch);
// boolean requestRectangleOnScreen(Rect rectangle);
// boolean requestRectangleOnScreen(Rect rectangle, boolean immediate);
// static int resolveSize(int size, int measureSpec);
// static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState);
// void scheduleDrawable(Drawable who, Runnable what, long when);
// void scrollBy(int x, int y);
// void sendAccessibilityEvent(int eventType);
// void sendAccessibilityEventUnchecked(AccessibilityEvent event);
// void setActivated(boolean activated);
// void setAlpha(float alpha);
// void setAnimation(Animation animation);
// void setBackground(Drawable background);
// final void setBottom(int bottom);
// void setCameraDistance(float distance);
// void setContentDescription(CharSequence contentDescription);
// void setDrawingCacheBackgroundColor(int color);
// void setDrawingCacheEnabled(boolean enabled);
// void setDrawingCacheQuality(int quality);
// void setDuplicateParentStateEnabled(boolean enabled);
// void setFadingEdgeLength(int length);
// void setFilterTouchesWhenObscured(boolean enabled);
// void setFitsSystemWindows(boolean fitSystemWindows);
// void setFocusableInTouchMode(boolean focusableInTouchMode);
// void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled);
// void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled);
// void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled);
// void setHovered(boolean hovered);
// void setKeepScreenOn(boolean keepScreenOn);
// void setLayerPaint(Paint paint);
// void setLayoutDirection(int layoutDirection);
// final void setLeft(int left);
// void setLongClickable(boolean longClickable);
// void setNextFocusDownId(int nextFocusDownId);
// void setNextFocusForwardId(int nextFocusForwardId);
// void setNextFocusLeftId(int nextFocusLeftId);
// void setNextFocusRightId(int nextFocusRightId);
// void setNextFocusUpId(int nextFocusUpId);
// void setOnDragListener(View.OnDragListener l);
// void setOnGenericMotionListener(View.OnGenericMotionListener l);
// void setOnHoverListener(View.OnHoverListener l);
// void setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l);
// void setPivotX(float pivotX);
// void setPivotY(float pivotY);
// void setPressed(boolean pressed);
// final void setRight(int right);
// void setRotation(float rotation);
// void setRotationX(float rotationX);
// void setRotationY(float rotationY);
// void setSaveEnabled(boolean enabled);
// void setSaveFromParentEnabled(boolean enabled);
// void setScaleX(float scaleX);
// void setScaleY(float scaleY);
// void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade);
// void setScrollBarFadeDuration(int scrollBarFadeDuration);
// void setScrollBarSize(int scrollBarSize);
// void setScrollBarStyle(int style);
// void setScrollContainer(boolean isScrollContainer);
// void setScrollX(int value);
// void setScrollY(int value);
// void setScrollbarFadingEnabled(boolean fadeScrollbars);
// void setSoundEffectsEnabled(boolean soundEffectsEnabled);
// void setSystemUiVisibility(int visibility);
// void setTextAlignment(int textAlignment);
// void setTextDirection(int textDirection);
// final void setTop(int top);
// void setTouchDelegate(TouchDelegate delegate);
// void setTranslationX(float translationX);
// void setTranslationY(float translationY);
// void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled);
// void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled);
// void setVerticalScrollbarPosition(int position);
// void setWillNotCacheDrawing(boolean willNotCacheDrawing);
// void setX(float x);
// void setY(float y);
// boolean showContextMenu();
// ActionMode startActionMode(ActionMode.Callback callback);
// final boolean startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags);
// String toString();
// void unscheduleDrawable(Drawable who);
// void unscheduleDrawable(Drawable who, Runnable what);
// boolean willNotCacheDrawing();
// 
// ***** Protected Methods *****
// boolean awakenScrollBars(int startDelay);
// boolean awakenScrollBars(int startDelay, boolean invalidate);
// boolean awakenScrollBars();
// int computeHorizontalScrollExtent();
// int computeHorizontalScrollOffset();
// int computeHorizontalScrollRange();
// int computeVerticalScrollExtent();
// int computeVerticalScrollOffset();
// int computeVerticalScrollRange();
// boolean dispatchGenericFocusedEvent(MotionEvent event);
// boolean dispatchGenericPointerEvent(MotionEvent event);
// boolean dispatchHoverEvent(MotionEvent event);
// void dispatchRestoreInstanceState(SparseArray<Parcelable> container);
// void dispatchSaveInstanceState(SparseArray<Parcelable> container);
// void dispatchSetActivated(boolean activated);
// void dispatchSetPressed(boolean pressed);
// void dispatchSetSelected(boolean selected);
// void dispatchVisibilityChanged(View changedView, int visibility);
// void drawableStateChanged();
// boolean fitSystemWindows(Rect insets);
// float getBottomFadingEdgeStrength();
// int getBottomPaddingOffset();
// ContextMenu.ContextMenuInfo getContextMenuInfo();
// int getHorizontalScrollbarHeight();
// float getLeftFadingEdgeStrength();
// int getLeftPaddingOffset();
// float getRightFadingEdgeStrength();
// int getRightPaddingOffset();
// int getSuggestedMinimumHeight();
// int getSuggestedMinimumWidth();
// float getTopFadingEdgeStrength();
// int getTopPaddingOffset();
// int getWindowAttachCount();
// void initializeFadingEdge(TypedArray a);
// void initializeScrollbars(TypedArray a);
// boolean isPaddingOffsetRequired();
// static int[] mergeDrawableStates(int[] baseState, int[] additionalState);
// void onAnimationEnd();
// void onAnimationStart();
// void onConfigurationChanged(Configuration newConfig);
// int[] onCreateDrawableState(int extraSpace);
// void onDisplayHint(int hint);
// final void onDrawScrollBars(Canvas canvas);
// void onFinishInflate();
// void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect);
// void onLayout(boolean changed, int left, int top, int right, int bottom);
// void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY);
// void onScrollChanged(int l, int t, int oldl, int oldt);
// boolean onSetAlpha(int alpha);
// void onVisibilityChanged(View changedView, int visibility);
// void onWindowVisibilityChanged(int visibility);
// boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent);
// boolean verifyDrawable(Drawable who);

}

class View$OnClickListener{
        void onClick(View arg0);
}

class View$OnCreateContextMenuListener{
        void onCreateContextMenu(ContextMenu arg0, View arg1, ContextMenuInfo arg2);
}


class View$OnTouchListener{
        boolean onTouch(View arg0, MotionEvent arg1);
}

class ViewConfiguration {
    
static ViewConfiguration get(Context context);
//Returns a configuration for the specified context.

static int getDoubleTapTimeout();

//static int getEdgeSlop();
//This method was deprecated in API level 3. Use getScaledEdgeSlop(); instead.

//static int getFadingEdgeLength();
//This method was deprecated in API level 3. Use getScaledFadingEdgeLength(); instead.

//static long getGlobalActionKeyTimeout();
//The amount of time a user needs to press the relevant key to bring up the global actions dialog.

//static int getJumpTapTimeout();

//static int getKeyRepeatDelay();

//static int getKeyRepeatTimeout();

static int getLongPressTimeout();

//static int getMaximumDrawingCacheSize();
//This method was deprecated in API level 3. Use getScaledMaximumDrawingCacheSize(); instead.

//static int getMaximumFlingVelocity();
//This method was deprecated in API level 4. Use getScaledMaximumFlingVelocity(); instead.

//static int getMinimumFlingVelocity();
//This method was deprecated in API level 3. Use getScaledMinimumFlingVelocity(); instead.

//static int getPressedStateDuration();

int getScaledDoubleTapSlop();

//int getScaledEdgeSlop();

//int getScaledFadingEdgeLength();

//int getScaledMaximumDrawingCacheSize();
//The maximum drawing cache size expressed in bytes.

int getScaledMaximumFlingVelocity();

int getScaledMinimumFlingVelocity();
//int getScaledOverflingDistance();

//int getScaledOverscrollDistance();

//int getScaledPagingTouchSlop();

//int getScaledScrollBarSize();

int getScaledTouchSlop();

//int getScaledWindowTouchSlop();

//static int getScrollBarFadeDuration();

//static int getScrollBarSize();
//This method was deprecated in API level 3. Use getScaledScrollBarSize(); instead.

//static int getScrollDefaultDelay();

//static float getScrollFriction();
//The amount of friction applied to scrolls and flings.

static int getTapTimeout();

//static int getTouchSlop();
//This method was deprecated in API level 3. Use getScaledTouchSlop(); instead.

//static int getWindowTouchSlop();
//This method was deprecated in API level 3. Use getScaledWindowTouchSlop(); instead.

//static long getZoomControlsTimeout();
//The amount of time that the zoom controls should be displayed on the screen expressed in milliseconds.

//boolean hasPermanentMenuKey();
//Report if the device has a permanent menu key available to the user.

    
}

class ViewGroup {

void setPadding(int left, int top, int right, int bottom);

//addChildrenForAccessibility(ArrayList<View> childrenForAccessibility);
//Adds the children of a given View for accessibility.

//void addFocusables(ArrayList<View> views, int direction, int focusableMode);
//Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself); to views.

//boolean addStatesFromChildren();
//Returns whether this ViewGroup's drawable states also include its children's drawable states.

//void addTouchables(ArrayList<View> views);
//Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself); to views.

void addView(@Sink(FlowPermission.DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

void addView(@Sink(FlowPermission.DISPLAY) View child, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

void addView(@Sink(FlowPermission.DISPLAY) View child, int index);
//Adds a child view.

void addView(@Sink(FlowPermission.DISPLAY) View child);
//Adds a child view.

void addView(@Sink(FlowPermission.DISPLAY) View child, int width, int height);
//Adds a child view with this ViewGroup's default layout parameters and the specified width and height.

//void bringChildToFront(View child);
//Change the z order of the child so it's on top of all other children

//void childDrawableStateChanged(View child);
//If addStatesFromChildren(); is true, refreshes this group's drawable state (to include the states from its children);.

//void clearChildFocus(View child);
//Called when a child of this parent is giving up focus

void clearDisappearingChildren();
//Removes any pending animations for views that have been removed.

//void clearFocus();
//Called when this view wants to give up focus.

//void dispatchConfigurationChanged(Configuration newConfig);
//Dispatch a notification about a resource configuration change down the view hierarchy.

//void dispatchDisplayHint(int hint);
//Dispatch a hint about whether this view is displayed.

//boolean dispatchDragEvent(DragEvent event);
//Detects if this View is enabled and has a drag event listener.

//boolean dispatchKeyEvent(KeyEvent event);
//Dispatch a key event to the next view on the focus path.

//boolean dispatchKeyEventPreIme(KeyEvent event);
//Dispatch a key event before it is processed by any input method associated with the view hierarchy.

//boolean dispatchKeyShortcutEvent(KeyEvent event);
//Dispatches a key shortcut event.

//void dispatchSetActivated(boolean activated);
//Dispatch setActivated to all of this View's children.

//void dispatchSetSelected(boolean selected);
//Dispatch setSelected to all of this View's children.

//void dispatchSystemUiVisibilityChanged(int visible);
//Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener); down the view hierarchy.

boolean dispatchTouchEvent(MotionEvent ev);
//Pass the touch screen motion event down to the target view, or this view if it is the target.

//boolean dispatchTrackballEvent(MotionEvent event);
//Pass a trackball motion event down to the focused view.

//boolean dispatchUnhandledMove(View focused, int direction);
//This method is the last chance for the focused view and its ancestors to respond to an arrow key.

//void dispatchWindowFocusChanged(boolean hasFocus);
//Called when the window containing this view gains or loses window focus.

//void dispatchWindowSystemUiVisiblityChanged(int visible);
//Dispatch callbacks to onWindowSystemUiVisibilityChanged(int); down the view hierarchy.

//void dispatchWindowVisibilityChanged(int visibility);
//Dispatch a window visibility change down the view hierarchy.

//void endViewTransition(View view);
//This method should always be called following an earlier call to startViewTransition(View);.

View findFocus();
//Find the view in the hierarchy rooted at this view that currently has focus.

//void findViewsWithText(ArrayList<View> outViews, CharSequence text, int flags);
//Finds the Views that contain given text.

//View focusSearch(View focused, int direction);
//Find the nearest view in the specified direction that wants to take focus.

void focusableViewAvailable(View v);
//Tells the parent that a new focusable view has become available.

//boolean gatherTransparentRegion(Region region);
//This is used by the RootView to perform an optimization when the view hierarchy contains one or several SurfaceView.

//ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

View getChildAt(int index);
//Returns the view at the specified position in the group.

int getChildCount();
//Returns the number of children in the group.

//static int getChildMeasureSpec(int spec, int padding, int childDimension);
//Does the hard part of measureChildren: figuring out the MeasureSpec to pass to a particular child.

//boolean getChildVisibleRect(View child, Rect r, Point offset);
//Compute the visible part of a rectangular region defined in terms of a child view's coordinates.

int getDescendantFocusability();
//Gets the descendant focusability of this view group.

//View getFocusedChild();
//Returns the focused child of this view, if any.

//LayoutAnimationController getLayoutAnimation();
//Returns the layout animation controller used to animate the group's children.

//Animation.AnimationListener getLayoutAnimationListener();
//Returns the animation listener to which layout animation events are sent.

//LayoutTransition getLayoutTransition();
//Gets the LayoutTransition object for this ViewGroup.

//int getPersistentDrawingCache();
//Returns an integer indicating what types of drawing caches are kept in memory.

//boolean hasFocus();
//Returns true if this view has or contains focus

//boolean hasFocusable();
//Returns true if this view is focusable or if it contains a reachable View for which hasFocusable(); returns true.

//int indexOfChild(View child);
//Returns the position in the group of the specified child view.

//final void invalidateChild(View child, Rect dirty);
//Don't call or override this method.

//ViewParent invalidateChildInParent(int[] location, Rect dirty);
//Don't call or override this method.

//boolean isAlwaysDrawnWithCacheEnabled();
//Indicates whether this ViewGroup will always try to draw its children using their drawing cache.

//boolean isAnimationCacheEnabled();
//Indicates whether the children's drawing cache is used during a layout animation.

//boolean isMotionEventSplittingEnabled();
//Returns true if MotionEvents dispatched to this ViewGroup can be split to multiple children.

//void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

//final void layout(int l, int t, int r, int b);
//Assign a size and position to a view and all of its descendants
//This is the second phase of the layout mechanism.

//final void offsetDescendantRectToMyCoords(View descendant, Rect rect);
//Offset a rectangle that is in a descendant's coordinate space into our coordinate space.

//final void offsetRectIntoDescendantCoords(View descendant, Rect rect);
//Offset a rectangle that is in our coordinate space into an ancestor's coordinate space.

//boolean onInterceptHoverEvent(MotionEvent event);
//Implement this method to intercept hover events before they are handled by child views.

//boolean onInterceptTouchEvent(MotionEvent ev);
//Implement this method to intercept all touch screen motion events.

//boolean onRequestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called when a child has requested sending an AccessibilityEvent and gives an opportunity to its parent to augment the event.

//void recomputeViewAttributes(View child);
//Tell view hierarchy that the global view attributes need to be re-evaluated.

void removeAllViews();
//Call this method to remove all child views from the ViewGroup.

//void removeAllViewsInLayout();
//Called by a ViewGroup subclass to remove child views from itself, when it must first know its size on screen before it can calculate how many child views it will render.

//void removeView(View view);
//Note: do not invoke this method from draw(android.graphics.Canvas);, onDraw(android.graphics.Canvas);, dispatchDraw(android.graphics.Canvas); or any related method.

void removeViewAt(int index);
//Removes the view at the specified position in the group.

//void removeViewInLayout(View view);
//Removes a view during layout.

//void removeViews(int start, int count);
//Removes the specified range of views from the group.

//void removeViewsInLayout(int start, int count);
//Removes a range of views during layout.

//void requestChildFocus(View child, View focused);
//Called when a child of this parent wants focus

//boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate);
//Called when a child of this group wants a particular rectangle to be positioned onto the screen.

//void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
//Called when a child does not want this parent and its ancestors to intercept touch events with onInterceptTouchEvent(MotionEvent);.

//boolean requestFocus(int direction, Rect previouslyFocusedRect);
//Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. Looks for a view to give focus to respecting the setting specified by getDescendantFocusability();.

//boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called by a child to request from its parent to send an AccessibilityEvent.

//void requestTransparentRegion(View child);
//Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor.

//void scheduleLayoutAnimation();
//Schedules the layout animation to be played after the next layout pass of this view group.

//void setAddStatesFromChildren(boolean addsStates);
//Sets whether this ViewGroup's drawable states also include its children's drawable states.

//void setAlwaysDrawnWithCacheEnabled(boolean always);
//Indicates whether this ViewGroup will always try to draw its children using their drawing cache.

//void setAnimationCacheEnabled(boolean enabled);
//Enables or disables the children's drawing cache during a layout animation.

//void setClipChildren(boolean clipChildren);
//By default, children are clipped to their bounds before drawing.

//void setClipToPadding(boolean clipToPadding);
//By default, children are clipped to the padding of the ViewGroup.

void setDescendantFocusability(int focusability);
//Set the descendant focusability of this view group.

//void setLayoutAnimation(LayoutAnimationController controller);
//Sets the layout animation controller used to animate the group's children after the first layout.

//void setLayoutAnimationListener(Animation.AnimationListener animationListener);
//Specifies the animation listener to which layout animation events must be sent.

void setLayoutTransition(LayoutTransition transition);
//Sets the LayoutTransition object for this ViewGroup.

//void setMotionEventSplittingEnabled(boolean split);
//Enable or disable the splitting of MotionEvents to multiple children during touch event dispatch.

//void setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener);
//Register a callback to be invoked when a child is added to or removed from this view.

//void setPersistentDrawingCache(int drawingCacheToKeep);
//Indicates what types of drawing caches should be kept in memory after they have been created.

//boolean shouldDelayChildPressedState();
//Return true if the pressed state should be delayed for children or descendants of this ViewGroup.

//boolean showContextMenuForChild(View originalView);
//Bring up a context menu for the specified view or its ancestors.

//ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback);
//Start an action mode for the specified view.

//void startLayoutAnimation();
//Runs the layout animation.

//void startViewTransition(View view);
//This method tells the ViewGroup that the given View object, which should have this ViewGroup as its parent, should be kept around (re-displayed when the ViewGroup draws its children); even if it is removed from its parent.

//void updateViewLayout(View view, ViewGroup.LayoutParams params);
//Protected Methods

boolean addViewInLayout(View child, int index, ViewGroup.LayoutParams params, boolean preventRequestLayout);
//Adds a view during layout.

boolean addViewInLayout(View child, int index, ViewGroup.LayoutParams params);
//Adds a view during layout.

//void attachLayoutAnimationParameters(View child, ViewGroup.LayoutParams params, int index, int count);
//Subclasses should override this method to set layout animation parameters on the supplied child.

//void attachViewToParent(View child, int index, ViewGroup.LayoutParams params);
//Attaches a view to this view group.

//boolean canAnimate();
//Indicates whether the view group has the ability to animate its children after the first layout.

//boolean checkLayoutParams(ViewGroup.LayoutParams p);

//void cleanupLayoutState(View child);
//Prevents the specified child to be laid out during the next layout pass.

//void debug(int depth);
//Prints information about this view in the log output, with the tag VIEW_LOG_TAG.

//void detachAllViewsFromParent();
//Detaches all views from the parent.

//void detachViewFromParent(View child);
//Detaches a view from its parent.

//void detachViewFromParent(int index);
//Detaches a view from its parent.

//void detachViewsFromParent(int start, int count);
//Detaches a range of views from their parents.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

//void dispatchFreezeSelfOnly(SparseArray<Parcelable> container);
//Perform dispatching of a saveHierarchyState(android.util.SparseArray); freeze();} to only this view, not to its children.

//boolean dispatchGenericFocusedEvent(MotionEvent event);
//Dispatch a generic motion event to the currently focused view.

//boolean dispatchGenericPointerEvent(MotionEvent event);
//Dispatch a generic motion event to the view under the first pointer.

//boolean dispatchHoverEvent(MotionEvent event);
//Dispatch a hover event.

//void dispatchRestoreInstanceState(SparseArray<Parcelable> container);
//Called by restoreHierarchyState(android.util.SparseArray); to retrieve the state for this view and its children.

//void dispatchSaveInstanceState(SparseArray<Parcelable> container);
//Called by saveHierarchyState(android.util.SparseArray); to store the state for this view and its children.

//void dispatchSetPressed(boolean pressed);
//Dispatch setPressed to all of this View's children.

//void dispatchThawSelfOnly(SparseArray<Parcelable> container);
//Perform dispatching of a restoreHierarchyState(android.util.SparseArray); to only this view, not to its children.

//void dispatchVisibilityChanged(View changedView, int visibility);
//Dispatch a view visibility change down the view hierarchy.

//boolean drawChild(Canvas canvas, View child, long drawingTime);
//Draw one child of this View Group.

//void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

//boolean fitSystemWindows(Rect insets);
//Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows.

//ViewGroup.LayoutParams generateDefaultLayoutParams();
//Returns a set of default layout parameters.

//ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

//int getChildDrawingOrder(int childCount, int i);
//Returns the index of the child to draw for this iteration.

//boolean getChildStaticTransformation(View child, Transformation t);
//Sets t to be the static transformation of the child, if set, returning a boolean to indicate whether a static transform was set.

//boolean isChildrenDrawingOrderEnabled();
//Indicates whether the ViewGroup is drawing its children in the order defined by getChildDrawingOrder(int, int);.

//boolean isChildrenDrawnWithCacheEnabled();
//Indicates whether the ViewGroup is currently drawing its children using their drawing cache.

//void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec);
//Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding.

//void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed);
//Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding and margins.

//void measureChildren(int widthMeasureSpec, int heightMeasureSpec);
//Ask all of the children of this view to measure themselves, taking into account both the MeasureSpec requirements for this view and its padding.

//void onAnimationEnd();
//Invoked by a parent ViewGroup to notify the end of the animation currently associated with this view.

//void onAnimationStart();
//Invoked by a parent ViewGroup to notify the start of the animation currently associated with this view.

//int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

//abstract void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

//boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect);
//Look for a descendant to call requestFocus(); on.

//void removeDetachedView(View child, boolean animate);
//Finishes the removal of a detached view.

//void setChildrenDrawingCacheEnabled(boolean enabled);
//Enables or disables the drawing cache for each child of this view group.

//void setChildrenDrawingOrderEnabled(boolean enabled);
//Tells the ViewGroup whether to draw its children in the order defined by the method getChildDrawingOrder(int, int);.

//void setChildrenDrawnWithCacheEnabled(boolean enabled);
//Tells the ViewGroup to draw its children using their drawing cache.

//void setStaticTransformationsEnabled(boolean enabled);
//When this property is set to true, this ViewGroup supports static transformations on children; this causes getChildStaticTransformation(View, android.view.animation.Transformation); to be invoked when a child is drawn.

}

class ViewParent {
 
//abstract void bringChildToFront(View child);
//Change the z order of the child so it's on top of all other children

//abstract void childDrawableStateChanged(View child);
//This method is called on the parent when a child's drawable state has changed.

//abstract void clearChildFocus(View child);
//Called when a child of this parent is giving up focus

//abstract void createContextMenu(ContextMenu menu);
//Have the parent populate the specified context menu if it has anything to add (and then recurse on its parent);.

//abstract View focusSearch(View v, int direction);
//Find the nearest view in the specified direction that wants to take focus

//abstract void focusableViewAvailable(View v);
//Tells the parent that a new focusable view has become available.

//abstract boolean getChildVisibleRect(View child, Rect r, Point offset);
//Compute the visible part of a rectangular region defined in terms of a child view's coordinates.

//abstract ViewParent getParent();
//Returns the parent if it exists, or null.

//abstract ViewParent getParentForAccessibility();
//Gets the parent of a given View for accessibility.

//abstract void invalidateChild(View child, Rect r);
//All or part of a child is dirty and needs to be redrawn.

//abstract ViewParent invalidateChildInParent(int[] location, Rect r);
//All or part of a child is dirty and needs to be redrawn.

//abstract boolean isLayoutRequested();
//Indicates whether layout was requested on this view parent.

//abstract void recomputeViewAttributes(View child);
//Tell view hierarchy that the global view attributes need to be re-evaluated.

//abstract void requestChildFocus(View child, View focused);
//Called when a child of this parent wants focus

//abstract boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate);
//Called when a child of this group wants a particular rectangle to be positioned onto the screen.

//abstract void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
//Called when a child does not want this parent and its ancestors to intercept touch events with onInterceptTouchEvent(MotionEvent);.

//abstract void requestFitSystemWindows();
//Ask that a new dispatch of View.fitSystemWindows(Rect); be performed.

abstract void requestLayout();
//Called when something has changed which has invalidated the layout of a child of this view parent.

//abstract boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called by a child to request from its parent to send an AccessibilityEvent.

//abstract void requestTransparentRegion(View child);
//Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor.

//abstract boolean showContextMenuForChild(View originalView);
//Bring up a context menu for the specified view or its ancestors.

//abstract ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback);
//Start an action mode for the specified view.
}

class Window{
        void clearFlags(int flags);
        void addFlags(int flags);
}

class Window$Callback{
        boolean onMenuItemSelected(int arg0, MenuItem arg1);
}

class WindowManager{
            Display getDefaultDisplay();
}

class KeyEvent {
    @Source(FlowPermission.USER_INPUT) int getKeyCode();
}

package android.view.animation;

class Animation$AnimationListener {
    void onAnimationRepeat(Animation arg0);
    void onAnimationStart(Animation arg0);
    void onAnimationEnd(Animation arg0);
}

class AnimationUtils{
    @PolyFlow
    static Animation loadAnimation(Context context, int id);
}
