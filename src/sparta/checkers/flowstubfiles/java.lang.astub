


package java.lang;

class AutoCloseable{
            void close() throws Exception;
}

@PolyFlowReceiver
class AbstractStringBuilder{
        int length();
        setLength(int arg0);
}

@PolyFlowReceiver
interface Appendable {
//Added by pbsf
    Appendable append(CharSequence arg0) throws IOException;
    Appendable append(CharSequence arg0, int arg1, int arg2) throws IOException;
    Appendable append(char arg0) throws IOException;
}

@PolyFlowReceiver
class AssertionError extends Error {
//Added by pbsf
    AssertionError();
    AssertionError(Object arg0);
    AssertionError(boolean arg0);
    AssertionError(char arg0);
    AssertionError(int arg0);
    AssertionError(long arg0);
    AssertionError(float arg0);
    AssertionError(double arg0);
    AssertionError(String arg0, Throwable arg1);
}

@PolyFlowReceiver
class Boolean implements Serializable, Comparable<Boolean> {
    final Boolean TRUE;
    final Boolean FALSE;
    final Class<Boolean> TYPE;
    Boolean(boolean arg0);
    Boolean(String arg0);
    static boolean parseBoolean(String arg0);
    boolean booleanValue();
    static Boolean valueOf(boolean arg0);
    static Boolean valueOf(String arg0);
    static String toString(boolean arg0);
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    static boolean getBoolean(String arg0);
    int compareTo(Boolean arg0);
    static int compare(boolean arg0, boolean arg1);
}

@PolyFlowReceiver
class Byte extends Number implements Comparable<Byte> {
//Added by pbsf
    final byte MIN_VALUE;
    final byte MAX_VALUE;
    final Class<Byte> TYPE;
    final int SIZE;
    static String toString(byte arg0);
    static Byte valueOf(byte arg0);
    static byte parseByte(String arg0, int arg1) throws NumberFormatException;
    static byte parseByte(String arg0) throws NumberFormatException;
    static Byte valueOf(String arg0, int arg1) throws NumberFormatException;
    static Byte valueOf(String arg0) throws NumberFormatException;
    static Byte decode(String arg0) throws NumberFormatException;
    Byte(byte arg0);
    Byte(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    int compareTo(Byte arg0);
    static int compare(byte arg0, byte arg1);
}

@PolyFlowReceiver
class Character implements Serializable, Comparable<Character> {
    final @Source(FlowPermission.LITERAL) int MIN_RADIX;
    final @Source(FlowPermission.LITERAL) int MAX_RADIX;
    final @Source(FlowPermission.LITERAL) char MIN_VALUE;
    final @Source(FlowPermission.LITERAL) char MAX_VALUE;
    final Class<Character> TYPE;
    final @Source(FlowPermission.LITERAL) byte UNASSIGNED;
    final @Source(FlowPermission.LITERAL) byte UPPERCASE_LETTER;
    final @Source(FlowPermission.LITERAL) byte LOWERCASE_LETTER;
    final @Source(FlowPermission.LITERAL) byte TITLECASE_LETTER;
    final @Source(FlowPermission.LITERAL) byte MODIFIER_LETTER;
    final @Source(FlowPermission.LITERAL) byte OTHER_LETTER;
    final @Source(FlowPermission.LITERAL) byte NON_SPACING_MARK;
    final @Source(FlowPermission.LITERAL) byte ENCLOSING_MARK;
    final @Source(FlowPermission.LITERAL) byte COMBINING_SPACING_MARK;
    final @Source(FlowPermission.LITERAL) byte DECIMAL_DIGIT_NUMBER;
    final @Source(FlowPermission.LITERAL) byte LETTER_NUMBER;
    final @Source(FlowPermission.LITERAL) byte OTHER_NUMBER;
    final @Source(FlowPermission.LITERAL) byte SPACE_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte LINE_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte PARAGRAPH_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte CONTROL;
    final @Source(FlowPermission.LITERAL) byte FORMAT;
    final @Source(FlowPermission.LITERAL) byte PRIVATE_USE;
    final @Source(FlowPermission.LITERAL) byte SURROGATE;
    final @Source(FlowPermission.LITERAL) byte DASH_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte START_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte END_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte CONNECTOR_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte OTHER_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte MATH_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte CURRENCY_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte MODIFIER_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte OTHER_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte INITIAL_QUOTE_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte FINAL_QUOTE_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_UNDEFINED;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_LEFT_TO_RIGHT;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_EUROPEAN_NUMBER;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_ARABIC_NUMBER;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_NONSPACING_MARK;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_BOUNDARY_NEUTRAL;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_PARAGRAPH_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_SEGMENT_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_WHITESPACE;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_OTHER_NEUTRALS;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT;
    final @Source(FlowPermission.LITERAL) char MIN_HIGH_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MAX_HIGH_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MIN_LOW_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MAX_LOW_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MIN_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MAX_SURROGATE;
    final @Source(FlowPermission.LITERAL) int MIN_SUPPLEMENTARY_CODE_POINT;
    final @Source(FlowPermission.LITERAL) int MIN_CODE_POINT;
    final @Source(FlowPermission.LITERAL) int MAX_CODE_POINT;
    final @Source(FlowPermission.LITERAL) int SIZE;
    Character(char arg0);
    static Character valueOf(char arg0);
    char charValue();
    int hashCode();
    boolean equals(Object arg0);
    String toString();
    static String toString(char arg0);
    static boolean isValidCodePoint(int arg0);
    static boolean isBmpCodePoint(int arg0);
    static boolean isSupplementaryCodePoint(int arg0);
    static boolean isHighSurrogate(char arg0);
    static boolean isLowSurrogate(char arg0);
    static boolean isSurrogate(char arg0);
    static boolean isSurrogatePair(char arg0, char arg1);
    static int charCount(int arg0);
    static int toCodePoint(char arg0, char arg1);
    static int codePointAt(CharSequence arg0, int arg1);
    static int codePointAt(char[] arg0, int arg1);
    static int codePointAt(char[] arg0, int arg1, int arg2);
    static int codePointBefore(CharSequence arg0, int arg1);
    static int codePointBefore(char[] arg0, int arg1);
    static int codePointBefore(char[] arg0, int arg1, int arg2);
    static char highSurrogate(int arg0);
    static char lowSurrogate(int arg0);
    static int toChars(int arg0, char[] arg1, int arg2);
    static char[] toChars(int arg0);
    static int codePointCount(CharSequence arg0, int arg1, int arg2);
    static int codePointCount(char[] arg0, int arg1, int arg2);
    static int offsetByCodePoints(CharSequence arg0, int arg1, int arg2);
    static int offsetByCodePoints(char[] arg0, int arg1, int arg2, int arg3, int arg4);
    static boolean isLowerCase(char arg0);
    static boolean isLowerCase(int arg0);
    static boolean isUpperCase(char arg0);
    static boolean isUpperCase(int arg0);
    static boolean isTitleCase(char arg0);
    static boolean isTitleCase(int arg0);
    static boolean isDigit(char arg0);
    static boolean isDigit(int arg0);
    static boolean isDefined(char arg0);
    static boolean isDefined(int arg0);
    static boolean isLetter(char arg0);
    static boolean isLetter(int arg0);
    static boolean isLetterOrDigit(char arg0);
    static boolean isLetterOrDigit(int arg0);
    static boolean isJavaLetter(char arg0);
    static boolean isJavaLetterOrDigit(char arg0);
    static boolean isAlphabetic(int arg0);
    static boolean isIdeographic(int arg0);
    static boolean isJavaIdentifierStart(char arg0);
    static boolean isJavaIdentifierStart(int arg0);
    static boolean isJavaIdentifierPart(char arg0);
    static boolean isJavaIdentifierPart(int arg0);
    static boolean isUnicodeIdentifierStart(char arg0);
    static boolean isUnicodeIdentifierStart(int arg0);
    static boolean isUnicodeIdentifierPart(char arg0);
    static boolean isUnicodeIdentifierPart(int arg0);
    static boolean isIdentifierIgnorable(char arg0);
    static boolean isIdentifierIgnorable(int arg0);
    static char toLowerCase(char arg0);
    static int toLowerCase(int arg0);
    static char toUpperCase(char arg0);
    static int toUpperCase(int arg0);
    static char toTitleCase(char arg0);
    static int toTitleCase(int arg0);
    static int digit(char arg0, int arg1);
    static int digit(int arg0, int arg1);
    static int getNumericValue(char arg0);
    static int getNumericValue(int arg0);
    static boolean isSpace(char arg0);
    static boolean isSpaceChar(char arg0);
    static boolean isSpaceChar(int arg0);
    static boolean isWhitespace(char arg0);
    static boolean isWhitespace(int arg0);
    static boolean isISOControl(char arg0);
    static boolean isISOControl(int arg0);
    static int getType(char arg0);
    static int getType(int arg0);
    static char forDigit(int arg0, int arg1);
    static byte getDirectionality(char arg0);
    static byte getDirectionality(int arg0);
    static boolean isMirrored(char arg0);
    static boolean isMirrored(int arg0);
    int compareTo(Character arg0);
    static int compare(char arg0, char arg1);
    static char reverseBytes(char arg0);
    static String getName(int arg0);
}

@PolyFlowReceiver
class Character$UnicodeBlock extends Subset {
    final UnicodeBlock BASIC_LATIN;
    final UnicodeBlock LATIN_1_SUPPLEMENT;
    final UnicodeBlock LATIN_EXTENDED_A;
    final UnicodeBlock LATIN_EXTENDED_B;
    final UnicodeBlock IPA_EXTENSIONS;
    final UnicodeBlock SPACING_MODIFIER_LETTERS;
    final UnicodeBlock COMBINING_DIACRITICAL_MARKS;
    final UnicodeBlock GREEK;
    final UnicodeBlock CYRILLIC;
    final UnicodeBlock ARMENIAN;
    final UnicodeBlock HEBREW;
    final UnicodeBlock ARABIC;
    final UnicodeBlock DEVANAGARI;
    final UnicodeBlock BENGALI;
    final UnicodeBlock GURMUKHI;
    final UnicodeBlock GUJARATI;
    final UnicodeBlock ORIYA;
    final UnicodeBlock TAMIL;
    final UnicodeBlock TELUGU;
    final UnicodeBlock KANNADA;
    final UnicodeBlock MALAYALAM;
    final UnicodeBlock THAI;
    final UnicodeBlock LAO;
    final UnicodeBlock TIBETAN;
    final UnicodeBlock GEORGIAN;
    final UnicodeBlock HANGUL_JAMO;
    final UnicodeBlock LATIN_EXTENDED_ADDITIONAL;
    final UnicodeBlock GREEK_EXTENDED;
    final UnicodeBlock GENERAL_PUNCTUATION;
    final UnicodeBlock SUPERSCRIPTS_AND_SUBSCRIPTS;
    final UnicodeBlock CURRENCY_SYMBOLS;
    final UnicodeBlock COMBINING_MARKS_FOR_SYMBOLS;
    final UnicodeBlock LETTERLIKE_SYMBOLS;
    final UnicodeBlock NUMBER_FORMS;
    final UnicodeBlock ARROWS;
    final UnicodeBlock MATHEMATICAL_OPERATORS;
    final UnicodeBlock MISCELLANEOUS_TECHNICAL;
    final UnicodeBlock CONTROL_PICTURES;
    final UnicodeBlock OPTICAL_CHARACTER_RECOGNITION;
    final UnicodeBlock ENCLOSED_ALPHANUMERICS;
    final UnicodeBlock BOX_DRAWING;
    final UnicodeBlock BLOCK_ELEMENTS;
    final UnicodeBlock GEOMETRIC_SHAPES;
    final UnicodeBlock MISCELLANEOUS_SYMBOLS;
    final UnicodeBlock DINGBATS;
    final UnicodeBlock CJK_SYMBOLS_AND_PUNCTUATION;
    final UnicodeBlock HIRAGANA;
    final UnicodeBlock KATAKANA;
    final UnicodeBlock BOPOMOFO;
    final UnicodeBlock HANGUL_COMPATIBILITY_JAMO;
    final UnicodeBlock KANBUN;
    final UnicodeBlock ENCLOSED_CJK_LETTERS_AND_MONTHS;
    final UnicodeBlock CJK_COMPATIBILITY;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS;
    final UnicodeBlock HANGUL_SYLLABLES;
    final UnicodeBlock PRIVATE_USE_AREA;
    final UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS;
    final UnicodeBlock ALPHABETIC_PRESENTATION_FORMS;
    final UnicodeBlock ARABIC_PRESENTATION_FORMS_A;
    final UnicodeBlock COMBINING_HALF_MARKS;
    final UnicodeBlock CJK_COMPATIBILITY_FORMS;
    final UnicodeBlock SMALL_FORM_VARIANTS;
    final UnicodeBlock ARABIC_PRESENTATION_FORMS_B;
    final UnicodeBlock HALFWIDTH_AND_FULLWIDTH_FORMS;
    final UnicodeBlock SPECIALS;
    final UnicodeBlock SURROGATES_AREA;
    final UnicodeBlock SYRIAC;
    final UnicodeBlock THAANA;
    final UnicodeBlock SINHALA;
    final UnicodeBlock MYANMAR;
    final UnicodeBlock ETHIOPIC;
    final UnicodeBlock CHEROKEE;
    final UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS;
    final UnicodeBlock OGHAM;
    final UnicodeBlock RUNIC;
    final UnicodeBlock KHMER;
    final UnicodeBlock MONGOLIAN;
    final UnicodeBlock BRAILLE_PATTERNS;
    final UnicodeBlock CJK_RADICALS_SUPPLEMENT;
    final UnicodeBlock KANGXI_RADICALS;
    final UnicodeBlock IDEOGRAPHIC_DESCRIPTION_CHARACTERS;
    final UnicodeBlock BOPOMOFO_EXTENDED;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A;
    final UnicodeBlock YI_SYLLABLES;
    final UnicodeBlock YI_RADICALS;
    final UnicodeBlock CYRILLIC_SUPPLEMENTARY;
    final UnicodeBlock TAGALOG;
    final UnicodeBlock HANUNOO;
    final UnicodeBlock BUHID;
    final UnicodeBlock TAGBANWA;
    final UnicodeBlock LIMBU;
    final UnicodeBlock TAI_LE;
    final UnicodeBlock KHMER_SYMBOLS;
    final UnicodeBlock PHONETIC_EXTENSIONS;
    final UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A;
    final UnicodeBlock SUPPLEMENTAL_ARROWS_A;
    final UnicodeBlock SUPPLEMENTAL_ARROWS_B;
    final UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B;
    final UnicodeBlock SUPPLEMENTAL_MATHEMATICAL_OPERATORS;
    final UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_ARROWS;
    final UnicodeBlock KATAKANA_PHONETIC_EXTENSIONS;
    final UnicodeBlock YIJING_HEXAGRAM_SYMBOLS;
    final UnicodeBlock VARIATION_SELECTORS;
    final UnicodeBlock LINEAR_B_SYLLABARY;
    final UnicodeBlock LINEAR_B_IDEOGRAMS;
    final UnicodeBlock AEGEAN_NUMBERS;
    final UnicodeBlock OLD_ITALIC;
    final UnicodeBlock GOTHIC;
    final UnicodeBlock UGARITIC;
    final UnicodeBlock DESERET;
    final UnicodeBlock SHAVIAN;
    final UnicodeBlock OSMANYA;
    final UnicodeBlock CYPRIOT_SYLLABARY;
    final UnicodeBlock BYZANTINE_MUSICAL_SYMBOLS;
    final UnicodeBlock MUSICAL_SYMBOLS;
    final UnicodeBlock TAI_XUAN_JING_SYMBOLS;
    final UnicodeBlock MATHEMATICAL_ALPHANUMERIC_SYMBOLS;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B;
    final UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT;
    final UnicodeBlock TAGS;
    final UnicodeBlock VARIATION_SELECTORS_SUPPLEMENT;
    final UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_A;
    final UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_B;
    final UnicodeBlock HIGH_SURROGATES;
    final UnicodeBlock HIGH_PRIVATE_USE_SURROGATES;
    final UnicodeBlock LOW_SURROGATES;
    final UnicodeBlock ARABIC_SUPPLEMENT;
    final UnicodeBlock NKO;
    final UnicodeBlock SAMARITAN;
    final UnicodeBlock MANDAIC;
    final UnicodeBlock ETHIOPIC_SUPPLEMENT;
    final UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED;
    final UnicodeBlock NEW_TAI_LUE;
    final UnicodeBlock BUGINESE;
    final UnicodeBlock TAI_THAM;
    final UnicodeBlock BALINESE;
    final UnicodeBlock SUNDANESE;
    final UnicodeBlock BATAK;
    final UnicodeBlock LEPCHA;
    final UnicodeBlock OL_CHIKI;
    final UnicodeBlock VEDIC_EXTENSIONS;
    final UnicodeBlock PHONETIC_EXTENSIONS_SUPPLEMENT;
    final UnicodeBlock COMBINING_DIACRITICAL_MARKS_SUPPLEMENT;
    final UnicodeBlock GLAGOLITIC;
    final UnicodeBlock LATIN_EXTENDED_C;
    final UnicodeBlock COPTIC;
    final UnicodeBlock GEORGIAN_SUPPLEMENT;
    final UnicodeBlock TIFINAGH;
    final UnicodeBlock ETHIOPIC_EXTENDED;
    final UnicodeBlock CYRILLIC_EXTENDED_A;
    final UnicodeBlock SUPPLEMENTAL_PUNCTUATION;
    final UnicodeBlock CJK_STROKES;
    final UnicodeBlock LISU;
    final UnicodeBlock VAI;
    final UnicodeBlock CYRILLIC_EXTENDED_B;
    final UnicodeBlock BAMUM;
    final UnicodeBlock MODIFIER_TONE_LETTERS;
    final UnicodeBlock LATIN_EXTENDED_D;
    final UnicodeBlock SYLOTI_NAGRI;
    final UnicodeBlock COMMON_INDIC_NUMBER_FORMS;
    final UnicodeBlock PHAGS_PA;
    final UnicodeBlock SAURASHTRA;
    final UnicodeBlock DEVANAGARI_EXTENDED;
    final UnicodeBlock KAYAH_LI;
    final UnicodeBlock REJANG;
    final UnicodeBlock HANGUL_JAMO_EXTENDED_A;
    final UnicodeBlock JAVANESE;
    final UnicodeBlock CHAM;
    final UnicodeBlock MYANMAR_EXTENDED_A;
    final UnicodeBlock TAI_VIET;
    final UnicodeBlock ETHIOPIC_EXTENDED_A;
    final UnicodeBlock MEETEI_MAYEK;
    final UnicodeBlock HANGUL_JAMO_EXTENDED_B;
    final UnicodeBlock VERTICAL_FORMS;
    final UnicodeBlock ANCIENT_GREEK_NUMBERS;
    final UnicodeBlock ANCIENT_SYMBOLS;
    final UnicodeBlock PHAISTOS_DISC;
    final UnicodeBlock LYCIAN;
    final UnicodeBlock CARIAN;
    final UnicodeBlock OLD_PERSIAN;
    final UnicodeBlock IMPERIAL_ARAMAIC;
    final UnicodeBlock PHOENICIAN;
    final UnicodeBlock LYDIAN;
    final UnicodeBlock KHAROSHTHI;
    final UnicodeBlock OLD_SOUTH_ARABIAN;
    final UnicodeBlock AVESTAN;
    final UnicodeBlock INSCRIPTIONAL_PARTHIAN;
    final UnicodeBlock INSCRIPTIONAL_PAHLAVI;
    final UnicodeBlock OLD_TURKIC;
    final UnicodeBlock RUMI_NUMERAL_SYMBOLS;
    final UnicodeBlock BRAHMI;
    final UnicodeBlock KAITHI;
    final UnicodeBlock CUNEIFORM;
    final UnicodeBlock CUNEIFORM_NUMBERS_AND_PUNCTUATION;
    final UnicodeBlock EGYPTIAN_HIEROGLYPHS;
    final UnicodeBlock BAMUM_SUPPLEMENT;
    final UnicodeBlock KANA_SUPPLEMENT;
    final UnicodeBlock ANCIENT_GREEK_MUSICAL_NOTATION;
    final UnicodeBlock COUNTING_ROD_NUMERALS;
    final UnicodeBlock MAHJONG_TILES;
    final UnicodeBlock DOMINO_TILES;
    final UnicodeBlock PLAYING_CARDS;
    final UnicodeBlock ENCLOSED_ALPHANUMERIC_SUPPLEMENT;
    final UnicodeBlock ENCLOSED_IDEOGRAPHIC_SUPPLEMENT;
    final UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS;
    final UnicodeBlock EMOTICONS;
    final UnicodeBlock TRANSPORT_AND_MAP_SYMBOLS;
    final UnicodeBlock ALCHEMICAL_SYMBOLS;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D;
    static UnicodeBlock of(char arg0);
    static UnicodeBlock of(int arg0);
    static UnicodeBlock forName(String arg0);
}

@PolyFlowReceiver
class Character$Subset {
    protected Subset(String arg0);
    boolean equals(Object arg0);
    int hashCode();
    String toString();
}


@PolyFlowReceiver
interface CharSequence {
    int length();
    char charAt(int arg0);
    CharSequence subSequence(int arg0, int arg1);
    String toString();
}

class Class{
<U> Class<? extends U> asSubclass(Class<U> arg0);
		String getCanonicalName();
        Constructor<T> getConstructor(Class<?>[] parameterTypes) throws NoSuchMethodException,SecurityException;
        Field getDeclaredField(String name) throws NoSuchFieldException,SecurityException;
        String getSimpleName();
        int getModifiers();
        boolean isMemberClass();
        ClassLoader getClassLoader();
        static Class<?> forName(String arg0) throws ClassNotFoundException;
        Method getDeclaredMethod(String arg0, Class<?>[] arg1) throws NoSuchMethodException,SecurityException;
        T newInstance() throws InstantiationException,IllegalAccessException;
         String getName();
            boolean isInstance(Object arg0);
            static Class<?> forName(String arg0, boolean arg1, ClassLoader arg2) throws ClassNotFoundException;
}

@PolyFlowReceiver
class ClassLoader {
    protected ClassLoader(ClassLoader arg0);
    protected ClassLoader();
    Class<?> loadClass(String arg0) throws ClassNotFoundException;
    protected Class<?> loadClass(String arg0, boolean arg1) throws ClassNotFoundException;
    protected Object getClassLoadingLock(String arg0);
    protected Class<?> findClass(String arg0) throws ClassNotFoundException;
    protected Class<?> defineClass(byte[] arg0, int arg1, int arg2) throws ClassFormatError;
    protected Class<?> defineClass(String arg0, byte[] arg1, int arg2, int arg3) throws ClassFormatError;
    protected Class<?> defineClass(String arg0, byte[] arg1, int arg2, int arg3, ProtectionDomain arg4) throws ClassFormatError;
    protected Class<?> defineClass(String arg0, ByteBuffer arg1, ProtectionDomain arg2) throws ClassFormatError;
    protected void resolveClass(Class<?> arg0);
    protected Class<?> findSystemClass(String arg0) throws ClassNotFoundException;
    protected Class<?> findLoadedClass(String arg0);
    protected void setSigners(Class<?> arg0, Object[] arg1);
    URL getResource(String arg0);
    Enumeration<URL> getResources(String arg0) throws IOException;
    protected URL findResource(String arg0);
    protected Enumeration<URL> findResources(String arg0) throws IOException;
    protected static boolean registerAsParallelCapable();
    static URL getSystemResource(String arg0);
    static Enumeration<URL> getSystemResources(String arg0) throws IOException;
    InputStream getResourceAsStream(String arg0);
    static InputStream getSystemResourceAsStream(String arg0);
    ClassLoader getParent();
    static ClassLoader getSystemClassLoader();
    protected Package definePackage(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5, String arg6, URL arg7) throws IllegalArgumentException;
    protected Package getPackage(String arg0);
    protected Package[] getPackages();
    protected String findLibrary(String arg0);
    void setDefaultAssertionStatus(boolean arg0);
    void setPackageAssertionStatus(String arg0, boolean arg1);
    void setClassAssertionStatus(String arg0, boolean arg1);
    void clearAssertionStatus();
}

@PolyFlowReceiver
interface Comparable<T> {
    int compareTo(T arg0);
}

@PolyFlowReceiver
class Double extends Number implements Comparable<Double> {
//Added by pbsf
    final double POSITIVE_INFINITY;
    final double NEGATIVE_INFINITY;
    final double NaN;
    final double MAX_VALUE;
    final double MIN_NORMAL;
    final double MIN_VALUE;
    final int MAX_EXPONENT;
    final int MIN_EXPONENT;
    final int SIZE;
    final Class<Double> TYPE;
    static String toString(double arg0);
    static String toHexString(double arg0);
    static Double valueOf(String arg0) throws NumberFormatException;
    static Double valueOf(double arg0);
    static double parseDouble(String arg0) throws NumberFormatException;
    static boolean isNaN(double arg0);
    static boolean isInfinite(double arg0);
    Double(double arg0);
    Double(String arg0) throws NumberFormatException;
    boolean isNaN();
    boolean isInfinite();
    String toString();
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    int hashCode();
    boolean equals(Object arg0);
    static long doubleToLongBits(double arg0);
    static long doubleToRawLongBits(double arg0);
    static double longBitsToDouble(long arg0);
    int compareTo(Double arg0);
    static int compare(double arg0, double arg1);
}

@PolyFlowReceiver
class IllegalStateException extends RuntimeException {
//Added by pbsf
    IllegalStateException();
    IllegalStateException(String arg0);
    IllegalStateException(String arg0, Throwable arg1);
    IllegalStateException(Throwable arg0);
}

@PolyFlowReceiver
class Enum<E> implements Comparable<E>, Serializable {
    String name();
    int ordinal();
    protected Enum(String arg0, int arg1);
    String toString();
    boolean equals(Object arg0);
    int hashCode();
    protected Object clone() throws CloneNotSupportedException;
    int compareTo(E arg0);
    Class<E> getDeclaringClass();
    static <T> T valueOf(Class<T> arg0, String arg1);
    protected void finalize();
}
class Error{
            Error(String arg0);
}

class Exception{
        Exception(String message);
        Exception(Throwable arg0);
        Exception(String arg0, Throwable arg1);
        Exception();

}

@PolyFlowReceiver
class Float extends Number implements Comparable<Float> {
//Added by pbsf
    final float POSITIVE_INFINITY;
    final float NEGATIVE_INFINITY;
    final float NaN;
    final float MAX_VALUE;
    final float MIN_NORMAL;
    final float MIN_VALUE;
    final int MAX_EXPONENT;
    final int MIN_EXPONENT;
    final int SIZE;
    final Class<Float> TYPE;
    static String toString(float arg0);
    static String toHexString(float arg0);
    @PolyFlow
    static Float valueOf(String arg0) throws NumberFormatException;
    static Float valueOf(float arg0);
    static float parseFloat(String arg0) throws NumberFormatException;
    static boolean isNaN(float arg0);
    static boolean isInfinite(float arg0);
    Float(float arg0);
    Float(double arg0);
    Float(String arg0) throws NumberFormatException;
    boolean isNaN();
    boolean isInfinite();
    String toString();
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    int hashCode();
    boolean equals(Object arg0);
    static int floatToIntBits(float arg0);
    static int floatToRawIntBits(float arg0);
    static float intBitsToFloat(int arg0);
    int compareTo(Float arg0);
    static int compare(float arg0, float arg1);
}

class IllegalArgumentException{
        IllegalArgumentException();
        IllegalArgumentException(Throwable arg0);
        IllegalArgumentException(String arg0);
        IllegalArgumentException(String arg0, Throwable arg1);
}
class UnsupportedOperationException{
            UnsupportedOperationException(String arg0);
            UnsupportedOperationException();
}
class NumberFormatException{
            NumberFormatException(String arg0);
}

@PolyFlowReceiver
class Integer extends Number implements Comparable<Integer> {
//Added by smillst
    final @Source(FlowPermission.LITERAL) int MIN_VALUE;
    final @Source(FlowPermission.LITERAL) int MAX_VALUE;
    final @Source(FlowPermission.LITERAL) int SIZE;

    static String toString(int arg0, int arg1);
    static String toHexString(int arg0);
    static String toOctalString(int arg0);
    static String toBinaryString(int arg0);
    static String toString(int arg0);
    static int parseInt(String arg0, int arg1) throws NumberFormatException;
    static int parseInt(String arg0) throws NumberFormatException;
    static Integer valueOf(String arg0, int arg1) throws NumberFormatException;
    static Integer valueOf(String arg0) throws NumberFormatException;
    static Integer valueOf(int arg0);
    Integer(int arg0);
    Integer(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    static Integer getInteger(String arg0);
    static Integer getInteger(String arg0, int arg1);
    static Integer getInteger(String arg0, Integer arg1);
    static Integer decode(String arg0) throws NumberFormatException;
    int compareTo(Integer arg0);
    static int compare(int arg0, int arg1);
    static int highestOneBit(int arg0);
    static int lowestOneBit(int arg0);
    static int numberOfLeadingZeros(int arg0);
    static int numberOfTrailingZeros(int arg0);
    static int bitCount(int arg0);
    static int rotateLeft(int arg0, int arg1);
    static int rotateRight(int arg0, int arg1);
    static int reverse(int arg0);
    static int signum(int arg0);
    static int reverseBytes(int arg0);
}

@PolyFlowReceiver
interface Iterable<T> {
    Iterator<T> iterator();
}

@PolyFlowReceiver
class Long extends Number implements Comparable<Long> {
//Added by pbsf
    final long MIN_VALUE;
    final long MAX_VALUE;
    final Class<Long> TYPE;
    final int SIZE;
    static String toString(long arg0, int arg1);
    static String toHexString(long arg0);
    static String toOctalString(long arg0);
    static String toBinaryString(long arg0);
    static String toString(long arg0);
    static long parseLong(String arg0, int arg1) throws NumberFormatException;
    static long parseLong(String arg0) throws NumberFormatException;
    static Long valueOf(String arg0, int arg1) throws NumberFormatException;
    static Long valueOf(String arg0) throws NumberFormatException;
    static Long valueOf(long arg0);
    static Long decode(String arg0) throws NumberFormatException;
    Long(long arg0);
    Long(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    static Long getLong(String arg0);
    static Long getLong(String arg0, long arg1);
    static Long getLong(String arg0, Long arg1);
    int compareTo(Long arg0);
    static int compare(long arg0, long arg1);
    static long highestOneBit(long arg0);
    static long lowestOneBit(long arg0);
    static int numberOfLeadingZeros(long arg0);
    static int numberOfTrailingZeros(long arg0);
    static int bitCount(long arg0);
    static long rotateLeft(long arg0, int arg1);
    static long rotateRight(long arg0, int arg1);
    static long reverse(long arg0);
    static int signum(long arg0);
    static long reverseBytes(long arg0);
}

class Math {
//Added by smillst
    @PolyFlow
    static double abs(double a);
    @PolyFlow
    static float abs(float a);
    @PolyFlow
    static int abs(int a);
    @PolyFlow
    static long abs(long a);
    @PolyFlow
    static double acos(double a);
    @PolyFlow
    static double asin(double a);
    @PolyFlow
    static double atan(double a);
    @PolyFlow
    static double atan2(double y, double x);
    @PolyFlow
    static double cbrt(double a);
    @PolyFlow
    static double ceil(double a);
    @PolyFlow
    static double copySign(double magnitude, double sign);
    @PolyFlow
    static float copySign(float magnitude, float sign);
    @PolyFlow
    static double cos(double a);
    @PolyFlow
    static double cosh(double x);
    @PolyFlow
    static double exp(double a);
    @PolyFlow
    static double expm1(double x);
    @PolyFlow
    static double floor(double a);
    @PolyFlow
    static int getExponent(double d);
    @PolyFlow
    static int getExponent(float f);
    @PolyFlow
    static double hypot(double x, double y);
    @PolyFlow
    static double IEEEremainder(double f1, double f2);
    @PolyFlow
    static double log(double a);
    @PolyFlow
    static double log10(double a);
    @PolyFlow
    static double log1p(double x);
    @PolyFlow
    static double max(double a, double b);
    @PolyFlow
    static float max(float a, float b);
    @PolyFlow
    static int max(int a, int b);
    @PolyFlow
    static long max(long a, long b);
    @PolyFlow
    static double min(double a, double b);
    @PolyFlow
    static float min(float a, float b);
    @PolyFlow
    static int min(int a, int b);
    @PolyFlow
    static long min(long a, long b);
    @PolyFlow
    static double nextAfter(double start, double direction);
    @PolyFlow
    static float nextAfter(float start, double direction);
    @PolyFlow
    static double nextUp(double d);
    @PolyFlow
    static float nextUp(float f);
    @PolyFlow
    static double pow(double a, double b);
    @PolyFlow
    static double random();
    @PolyFlow
    static double rint(double a);
    @PolyFlow
    static long round(double a);
    @PolyFlow
    static int round(float a);
    @PolyFlow
    static double scalb(double d, int scaleFactor);
    @PolyFlow
    static float scalb(float f, int scaleFactor);
    @PolyFlow
    static double signum(double d);
    @PolyFlow
    static float signum(float f);
    @PolyFlow
    static double sin(double a);
    @PolyFlow
    static double sinh(double x);
    @PolyFlow
    static double sqrt(double a);
    @PolyFlow
    static double tan(double a);
    @PolyFlow
    static double tanh(double x);
    @PolyFlow
    static double toDegrees(double angrad);
    @PolyFlow
    static double toRadians(double angdeg);
    @PolyFlow
    static double ulp(double d);
    @PolyFlow
    static float ulp(float f);

}

@PolyFlowReceiver
class Number implements Serializable {
    Number();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    byte byteValue();
    short shortValue();
}

class Object {
//Added by smillst
    Object();
    Class<?> getClass();
    @PolyFlowReceiver
    int hashCode();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    protected Object clone() throws CloneNotSupportedException;
    @PolyFlowReceiver
    String toString();
    void notify();
    void notifyAll();
    void wait(long arg0) throws InterruptedException;
    void wait(long arg0, int arg1) throws InterruptedException;
    void wait() throws InterruptedException;
    protected void finalize() throws Throwable;
}

@PolyFlowReceiver
class Process {
    Process();
    OutputStream getOutputStream();
    InputStream getInputStream();
    InputStream getErrorStream();
    int waitFor() throws InterruptedException;
    int exitValue();
    void destroy();
}

class ProcessBuilder {
//Added by pbsf
    ProcessBuilder(@Sink(PROCESS_BUILDER) List< @Sink(PROCESS_BUILDER)String> arg0);
    ProcessBuilder( @Sink(PROCESS_BUILDER) String @Sink(PROCESS_BUILDER) [] arg0);
    ProcessBuilder command(@Sink(PROCESS_BUILDER) List< @Sink(PROCESS_BUILDER) String> arg0);
    ProcessBuilder command(@Sink(PROCESS_BUILDER) String @Sink(PROCESS_BUILDER) [] arg0);
    @Sink(PROCESS_BUILDER) List< @Sink(PROCESS_BUILDER) String> command();
    @Sink(PROCESS_BUILDER) Map<@Sink(PROCESS_BUILDER) String,@Sink(PROCESS_BUILDER) String> environment();
    @Sink(PROCESS_BUILDER) File directory();
    ProcessBuilder directory(@Sink(PROCESS_BUILDER) File arg0);
    ProcessBuilder redirectInput(@Sink(PROCESS_BUILDER) Redirect arg0);
    ProcessBuilder redirectOutput(@Sink(PROCESS_BUILDER) Redirect arg0);
    ProcessBuilder redirectError(@Sink(PROCESS_BUILDER) Redirect arg0);
    ProcessBuilder redirectInput(@Sink(PROCESS_BUILDER) File arg0);
    ProcessBuilder redirectOutput(@Sink(PROCESS_BUILDER) File arg0);
    ProcessBuilder redirectError(@Sink(PROCESS_BUILDER) File arg0);
    @Sink(PROCESS_BUILDER) Redirect redirectInput();
    @Sink(PROCESS_BUILDER) Redirect redirectOutput();
    @Sink(PROCESS_BUILDER) Redirect redirectError();
    ProcessBuilder inheritIO();
    boolean redirectErrorStream();
    ProcessBuilder redirectErrorStream(boolean arg0);
    @Source(PROCESS_BUILDER) Process start() throws IOException;
}

@PolyFlowReceiver
class ProcessBuilder$Redirect {
//Added by pbsf
    final Redirect PIPE;
    final Redirect INHERIT;
    Type type();
    File file();
    static Redirect from(File arg0);
    static Redirect to(File arg0);
    static Redirect appendTo(File arg0);
    boolean equals(Object arg0);
    int hashCode();
}

class Runnable{
        void run();
}

@PolyFlowReceiver
class Runtime {
    static Runtime getRuntime();
    void exit(int arg0);
    void addShutdownHook(Thread arg0);
    boolean removeShutdownHook(Thread arg0);
    void halt(int arg0);
    static void runFinalizersOnExit(boolean arg0);
    Process exec(String arg0) throws IOException;
    Process exec(String arg0, String[] arg1) throws IOException;
    Process exec(String arg0, String[] arg1, File arg2) throws IOException;
    Process exec(String[] arg0) throws IOException;
    Process exec(String[] arg0, String[] arg1) throws IOException;
    Process exec(String[] arg0, String[] arg1, File arg2) throws IOException;
    int availableProcessors();
    long freeMemory();
    long totalMemory();
    long maxMemory();
    void gc();
    void runFinalization();
    void traceInstructions(boolean arg0);
    void traceMethodCalls(boolean arg0);
    void load(String arg0);
    void loadLibrary(String arg0);
    InputStream getLocalizedInputStream(InputStream arg0);
    OutputStream getLocalizedOutputStream(OutputStream arg0);
}

class RuntimeException{
            RuntimeException(String arg0);
            RuntimeException(String arg0, Throwable arg1);
            RuntimeException(Throwable arg0);

}
class IndexOutOfBoundsException{
        IndexOutOfBoundsException();               
        IndexOutOfBoundsException(String arg0);

}
class NullPointerException{
            NullPointerException();
            NullPointerException(String arg0);

}

@PolyFlowReceiver
class Readable{
            int read(CharBuffer arg0) throws IOException;
}

@PolyFlowReceiver
class Short extends Number implements Comparable<Short> {
//Added by pbsf
    final short MIN_VALUE;
    final short MAX_VALUE;
    final Class<Short> TYPE;
    final int SIZE;
    static String toString(short arg0);
    static short parseShort(String arg0, int arg1) throws NumberFormatException;
    static short parseShort(String arg0) throws NumberFormatException;
    static Short valueOf(String arg0, int arg1) throws NumberFormatException;
    static Short valueOf(String arg0) throws NumberFormatException;
    static Short valueOf(short arg0);
    static Short decode(String arg0) throws NumberFormatException;
    Short(short arg0);
    Short(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    int compareTo(Short arg0);
    static int compare(short arg0, short arg1);
    static short reverseBytes(short arg0);
}

@PolyFlowReceiver
class StringBuilder extends AbstractStringBuilder implements Serializable, CharSequence {
//Added by smillst
    @PolyFlow
    StringBuilder();
    @PolyFlow
    StringBuilder(int arg0);
    @PolyFlow
    StringBuilder(String arg0);
    @PolyFlow
    StringBuilder(CharSequence arg0);
    
    StringBuilder append(Object arg0);
    StringBuilder append(String arg0);
    StringBuilder append(StringBuffer arg0);
    StringBuilder append(CharSequence arg0);
    StringBuilder append(CharSequence arg0, int arg1, int arg2);
    StringBuilder append(char[] arg0);
    StringBuilder append(char[] arg0, int arg1, int arg2);
    StringBuilder append(boolean arg0);
    StringBuilder append(char arg0);
    StringBuilder append(int arg0);
    StringBuilder append(long arg0);
    StringBuilder append(float arg0);
    StringBuilder append(double arg0);
    StringBuilder appendCodePoint(int arg0);
    StringBuilder delete(int arg0, int arg1);
    StringBuilder deleteCharAt(int arg0);
    StringBuilder replace(int arg0, int arg1, String arg2);
    StringBuilder insert(int arg0, char[] arg1, int arg2, int arg3);
    StringBuilder insert(int arg0, Object arg1);
    StringBuilder insert(int arg0, String arg1);
    StringBuilder insert(int arg0, char[] arg1);
    StringBuilder insert(int arg0, CharSequence arg1);
    StringBuilder insert(int arg0, CharSequence arg1, int arg2, int arg3);
    StringBuilder insert(int arg0, boolean arg1);
    StringBuilder insert(int arg0, char arg1);
    StringBuilder insert(int arg0, int arg1);
    StringBuilder insert(int arg0, long arg1);
    StringBuilder insert(int arg0, float arg1);
    StringBuilder insert(int arg0, double arg1);
    int indexOf(String arg0);
    int indexOf(String arg0, int arg1);
    int lastIndexOf(String arg0);
    int lastIndexOf(String arg0, int arg1);
    StringBuilder reverse();
    String toString();
}


/*[equals, length, valueOf, trim, substring, charAt, indexOf, contains, replace, startsWith, format, split, 
   toUpperCase, <init>, hashCode, toCharArray, getChars, replaceAll, getBytes, endsWith, equalsIgnoreCase, 
   lastIndexOf, toLowerCase, compareTo, toString, intern, isEmpty, contentEquals, replaceFirst, concat, compareToIgnoreCase, 
   matches, copyValueOf]*/
   
   class String implements Serializable, Comparable<String>, CharSequence {
   //Added by SOM
   //TODO: Should indexs into the char[] be PolyFlow or just LITERAL?
    final Comparator<String> CASE_INSENSITIVE_ORDER;
    @PolyFlow
    String();
    @PolyFlow
    String(String arg0);
    @PolyFlow
    String(char[] arg0);
    @PolyFlow
    String(char[] arg0, int arg1, int arg2);
    @PolyFlow
    String(int[] arg0, int arg1, int arg2);
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2, int arg3);
    @PolyFlow
    String(byte[] arg0, int arg1);
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2, String arg3) throws UnsupportedEncodingException;
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2, Charset arg3);
    @PolyFlow
    String(byte[] arg0, String arg1) throws UnsupportedEncodingException;
    @PolyFlow
    String(byte[] arg0, Charset arg1);
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2);
    @PolyFlow
    String(byte[] arg0);
    @PolyFlow
    String(StringBuffer arg0);
    @PolyFlow
    String(StringBuilder arg0);
    
    int length();
    boolean isEmpty();
    @PolyFlowReceiver
    char charAt(int arg0);
    @PolyFlowReceiver
    int codePointAt(int arg0);
    @PolyFlowReceiver
    int codePointBefore(int arg0);
    @PolyFlowReceiver
    int codePointCount(int arg0, int arg1);
    @PolyFlowReceiver
    int offsetByCodePoints(int arg0, int arg1);
    @PolyFlowReceiver
    void getChars(int arg0, int arg1, char[] arg2, int arg3);
    @PolyFlowReceiver
    void getBytes(int arg0, int arg1, byte[] arg2, int arg3);
    @PolyFlowReceiver
    byte[] getBytes(String arg0) throws UnsupportedEncodingException;
    @PolyFlowReceiver
    byte[] getBytes(Charset arg0);
    @PolyFlowReceiver
    byte[] getBytes();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    boolean contentEquals(StringBuffer arg0);
    @PolyFlowReceiver
    boolean contentEquals(CharSequence arg0);
    @PolyFlowReceiver
    boolean equalsIgnoreCase(String arg0);
    @PolyFlowReceiver
    int compareTo(String arg0);
    @PolyFlowReceiver
    int compareToIgnoreCase(String arg0);
    @PolyFlowReceiver
    boolean regionMatches(int arg0, String arg1, int arg2, int arg3);
    @PolyFlowReceiver
    boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4);
    @PolyFlowReceiver
    boolean startsWith(String arg0, int arg1);
    @PolyFlowReceiver
    boolean startsWith(String arg0);
    @PolyFlowReceiver
    boolean endsWith(String arg0);
    @PolyFlowReceiver
    int hashCode();
    @PolyFlowReceiver
    int indexOf(int arg0);
    @PolyFlowReceiver
    int indexOf(int arg0, int arg1);
    @PolyFlowReceiver
    int lastIndexOf(int arg0);
    @PolyFlowReceiver
    int lastIndexOf(int arg0, int arg1);
    @PolyFlowReceiver
    int indexOf(String arg0);
    @PolyFlowReceiver
    int indexOf(String arg0, int arg1);
    @PolyFlowReceiver
    int lastIndexOf(String arg0);
    @PolyFlowReceiver
    int lastIndexOf(String arg0, int arg1);
    @PolyFlowReceiver
    String substring(int arg0);
    @PolyFlowReceiver
    String substring(int arg0, int arg1);
    @PolyFlowReceiver
    CharSequence subSequence(int arg0, int arg1);
    @PolyFlowReceiver
    String concat(String arg0);
    @PolyFlowReceiver
    String replace(char arg0, char arg1);
    @PolyFlowReceiver
    boolean matches(String arg0);
    @PolyFlowReceiver
    boolean contains(CharSequence arg0);
    @PolyFlowReceiver
    String replaceFirst(String arg0, String arg1);
    @PolyFlowReceiver
    String replaceAll(String arg0, String arg1);
    @PolyFlowReceiver
    String replace(CharSequence arg0, CharSequence arg1);
    @PolyFlowReceiver
    String[] split(String arg0, int arg1);
    @PolyFlowReceiver
    String[] split(String arg0);
    String toLowerCase(Locale arg0);
    String toLowerCase();
    String toUpperCase(Locale arg0);
    String toUpperCase();
    String trim();
    @PolyFlowReceiver
    String toString();
    @PolyFlowReceiver
    char[] toCharArray();
    @PolyFlow
    static String format(String arg0, @PolySource @PolySink Object[] arg1);
    @PolyFlow
    static String format(Locale arg0, String arg1, @PolySource @PolySink Object[] arg2);
    @PolyFlow
    static String valueOf(Object arg0);
    @PolyFlow
    static String valueOf(char[] arg0);
    @PolyFlow
    static String valueOf(char[] arg0, int arg1, int arg2);
    @PolyFlow
    static String copyValueOf(char[] arg0, int arg1, int arg2);
    @PolyFlow
    static String copyValueOf(char[] arg0);
    @PolyFlow
    static String valueOf(boolean arg0);
    @PolyFlow
    static String valueOf(char arg0);
    @PolyFlow
    static String valueOf(int arg0);
    @PolyFlow
    static String valueOf(long arg0);
    @PolyFlow
    static String valueOf(float arg0);
    @PolyFlow
    static String valueOf(double arg0);
    @PolyFlowReceiver
    String intern();
}

// [append, toString, <init>, length, insert, indexOf, substring, setCharAt, setLength]
class StringBuffer implements Serializable, CharSequence {
    // DAM
   
    StringBuffer();

    @PolyFlow
    StringBuffer(CharSequence seq);

    @PolyFlow
    StringBuffer(int capacity);

    @PolyFlow
    StringBuffer(String str);

    @PolyFlowReceiver
    StringBuffer    append(boolean b);
    @PolyFlowReceiver
    StringBuffer    append(char c);
    @PolyFlowReceiver
    StringBuffer    append(char[] str);
    @PolyFlowReceiver
    StringBuffer    append(char[] str, int offset, int len);
    @PolyFlowReceiver
    StringBuffer    append(CharSequence s);
    @PolyFlowReceiver
    StringBuffer    append(CharSequence s, int start, int end);
    @PolyFlowReceiver
    StringBuffer    append(double d);
    @PolyFlowReceiver
    StringBuffer    append(float f);
    @PolyFlowReceiver
    StringBuffer    append(int i);
    @PolyFlowReceiver
    StringBuffer    append(long lng);
    @PolyFlowReceiver
    StringBuffer    append(Object obj);
    @PolyFlowReceiver
    StringBuffer    append(String str);
    @PolyFlowReceiver
    StringBuffer    append(StringBuffer sb);
    @PolyFlowReceiver
    StringBuffer    appendCodePoint(int codePoint);
    @PolyFlowReceiver
    int capacity();
    @PolyFlowReceiver
    char    charAt(int index);
    @PolyFlowReceiver
    int codePointAt(int index);
    @PolyFlowReceiver
    int codePointBefore(int index);
    @PolyFlowReceiver
    int codePointCount(int beginIndex, int endIndex);
    @PolyFlowReceiver
    StringBuffer    delete(int start, int end);
    @PolyFlowReceiver
    StringBuffer    deleteCharAt(int index);
    // TODO: Need polyflow on receiver and params with no return type.
    void    ensureCapacity(int minimumCapacity);
    // TODO: Need polyflow on receiver and params with no return type.
    // Especially here since the data is being set in an out param.
    void    getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin);
    @PolyFlowReceiver
    int indexOf(String str);
    @PolyFlowReceiver
    int indexOf(String str, int fromIndex);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, boolean b);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, char c);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, char[] str);
    @PolyFlowReceiver
    StringBuffer    insert(int index, char[] str, int offset, int len);
    @PolyFlowReceiver
    StringBuffer    insert(int dstOffset, CharSequence s);
    @PolyFlowReceiver
    StringBuffer    insert(int dstOffset, CharSequence s, int start, int end);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, double d);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, float f);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, int i);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, long l);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, Object obj);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, String str);
    @PolyFlowReceiver
    int lastIndexOf(String str);
    @PolyFlowReceiver
    int lastIndexOf(String str, int fromIndex);
    @PolyFlowReceiver
    int length();
    @PolyFlowReceiver
    int offsetByCodePoints(int index, int codePointOffset);
    @PolyFlowReceiver
    StringBuffer    replace(int start, int end, String str);
    @PolyFlowReceiver
    StringBuffer    reverse();
    // TODO: Need polyflow on receiver and params with no return type.
    void    setCharAt(int index, char ch);
    // TODO: Need polyflow on receiver and params with no return type.
    void    setLength(int newLength);
    @PolyFlowReceiver
    CharSequence    subSequence(int start, int end);
    @PolyFlowReceiver
    String  substring(int start);
    @PolyFlowReceiver
    String  substring(int start, int end);
    @PolyFlowReceiver
    String  toString();
    void    trimToSize();
}


class System {
//SOM: Android it writes in, out, err, either to /dev/null or the log 
    final @Source(READ_LOGS) InputStream in;
    final @Sink(WRITE_LOGS) PrintStream out;
    final @Sink(WRITE_LOGS) PrintStream err;
    static void setIn(@Source(WRITE_LOGS) InputStream arg0);
    static void setOut(@Sink(WRITE_LOGS) PrintStream arg0);
    static void setErr(@Sink(WRITE_LOGS) PrintStream arg0);
    
    static SecurityManager getSecurityManager();
    static @Source(READ_TIME) long currentTimeMillis();
    static @Source(READ_TIME) long nanoTime();
    
    static void arraycopy(@PolySource @PolySink Object src, int srcPos, @PolySource @PolySink Object dest, int destPos, int length) ;
    @PolyFlow
    static int identityHashCode(Object arg0);
    static @Source(SYSTEM_PROPERTIES) Properties getProperties();
    static String lineSeparator();
    static void setProperties(@Sink(SYSTEM_PROPERTIES) Properties arg0);
    static @Source(SYSTEM_PROPERTIES) String getProperty(@Sink(SYSTEM_PROPERTIES) String arg0);
    static @Source(SYSTEM_PROPERTIES) String getProperty(@Sink(SYSTEM_PROPERTIES) String arg0, String arg1);
    static @Source(SYSTEM_PROPERTIES) String setProperty(@Sink(SYSTEM_PROPERTIES) String arg0, String arg1);
    static @Source(SYSTEM_PROPERTIES) String clearProperty(@Sink(SYSTEM_PROPERTIES) String arg0);

    static void exit(int arg0);

    static @Source(SYSTEM_PROPERTIES) String mapLibraryName(String arg0);
    
    //[ getSecurityManager, loadLibrary]
}

@PolyFlowReceiver
class Thread implements Runnable {
    final @Source(FlowPermission.LITERAL) int MIN_PRIORITY;
    final @Source(FlowPermission.LITERAL) int NORM_PRIORITY;
    final @Source(FlowPermission.LITERAL) int MAX_PRIORITY;
    static Thread currentThread();
    static void yield();
    static void sleep(long arg0) throws InterruptedException;
    static void sleep(long arg0, int arg1) throws InterruptedException;
    protected Object clone() throws CloneNotSupportedException;
    Thread();
    Thread(Runnable arg0);
    Thread(ThreadGroup arg0, Runnable arg1);
    Thread(String arg0);
    Thread(ThreadGroup arg0, String arg1);
    Thread(Runnable arg0, String arg1);
    Thread(ThreadGroup arg0, Runnable arg1, String arg2);
    Thread(ThreadGroup arg0, Runnable arg1, String arg2, long arg3);
    void start();
    void run();
    void stop();
    void stop(Throwable arg0);
    void interrupt();
    static boolean interrupted();
    boolean isInterrupted();
    void destroy();
    boolean isAlive();
    void suspend();
    void resume();
    void setPriority(int arg0);
    int getPriority();
    void setName(String arg0);
    String getName();
    ThreadGroup getThreadGroup();
    static int activeCount();
    static int enumerate(Thread[] arg0);
    int countStackFrames();
    void join(long arg0) throws InterruptedException;
    void join(long arg0, int arg1) throws InterruptedException;
    void join() throws InterruptedException;
    static void dumpStack();
    void setDaemon(boolean arg0);
    boolean isDaemon();
    void checkAccess();
    String toString();
    ClassLoader getContextClassLoader();
    void setContextClassLoader(ClassLoader arg0);
    static boolean holdsLock(Object arg0);
    StackTraceElement[] getStackTrace();
    static Map<Thread,StackTraceElement[]> getAllStackTraces();
    long getId();
    State getState();
    static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler arg0);
    static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler();
    UncaughtExceptionHandler getUncaughtExceptionHandler();
    void setUncaughtExceptionHandler(UncaughtExceptionHandler arg0);
}

@PolyFlowReceiver
interface Thread$UncaughtExceptionHandler {
    void uncaughtException(Thread arg0, Throwable arg1);
}

@PolyFlowReceiver
class ThreadLocal<T> {
//Added by pbsf
    protected T initialValue();
    ThreadLocal();
    T get();
    void set(T arg0);
    void remove();
}


class Throwable implements Serializable {
//SOM
    Throwable();
    Throwable(String arg0);
    Throwable(String arg0, Throwable arg1);
    Throwable(Throwable arg0);
    protected Throwable(String arg0, Throwable arg1, boolean arg2, boolean arg3);
    String getMessage();
    String getLocalizedMessage();
    Throwable getCause();
    Throwable initCause(Throwable arg0);
    String toString();
    void printStackTrace();
    void printStackTrace(PrintStream arg0);
    void printStackTrace(PrintWriter arg0);
    Throwable fillInStackTrace();
    StackTraceElement[] getStackTrace();
    void setStackTrace(StackTraceElement[] arg0);
    void addSuppressed(Throwable arg0);
    Throwable[] getSuppressed();
}

package java.lang.ref;

@PolyFlowReceiver
class ReferenceQueue<T> {
//Added by pbsf
    ReferenceQueue();
    Reference<? extends T> poll();
    Reference<? extends T> remove(long arg0) throws IllegalArgumentException,InterruptedException;
    Reference<? extends T> remove() throws InterruptedException;
}

@PolyFlowReceiver
class SoftReference<T> extends Reference<T> {
//Added by pbsf
    SoftReference(T arg0);
    SoftReference(T arg0, ReferenceQueue<? super T> arg1);
    T get();
}


@PolyFlowReceiver
class WeakReference<T> extends Reference<T> {
//Added by pbsf
    WeakReference(T arg0);
    WeakReference(T arg0, ReferenceQueue<? super T> arg1);
}


package java.lang.reflect;
class AccessibleObject{
        void setAccessible(boolean arg0) throws SecurityException;
}
@PolyFlowReceiver
class Array {
//Added by pbsf
    static Object newInstance(Class<?> arg0, int arg1) throws NegativeArraySizeException;
    static Object newInstance(Class<?> arg0, int[] arg1) throws IllegalArgumentException,NegativeArraySizeException;
    static int getLength(Object arg0) throws IllegalArgumentException;
    static Object get(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static boolean getBoolean(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static byte getByte(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static char getChar(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static short getShort(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static int getInt(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static long getLong(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static float getFloat(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static double getDouble(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void set(Object arg0, int arg1, Object arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setBoolean(Object arg0, int arg1, boolean arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setByte(Object arg0, int arg1, byte arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setChar(Object arg0, int arg1, char arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setShort(Object arg0, int arg1, short arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setInt(Object arg0, int arg1, int arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setLong(Object arg0, int arg1, long arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setFloat(Object arg0, int arg1, float arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setDouble(Object arg0, int arg1, double arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
}

@PolyFlowReceiver
class Constructor<T> {
//Added by pbsf
    Class<T> getDeclaringClass();
    String getName();
    int getModifiers();
    TypeVariable<Constructor<T>>[] getTypeParameters();
    Class<?>[] getParameterTypes();
    Type[] getGenericParameterTypes();
    Class<?>[] getExceptionTypes();
    Type[] getGenericExceptionTypes();
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    String toGenericString();
    T newInstance(Object[] arg0) throws InstantiationException,IllegalAccessException,IllegalArgumentException,InvocationTargetException;
    boolean isVarArgs();
    boolean isSynthetic();
    <T> T getAnnotation(Class<T> arg0);
    Annotation[] getDeclaredAnnotations();
    Annotation[][] getParameterAnnotations();
}

@PolyFlowReceiver
class Field extends AccessibleObject implements Member {
//Added by pbsf
    Class<?> getDeclaringClass();
    String getName();
    int getModifiers();
    boolean isEnumConstant();
    boolean isSynthetic();
    Class<?> getType();
    Type getGenericType();
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    String toGenericString();
    Object get(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    boolean getBoolean(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    byte getByte(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    char getChar(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    short getShort(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    int getInt(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    long getLong(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    float getFloat(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    double getDouble(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    void set(Object arg0, Object arg1) throws IllegalArgumentException,IllegalAccessException;
    void setBoolean(Object arg0, boolean arg1) throws IllegalArgumentException,IllegalAccessException;
    void setByte(Object arg0, byte arg1) throws IllegalArgumentException,IllegalAccessException;
    void setChar(Object arg0, char arg1) throws IllegalArgumentException,IllegalAccessException;
    void setShort(Object arg0, short arg1) throws IllegalArgumentException,IllegalAccessException;
    void setInt(Object arg0, int arg1) throws IllegalArgumentException,IllegalAccessException;
    void setLong(Object arg0, long arg1) throws IllegalArgumentException,IllegalAccessException;
    void setFloat(Object arg0, float arg1) throws IllegalArgumentException,IllegalAccessException;
    void setDouble(Object arg0, double arg1) throws IllegalArgumentException,IllegalAccessException;
    <T> T getAnnotation(Class<T> arg0);
    Annotation[] getDeclaredAnnotations();
}

@PolyFlowReceiver
interface GenericArrayType extends Type {
    Type getGenericComponentType();
}
class InvocationTargetException{
            Throwable getCause();
}

@PolyFlowReceiver
class Method {
//Added by pbsf
    Class<?> getDeclaringClass();
    String getName();
    int getModifiers();
    TypeVariable<Method>[] getTypeParameters();
    Class<?> getReturnType();
    Type getGenericReturnType();
    Class<?>[] getParameterTypes();
    Type[] getGenericParameterTypes();
    Class<?>[] getExceptionTypes();
    Type[] getGenericExceptionTypes();
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    String toGenericString();
    @Source(FlowPermission.REFLECTION) Object invoke(@Sink(REFLECTION) Object arg0, @Sink(REFLECTION) Object @Sink(REFLECTION) [] arg1) throws IllegalAccessException,IllegalArgumentException,InvocationTargetException;
    boolean isBridge();
    boolean isVarArgs();
    boolean isSynthetic();
    Object getDefaultValue();
    <T> T getAnnotation(Class<T> arg0);
    Annotation[] getDeclaredAnnotations();
    Annotation[][] getParameterAnnotations();
}

@PolyFlowReceiver
class Modifier {
    final @Source(FlowPermission.LITERAL) int PUBLIC;
    final @Source(FlowPermission.LITERAL) int PRIVATE;
    final @Source(FlowPermission.LITERAL) int PROTECTED;
    final @Source(FlowPermission.LITERAL) int STATIC;
    final @Source(FlowPermission.LITERAL) int FINAL;
    final @Source(FlowPermission.LITERAL) int SYNCHRONIZED;
    final @Source(FlowPermission.LITERAL) int VOLATILE;
    final @Source(FlowPermission.LITERAL) int TRANSIENT;
    final @Source(FlowPermission.LITERAL) int NATIVE;
    final @Source(FlowPermission.LITERAL) int INTERFACE;
    final @Source(FlowPermission.LITERAL) int ABSTRACT;
    final @Source(FlowPermission.LITERAL) int STRICT;
    Modifier();
    static boolean isPublic(int arg0);
    static boolean isPrivate(int arg0);
    static boolean isProtected(int arg0);
    static boolean isStatic(int arg0);
    static boolean isFinal(int arg0);
    static boolean isSynchronized(int arg0);
    static boolean isVolatile(int arg0);
    static boolean isTransient(int arg0);
    static boolean isNative(int arg0);
    static boolean isInterface(int arg0);
    static boolean isAbstract(int arg0);
    static boolean isStrict(int arg0);
    static String toString(int arg0);
    static int classModifiers();
    static int interfaceModifiers();
    static int constructorModifiers();
    static int methodModifiers();
    static int fieldModifiers();
}

