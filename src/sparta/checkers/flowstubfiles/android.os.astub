
package android.os;

class AsyncTask {
    @Source(FlowPermission.ANY) Result doInBackground(@Source(FlowPermission.ANY) Params... params);
        protected void onCancelled();
        AsyncTask<Params,Progress,Result> execute(@Source(FlowPermission.ANY) Params[] params);
        protected void onProgressUpdate(@Source(FlowPermission.ANY) Progress[] values);
        boolean cancel(boolean mayInterruptIfRunning);
        protected void publishProgress(@Source(FlowPermission.ANY) Progress[] values);
        Status getStatus();
        protected void onPostExecute(@Source(FlowPermission.ANY) Result result);
        protected void onPreExecute();
        AsyncTask();
}

class Environment {
    static @Source(FlowPermission.FILESYSTEM) File 
    getExternalStoragePublicDirectory(@Sink(FlowPermission.FILESYSTEM) String type);
	static @Source(FlowPermission.FILESYSTEM) File getExternalStorageDirectory() ;

    @Source(FlowPermission.READ_EXTERNAL_STORAGE) static String getExternalStorageState();
                static @Source(FILESYSTEM) File getDataDirectory();

}

class IInterface{
    IBinder asBinder();
}

class IBinder {
    //Added by Carl Hartung
    abstract boolean transact(int code, Parcel data, Parcel reply, int flags);
    //Perform a generic operation with the object.
    
    abstract IInterface queryLocalInterface(String descriptor);
    //Attempt to retrieve a local implementation of an interface for this Binder object.
    
    abstract String getInterfaceDescriptor();
    //Get the canonical name of the interface supported by this binder.
     
    //UNUSED and UNANNOTATED 
    // abstract void dump(FileDescriptor fd, String[] args);
    // abstract void dumpAsync(FileDescriptor fd, String[] args);
    // abstract boolean isBinderAlive();
    // abstract void linkToDeath(IBinder.DeathRecipient recipient, int flags);
    // abstract boolean pingBinder();
    // abstract boolean unlinkToDeath(IBinder.DeathRecipient recipient, int flags);
    }
class Binder{
            protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException;
            void attachInterface(IInterface owner, String descriptor);
            Binder();
}
    
class Bundle {
  void clear();
//Removes all elements from the mapping of this Bundle.

Object clone();
//Clones the current Bundle.

boolean containsKey(String key);
//Returns true if the given key is contained in the mapping of this Bundle.

int describeContents();
//Report the nature of this Parcelable's contents

Object get(String key);
//Returns the entry with the given key as an object.

boolean getBoolean(String key);
//Returns the value associated with the given key, or false if no mapping of the desired type exists for the given key.

boolean getBoolean(String key, boolean defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

boolean[] getBooleanArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

Bundle getBundle(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

byte getByte(String key);
//Returns the value associated with the given key, or (byte); 0 if no mapping of the desired type exists for the given key.

Byte getByte(String key, byte defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

byte[] getByteArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

char getChar(String key);
//Returns the value associated with the given key, or (char); 0 if no mapping of the desired type exists for the given key.

char getChar(String key, char defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

char[] getCharArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

CharSequence getCharSequence(String key, CharSequence defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

CharSequence getCharSequence(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

CharSequence[] getCharSequenceArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ArrayList<CharSequence> getCharSequenceArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ClassLoader getClassLoader();
//Return the ClassLoader currently associated with this Bundle.

double getDouble(String key);
//Returns the value associated with the given key, or 0.0 if no mapping of the desired type exists for the given key.

double getDouble(String key, double defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

double[] getDoubleArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

float getFloat(String key);
//Returns the value associated with the given key, or 0.0f if no mapping of the desired type exists for the given key.

float getFloat(String key, float defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

float[] getFloatArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

int getInt(String key, int defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

int getInt(String key);
//Returns the value associated with the given key, or 0 if no mapping of the desired type exists for the given key.

int[] getIntArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ArrayList<Integer> getIntegerArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

long getLong(String key);
//Returns the value associated with the given key, or 0L if no mapping of the desired type exists for the given key.

long getLong(String key, long defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

long[] getLongArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

<T extends Parcelable> T getParcelable(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

Parcelable[] getParcelableArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

<T extends Parcelable> ArrayList<T> getParcelableArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

Serializable getSerializable(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

short getShort(String key);
//Returns the value associated with the given key, or (short); 0 if no mapping of the desired type exists for the given key.

short getShort(String key, short defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

short[] getShortArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

<T extends Parcelable> SparseArray<T> getSparseParcelableArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

String getString(String key, String defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

String getString(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

String[] getStringArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ArrayList<String> getStringArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

boolean hasFileDescriptors();
//Reports whether the bundle contains any parcelled file descriptors.

boolean isEmpty();
//Returns true if the mapping of this Bundle is empty, false otherwise.

Set<String> keySet();
//Returns a Set containing the Strings used as keys in this Bundle.

void putAll(Bundle map);
//Inserts all mappings from the given Bundle into this Bundle.

void putBoolean(String key, boolean value);
//Inserts a Boolean value into the mapping of this Bundle, replacing any existing value for the given key.

void putBooleanArray(String key, boolean[] value);
//Inserts a boolean array value into the mapping of this Bundle, replacing any existing value for the given key.

void putBundle(String key, Bundle value);
//Inserts a Bundle value into the mapping of this Bundle, replacing any existing value for the given key.

void putByte(String key, byte value);
//Inserts a byte value into the mapping of this Bundle, replacing any existing value for the given key.

void putByteArray(String key, byte[] value);
//Inserts a byte array value into the mapping of this Bundle, replacing any existing value for the given key.

void putChar(String key, char value);
//Inserts a char value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharArray(String key, char[] value);
//Inserts a char array value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharSequence(String key, CharSequence value);
//Inserts a CharSequence value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharSequenceArray(String key, CharSequence[] value);
//Inserts a CharSequence array value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharSequenceArrayList(String key, ArrayList<CharSequence> value);
//Inserts an ArrayList value into the mapping of this Bundle, replacing any existing value for the given key.

void putDouble(String key, double value);
//Inserts a double value into the mapping of this Bundle, replacing any existing value for the given key.

void putDoubleArray(String key, double[] value);
//Inserts a double array value into the mapping of this Bundle, replacing any existing value for the given key.

void putFloat(String key, float value);
//Inserts a float value into the mapping of this Bundle, replacing any existing value for the given key.

void putFloatArray(String key, float[] value);
//Inserts a float array value into the mapping of this Bundle, replacing any existing value for the given key.

void putInt(String key, int value);
//Inserts an int value into the mapping of this Bundle, replacing any existing value for the given key.

void putIntArray(String key, int[] value);
//Inserts an int array value into the mapping of this Bundle, replacing any existing value for the given key.

void putIntegerArrayList(String key, ArrayList<Integer> value);
//Inserts an ArrayList value into the mapping of this Bundle, replacing any existing value for the given key.

void putLong(String key, long value);
//Inserts a long value into the mapping of this Bundle, replacing any existing value for the given key.

void putLongArray(String key, long[] value);
//Inserts a long array value into the mapping of this Bundle, replacing any existing value for the given key.

void putParcelable(String key, Parcelable value);
//Inserts a Parcelable value into the mapping of this Bundle, replacing any existing value for the given key.

void putParcelableArray(String key, Parcelable[] value);
//Inserts an array of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.

void putParcelableArrayList(String key, ArrayList<? extends Parcelable> value);
//Inserts a List of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.

void putSerializable(String key, Serializable value);
//Inserts a Serializable value into the mapping of this Bundle, replacing any existing value for the given key.

void putShort(String key, short value);
//Inserts a short value into the mapping of this Bundle, replacing any existing value for the given key.

void putShortArray(String key, short[] value);
//Inserts a short array value into the mapping of this Bundle, replacing any existing value for the given key.

void putSparseParcelableArray(String key, SparseArray<? extends Parcelable> value);
//Inserts a SparceArray of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.

void putString(String key, String value);
//Inserts a String value into the mapping of this Bundle, replacing any existing value for the given key.

void putStringArray(String key, String[] value);
//Inserts a String array value into the mapping of this Bundle, replacing any existing value for the given key.

void putStringArrayList(String key, ArrayList<String> value);
//Inserts an ArrayList value into the mapping of this Bundle, replacing any existing value for the given key.

void readFromParcel(Parcel parcel);
//Reads the Parcel contents into this Bundle, typically in order for it to be passed through an IBinder connection.

void remove(String key);
//Removes any entry with the given key from the mapping of this Bundle.

void setClassLoader(ClassLoader loader);
//Changes the ClassLoader this Bundle uses when instantiating objects.

int size();
//Returns the number of mappings contained in this Bundle.

synchronized String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel parcel, int flags);
//Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
}

class Message{
            static Message obtain(Handler h, int what);
}

class Looper{
            static Looper myLooper();
            static void prepare();
}


class FileObserver{
            FileObserver(String path, int mask);
            void onEvent(int arg0, String arg1);
            void startWatching();
}

class Handler {
       boolean sendEmptyMessageAtTime(int what, long uptimeMillis);
    Handler(Looper looper);
final Looper getLooper();
void handleMessage(Message msg);
//Subclasses must implement this to receive messages .

final boolean hasMessages(int what, Object object);
//Check if there are any pending posts of messages with code 'what' and whose obj is 'object' in the message queue .

final boolean hasMessages(int what);
//Check if there are any pending posts of messages with code 'what' in the message queue .

final Message obtainMessage(int what, int arg1, int arg2);
//Same as obtainMessage();, except that it also sets the what, arg1 and arg2 members of the returned Message .

final Message obtainMessage();
//Returns a new Message from the global message pool .

final Message obtainMessage(int what, int arg1, int arg2, Object obj);
//Same as obtainMessage();, except that it also sets the what, obj, arg1,and arg2 values on the returned Message .

final Message obtainMessage(int what);
//Same as obtainMessage();, except that it also sets the what member of the returned Message .

final Message obtainMessage(int what, Object obj);
//Same as obtainMessage();, except that it also sets the what and obj members of the returned Message .

final boolean post(Runnable r);
//Causes the Runnable r to be added to the message queue .

final boolean postAtTime(Runnable r, Object token, long uptimeMillis);
//Causes the Runnable r to be added to the message queue, to be run at a specific time given by uptimeMillis .

final boolean postAtTime(Runnable r, long uptimeMillis);
//Causes the Runnable r to be added to the message queue, to be run at a specific time given by uptimeMillis .

final boolean postDelayed(Runnable r, long delayMillis);
//Causes the Runnable r to be added to the message queue, to be run after the specified amount of time elapses .

final void removeCallbacks(Runnable r);
//Remove any pending posts of Runnable r that are in the message queue .

final void removeCallbacks(Runnable r, Object token);
//Remove any pending posts of Runnable r with Object token that are in the message queue .

final void removeMessages(int what);
//Remove any pending posts of messages with code 'what' that are in the message queue .

final void removeMessages(int what, Object object);
//Remove any pending posts of messages with code 'what' and whose obj is 'object' that are in the message queue .

final boolean sendEmptyMessage(int what);
//Sends a Message containing only the what value .

final boolean sendEmptyMessageDelayed(int what, long delayMillis);
//Sends a Message containing only the what value, to be delivered after the specified amount of time elapses .

final boolean sendMessage(Message msg);
//Pushes a message onto the end of the message queue after all pending messages before the current time .

        Handler();
        void dispatchMessage(Message msg);
//UNUSED AND UNANNOTATED    
// final void dump(Printer pw, String prefix);
// String getMessageName(Message message);
// final boolean postAtFrontOfQueue(Runnable r);
// final void removeCallbacksAndMessages(Object token);
// final boolean sendEmptyMessageAtTime(int what, long uptimeMillis);
// final boolean sendMessageAtFrontOfQueue(Message msg);
// boolean sendMessageAtTime(Message msg, long uptimeMillis);
// final boolean sendMessageDelayed(Message msg, long delayMillis);
// String toString();
}

class PowerManager{
        @Source(FlowPermission.WAKE_LOCK) WakeLock newWakeLock(int flags, String tag);
}

class PowerManager$WakeLock{
        void acquire();
        void release();
}

class SystemClock {
//static long currentThreadTimeMillis();
//Returns milliseconds running in the current thread.

static @Source(FlowPermission.READ_TIME) long elapsedRealtime();
//Returns milliseconds since boot, including time spent in sleep.

//static long elapsedRealtimeNanos();
//Returns nanoseconds since boot, including time spent in sleep.

//static boolean setCurrentTimeMillis(long millis);
//Sets the current wall time, in milliseconds.

static void sleep(long ms);
//Waits a given number of milliseconds (of uptimeMillis); before returning.

static @Source(FlowPermission.READ_TIME) long uptimeMillis();
//Returns milliseconds since boot, not counting time spent in deep sleep.


}
class Messenger{
            Messenger(Handler target);
            IBinder getBinder();
}
class Message{
    Bundle getData();
    void sendToTarget();
}
class Process{
            static void setThreadPriority(int arg0) throws IllegalArgumentException,SecurityException;
}
class Parcelable{
            void writeToParcel(Parcel arg0, int arg1);
            int describeContents();
}
class Parcelable$Creator{
            T[] newArray(int arg0);
            T createFromParcel(Parcel arg0);
}
class Parcelable$ClassLoaderCreator{
            T createFromParcel(Parcel arg0, ClassLoader arg1);
}

class Parcel{
            <T> T readParcelable(ClassLoader loader);
            void enforceInterface(String arg0);
            <T> T[] createTypedArray(Creator<T> c);
            void writeInt(int arg0);
            int[] createIntArray();
            <T> void writeTypedArray(T[] val, int parcelableFlags);
            Bundle readBundle();
            void writeParcelable(Parcelable p, int parcelableFlags);
            void writeBundle(Bundle val);
            void writeInterfaceToken(String arg0);
            static Parcel obtain();
            Object readValue(ClassLoader loader);
            int readInt();
            String readString();
            void recycle();
            void writeIntArray(int[] val);
            void writeNoException();
            void writeValue(Object v);
            void readException();
            void writeString(String arg0);
}
