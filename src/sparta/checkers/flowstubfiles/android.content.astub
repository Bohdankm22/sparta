package android.content;

class AsyncTaskLoader {
// CSH: In spreadsheet but not in class or parents:
//dispatchOnCancelled
//dispatchOnLoadComplete
//executePendingTask

boolean cancelLoad();
//Attempt to cancel the current load task.

void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.
//CSH: FileDescriptor

abstract D loadInBackground();

void onCanceled(D data);
//Called if the task was canceled before it was completed.

//void setUpdateThrottle(long delayMS);
//Set amount to throttle updates by.

//Protected Methods
//void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

D onLoadInBackground();
//Called on a worker thread to perform the actual load.

}
class BroadcastReceiver{
            BroadcastReceiver();
            void onReceive(Context arg0, Intent arg1);
            void setResult(int code, String data, Bundle extras);
}
class ClipData{
        static ClipData newPlainText(CharSequence label, CharSequence text);
}

class ClipboardManager extends ClipboardManager {
//ClipData objects not annotated, because the class itself is annoated
//SOM
    void setPrimaryClip(ClipData arg0);
    ClipData getPrimaryClip();
    ClipDescription getPrimaryClipDescription();
    boolean hasPrimaryClip();
    void addPrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    void removePrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    @Source(READ_CLIPBOARD) CharSequence getText();
    void setText(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    boolean hasText();
}
class ClipData implements Parcelable {
    ClipData(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) String @Sink(WRITE_CLIPBOARD) [] arg1, @Sink(WRITE_CLIPBOARD) Item arg2);
    ClipData(ClipDescription arg0, @Sink(WRITE_CLIPBOARD)  Item arg1);
    static ClipData newPlainText(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1);
    static ClipData newIntent(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1);
    static ClipData newUri(@Sink(WRITE_CLIPBOARD) ContentResolver arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    static ClipData newRawUri(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Uri arg1);
    @Source(READ_CLIPBOARD) ClipDescription getDescription();
    void addItem(@Sink(WRITE_CLIPBOARD) Item arg0);
    int getItemCount();
    @Source(READ_CLIPBOARD) Item getItemAt(@Sink(WRITE_CLIPBOARD) int arg0);
    int describeContents();
    void writeToParcel(@Source(READ_CLIPBOARD) Parcel arg0, int arg1);
}
class ClipData$Item {
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    Item(@Sink(WRITE_CLIPBOARD) Intent arg0);
    Item(@Sink(WRITE_CLIPBOARD) Uri arg0);
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    @Source(READ_CLIPBOARD) CharSequence getText();
    @Source(READ_CLIPBOARD) Intent getIntent();
    @Source(READ_CLIPBOARD) Uri getUri();
    @Source(READ_CLIPBOARD) CharSequence coerceToText(@Sink(WRITE_CLIPBOARD) Context arg0);
}

class ComponentName{
        ComponentName(String pkg, String cls);
}

class ContentProvider {
    final @Source(FlowPermission.ANY) Context getContext() @Source(FlowPermission.ANY);
}

class ContentUris {
    @PolyFlow static Uri withAppendedId(Uri contentUri, long id);
}

@PolyFlowReceiver
class ContentValues {
        ContentValues();
        Set<String> keySet();
        void put(String key, String value);
        void put(String key, Integer value);
    void put(@PolySource @PolySink String key, @PolySource @PolySink Long value) @PolySource @PolySink;
}


class ContentProviderOperation{
       // static Builder newUpdate(Uri uri);
        //static Builder newInsert(Uri uri);
}

class ContentProviderOperation$Builder{
        Builder withValues(ContentValues values);
        Builder withSelection(String selection, String[] selectionArgs);
        ContentProviderOperation build();
        Builder withValue(String key, Object value);
        Builder withValueBackReference(String key, int previousResult);
}

class ContentResolver{
        //Uri insert(Uri url, ContentValues values);
        //int delete(Uri url, String where, String[] selectionArgs);
        ContentProviderResult[] applyBatch(String authority, ArrayList<ContentProviderOperation> operations) throws RemoteException,OperationApplicationException;
        //Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
        //int update(Uri uri, ContentValues values, String where, String[] selectionArgs);
}

class Context {
	@Source(FlowPermission.FILESYSTEM) File getDir( @Sink(FlowPermission.FILESYSTEM) String name,  @Sink(FlowPermission.CONDITIONAL) int mode);
	void unregisterReceiver(BroadcastReceiver arg0);

String getString(int resId, Object[] formatArgs);
 //Added by Carl Hartung
abstract ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

abstract Resources getResources();
//Return a Resources instance for your application's package.

abstract Object getSystemService(String name);
//Return the handle to a system-level service by name.

final @Source(FlowPermission.LITERAL) String getString(int resId);
//Return a localized string from the application's package's default string table.

abstract @Source(FlowPermission.LITERAL) String getPackageName();
//Return the name of this application's package.

abstract SharedPreferences getSharedPreferences(String name, int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

abstract void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

abstract void startActivity(Intent intent, Bundle options);
//Launch a new activity.

abstract PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

abstract ComponentName startService(Intent service);
//Request that a given application service be started.

abstract @Source(FlowPermission.FILESYSTEM) File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

abstract Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

abstract void sendBroadcast(Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

abstract void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

final TypedArray obtainStyledAttributes(int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(int resid, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes);
//Retrieve styled attribute information in this Context's theme.

abstract void unbindService(ServiceConnection conn);
//Disconnect from an application service.

final @Source(FlowPermission.LITERAL) CharSequence getText(int resId);
//Return a localized, styled CharSequence from the application's package's default string table.

abstract @Source(FlowPermission.FILESYSTEM) File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

abstract AssetManager getAssets();
//Return an AssetManager instance for your application's package.

abstract Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

abstract boolean stopService(Intent service);
//Request that a given application service be stopped.

abstract void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

abstract void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

abstract Looper getMainLooper();
//Return the Looper for the main thread of the current process.

abstract ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

abstract boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

abstract void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

abstract @Sink(FlowPermission.FILESYSTEM) FileOutputStream openFileOutput(String name, int mode);
//Open a private file associated with this Context's application package for writing.
//CSH: a sink on a return value seems odd. This opens a file local to the app for writing to anywhere.

abstract void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

abstract @Source(FlowPermission.FILESYSTEM) File getFileStreamPath(String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

}

class ComponentName{
            String getClassName();
}

class ContextWrapper {
            File getDir(String name, int mode);
            ContextWrapper(Context base);
            
                        String getPackageName();
            ComponentName startService(Intent service);
            PackageManager getPackageManager();
            @Source(FILESYSTEM) File getFilesDir();
            AssetManager getAssets();
            Context getApplicationContext();
            Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
            Context getBaseContext();
            void sendBroadcast(Intent intent);
            @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(String name, int mode);


//boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

//int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

//int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

//int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

//int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

//int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

//int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

//int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

//void clearWallpaper();
//This method was deprecated in API level . Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

//Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

//Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

//String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

//boolean deleteDatabase(String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

//boolean deleteFile(String name);
//Delete the given private file associated with this Context's application package.

//void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

//void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

//void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

//void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

//void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

//String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

//ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

AssetManager getAssets();
//Return an AssetManager instance for your application's package.

Context getBaseContext();

//File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

//ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

//File getDatabasePath(String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

//File getDir(String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

//File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

//File getExternalFilesDir(String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

//File getFileStreamPath(String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

//File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

//Looper getMainLooper();
//Return the Looper for the main thread of the current process.

//File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

//String getPackageCodePath();
//Return the full path to this context's primary Android package.

//PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

//String getPackageName();
//Return the name of this application's package.

//String getPackageResourcePath();
//Return the full path to this context's primary Android package.

Resources getResources();
//Return a Resources instance for your application's package.

//SharedPreferences getSharedPreferences(String name, int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolyX

//Resources.Theme getTheme();
//Return the Theme object associated with this Context.

//Drawable getWallpaper();
//This method was deprecated in API level . Use WallpaperManager.get(); instead.

//int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumHeight(); instead.

//int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumWidth(); instead.

//void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

//boolean isRestricted();
//Indicates whether this Context is restricted.

//FileInputStream openFileInput(String name);
//Open a private file associated with this Context's application package for reading.

//FileOutputStream openFileOutput(String name, int mode);
//Open a private file associated with this Context's application package for writing.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

//Drawable peekWallpaper();
//This method was deprecated in API level . Use WallpaperManager.peek(); instead.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

//void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

//void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

void sendBroadcast(@Source(FlowPermission.INTENT) Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

//void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

//void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

//void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

//void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

//void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void setTheme(int resid);
//Set the base theme for this context.

//void setWallpaper(Bitmap bitmap);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void setWallpaper(InputStream data);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

//void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

void startActivity(@Source(FlowPermission.INTENT) Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

//void startActivity(Intent intent, Bundle options);
//Launch a new activity.

//boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

ComponentName startService(@Source(FlowPermission.INTENT) Intent service);
//Request that a given application service be started.

//boolean stopService(Intent name);
//Request that a given application service be stopped.

//void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

//Protected Methods
//void attachBaseContext(Context base);
//Set the base context for this ContextWrapper.

}


class CursorLoader {
    
//CSH: found in spreadsheet, not in API:
//registerContentObserver


void deliverResult(Cursor cursor);
//Sends the result of the load to the registered listener.

//void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

//String[] getProjection();

//String getSelection();

//String[] getSelectionArgs();

//String getSortOrder();

//Uri getUri();

Cursor loadInBackground();

void onCanceled(Cursor cursor);
//Called if the task was canceled before it was completed.

//void setProjection(String[] projection);

//void setSelection(String selection);

//void setSelectionArgs(String[] selectionArgs);

//void setSortOrder(String sortOrder);

//void setUri(Uri uri);

//Protected Methods
//void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

//void onStartLoading();
//Starts an asynchronous load of the contacts list data.

void onStopLoading();
//Must be called from the UI thread
}

class DialogInterface{
        void dismiss();
        void cancel();
}

class DialogInterface$OnClickListener{
        void onClick(DialogInterface arg0, int arg1);
}
class DialogInterface$OnKeyListener{
        boolean onKey(DialogInterface arg0, int arg1, KeyEvent arg2);
}

class DialogInterface$OnMultiChoiceClickListener{
            void onClick(DialogInterface arg0, int arg1, boolean arg2);
}
class IntentFilter{
            IntentFilter(String action);
             IntentFilter();
            void addAction(String action);
            void addCategory(String category);
}


class Intent implements Parcelable, Cloneable {
//SOM, We have a special FlowPermission for INTENTS
  
    Intent();
    Intent(@Sink(INTENT) Intent arg0);
    Intent(@Sink(INTENT)  String arg0);
    Intent(@Sink(INTENT) String arg0, @Sink(INTENT)  Uri arg1);
    Intent(@Sink(INTENT) Context arg0, @Sink(INTENT) Class<?> arg1);
    Intent(@Sink(INTENT) String arg0, @Sink(INTENT) Uri arg1, @Sink(INTENT)  Context arg2,@Sink(INTENT)  Class<?> arg3);
   @Source(INTENT) static Intent createChooser(@Sink(INTENT) Intent arg0, @Sink(INTENT) CharSequence arg1);
    Object clone();
   @Source(INTENT)  Intent cloneFilter();
    static Intent makeMainActivity(@Sink(INTENT) ComponentName arg0);
    static Intent makeMainSelectorActivity(@Sink(INTENT) String arg0,@Sink(INTENT)  String arg1);
    static Intent makeRestartActivityTask(@Sink(INTENT) ComponentName arg0);
    static Intent getIntent(@Sink(INTENT) String arg0) throws URISyntaxException;
    static Intent parseUri(@Sink(INTENT) String arg0, int arg1) throws URISyntaxException;
    static Intent getIntentOld(@Sink(INTENT) String arg0) throws URISyntaxException;
    @Source(INTENT) String getAction();
     @Source(INTENT) Uri getData();
     @Source(INTENT) String getDataString();
    @Source(INTENT) String getScheme();
    @Source(INTENT) String getType();
    @Source(INTENT) String resolveType(@Sink(INTENT) Context arg0);
    @Source(INTENT) String resolveType(@Sink(INTENT) ContentResolver arg0);
    @Source(INTENT) String resolveTypeIfNeeded(@Sink(INTENT) ContentResolver arg0);
    @Source(INTENT) boolean hasCategory(@Sink(INTENT) String arg0);
    @Source(INTENT) Set<@Source(INTENT) String> getCategories();
    Intent getSelector();
    void setExtrasClassLoader(@Sink(INTENT) ClassLoader arg0);
    @Source(INTENT) boolean hasExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  boolean hasFileDescriptors();
    @Source(INTENT) boolean getBooleanExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    @Source(INTENT) byte getByteExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    @Source(INTENT) short getShortExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    @Source(INTENT) char getCharExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
   @Source(INTENT)  int getIntExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    @Source(INTENT) long getLongExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    @Source(INTENT) float getFloatExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    @Source(INTENT) double getDoubleExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    @Source(INTENT) String getStringExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) CharSequence getCharSequenceExtra(@Sink(INTENT) String arg0);
    <T> T getParcelableExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) Parcelable[] getParcelableArrayExtra(@Sink(INTENT) String arg0);
    <T> ArrayList<T> getParcelableArrayListExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) Serializable getSerializableExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) Integer> getIntegerArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) String> getStringArrayListExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) ArrayList< @Source(INTENT) CharSequence> getCharSequenceArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) boolean @Source(INTENT) [] getBooleanArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) byte @Source(INTENT) [] getByteArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) short @Source(INTENT) [] getShortArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  char @Source(INTENT) [] getCharArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) int @Source(INTENT) [] getIntArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  long @Source(INTENT) [] getLongArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  float @Source(INTENT) [] getFloatArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  double @Source(INTENT) [] getDoubleArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  String @Source(INTENT) [] getStringArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   CharSequence @Source(INTENT) [] getCharSequenceArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  Bundle getBundleExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   Bundle getExtras();
    @Source(INTENT)  int getFlags();
    @Source(INTENT)  String getPackage();
    @Source(INTENT)  ComponentName getComponent();
    @Source(INTENT)  Rect getSourceBounds();
    @Source(INTENT)  ComponentName resolveActivity(@Sink(INTENT) PackageManager arg0);
    @Source(INTENT)  ActivityInfo resolveActivityInfo(@Sink(INTENT) PackageManager arg0, int arg1);
    Intent setAction(@Sink(INTENT) String arg0);
    Intent setData(@Sink(INTENT) Uri arg0);
    Intent setType(@Sink(INTENT) String arg0);
    Intent setDataAndType(@Sink(INTENT) Uri arg0, @Sink(INTENT) String arg1);
    Intent addCategory(@Sink(INTENT) String arg0);
    void removeCategory(@Sink(INTENT) String arg0);
    void setSelector(@Sink(INTENT) Intent arg0);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  CharSequence arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable[] arg1);
    Intent putParcelableArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<? extends Parcelable> arg1);
    Intent putIntegerArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) Integer> arg1);
    Intent putStringArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) String> arg1);
    Intent putCharSequenceArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) CharSequence> arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Serializable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  char @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) CharSequence @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Bundle arg1);
    Intent putExtras(@Sink(INTENT) Intent arg0);
    Intent putExtras( @Sink(INTENT) Bundle arg0);
    Intent replaceExtras( @Sink(INTENT) Intent arg0);
    Intent replaceExtras( @Sink(INTENT) Bundle arg0);
    void removeExtra( @Sink(INTENT) String arg0);
    Intent setFlags( @Sink(INTENT) int arg0);
    Intent addFlags( @Sink(INTENT) int arg0);
    Intent setPackage( @Sink(INTENT) String arg0);
    Intent setComponent( @Sink(INTENT) ComponentName arg0);
    Intent setClassName( @Sink(INTENT) Context arg0,  @Sink(INTENT) String arg1);
    Intent setClassName( @Sink(INTENT) String arg0,  @Sink(INTENT) String arg1);
    Intent setClass( @Sink(INTENT) Context arg0,  @Sink(INTENT) Class<?> arg1);
    void setSourceBounds( @Sink(INTENT) Rect arg0);
    @Source(INTENT)  int fillIn( @Sink(INTENT) Intent arg0,  @Sink(INTENT) int arg1);
    @Source(INTENT)  boolean filterEquals( @Sink(INTENT) Intent arg0);
     @Source(INTENT) int filterHashCode();
    @Source(INTENT)  String toString();
     @Source(INTENT) String toURI();
    @Source(INTENT)  String toUri( @Sink(INTENT) int arg0);
    @Source(INTENT)  int describeContents();
    void writeToParcel( @Sink(INTENT) Parcel arg0,  @Sink(INTENT) int arg1);
    void readFromParcel( @Sink(INTENT) Parcel arg0);
    static Intent parseIntent( @Sink(INTENT) Resources arg0, @Sink(INTENT)  XmlPullParser arg1,  @Sink(INTENT) AttributeSet arg2) throws XmlPullParserException,IOException;
}

class Loader {
    
void abandon();
//Tell the Loader that it is being abandoned.

String dataToString(D data);
//For debugging, converts an instance of the Loader's data class to a string that can be printed.

void deliverResult(D data);
//Sends the result of the load to the registered listener.

void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.
//CSH: filedescriptor

void forceLoad();
//Force an asynchronous load.

Context getContext();

//int getId();

boolean isAbandoned();
//Return whether this loader has been abandoned.

boolean isReset();
//Return whether this load has been reset.

boolean isStarted();
//Return whether this load has been started.

void onContentChanged();
//Called when Loader.ForceLoadContentObserver detects a change.

void registerListener(int id, OnLoadCompleteListener<D> listener);
//Registers a class that will receive callbacks when a load is complete.

void reset();
//Resets the state of the Loader.

final void startLoading();
//Starts an asynchronous load of the Loader's data.

void stopLoading();
//Stops delivery of updates until the next time startLoading(); is called.

boolean takeContentChanged();
//Take the current flag indicating whether the loader's content had changed while it was stopped.

//String toString();
//Returns a string containing a concise, human-readable description of this object.

void unregisterListener(OnLoadCompleteListener<D> listener);
//Remove a listener that was previously added with registerListener(int, Loader.OnLoadCompleteListener);.


//Protected Methods
void onAbandon();
//Subclasses implement this to take care of being abandoned.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

void onStartLoading();
//Subclasses must implement this to take care of loading their data, as per startLoading();.

void onStopLoading();
//Subclasses must implement this to take care of stopping their loader, as per stopLoading();.



}

class UriMatcher {
    void addURI(@PolySource @PolySink String authority, @PolySource @PolySink String path, @PolySource @PolySink int code) @PolySource @PolySink;
    @PolyFlow int match(Uri uri);
    @Source(FlowPermission.INTENT) UriMatcher(@Source(FlowPermission.LITERAL) @Sink({}) int code);
    @Source(FlowPermission.INTENT) Uri getData();
}


class SharedPreferences {
    
abstract @Source(FlowPermission.SHARED_PREFERENCES) boolean getBoolean(String key, boolean defValue);
//Retrieve a boolean value from the preferences.

abstract @Source(FlowPermission.SHARED_PREFERENCES) String getString(String key, String defValue);
//Retrieve a String value from the preferences.

abstract SharedPreferences.Editor edit();
//Create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.

abstract @Source(FlowPermission.SHARED_PREFERENCES) long getLong(String key, long defValue);
//Retrieve a long value from the preferences.

abstract @Source(FlowPermission.SHARED_PREFERENCES) int getInt(String key, int defValue);
//Retrieve an int value from the preferences.

abstract void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Registers a callback to be invoked when a change happens to a preference.

abstract Map<String, ?> getAll();
//Retrieve all values from the preferences.


//UNUSED AND UNANNOTATED
// abstract boolean contains(String key);
// abstract float getFloat(String key, float defValue);
// abstract Set<String> getStringSet(String key, Set<String> defValues);
// abstract void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
}

class SharedPreferences$Editor{
        Editor putBoolean(@Sink(SHARED_PREFERENCES) String arg0, @Sink(SHARED_PREFERENCES) boolean arg1);

        boolean commit();

            Editor putString(@Sink(SHARED_PREFERENCES) String arg0, @Sink(SHARED_PREFERENCES) String arg1);

        Editor putLong(String arg0, @Sink(FlowPermission.SHARED_PREFERENCES) long arg1);
        Editor putInt(String arg0, @Sink(FlowPermission.SHARED_PREFERENCES) int arg1);
}

package android.content.pm;
class PackageManager{
        List<ResolveInfo> queryBroadcastReceivers(@Source(FlowPermission.INTENT) Intent arg0, int arg1);
        PackageInfo getPackageInfo(String arg0, int arg1) throws NameNotFoundException;
        PermissionInfo getPermissionInfo(String arg0, int arg1) throws NameNotFoundException;
}

package android.content.res;

class AssetManager{
            @Source(ANY) InputStream open(String fileName) throws IOException;

}

class ColorStateList{
        int getDefaultColor();
}

class Resources {
//CSH: All of the objects returned by this class are pre-defined by the developer and compiled into the.apk
    
@Source(FlowPermission.LITERAL) CharSequence getText(int id, CharSequence def);
//Return the string value associated with a particular resource ID.

@Source(FlowPermission.LITERAL) CharSequence getText(int id);
//Return the string value associated with a particular resource ID. The returned object will be a String if this is a plain string; it will be some other type of CharSequence if it is styled.

@Source(FlowPermission.LITERAL) String getString(int id);
//Return the string value associated with a particular resource ID. It will be stripped of any styled text information.

@Source(FlowPermission.LITERAL) String getString(int id, Object... formatArgs);
//Return the string value associated with a particular resource ID, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

DisplayMetrics getDisplayMetrics();
//Return the current display metrics that are in effect for this resource object.

@Source(FlowPermission.LITERAL) Drawable getDrawable(int id);
//Return a drawable object associated with a particular resource ID.

@Source(FlowPermission.LITERAL) int getIdentifier(String name, String defType, String defPackage);
//Return a resource identifier for the given resource name.

XmlResourceParser getXml(int id);
//Return an XmlResourceParser through which you can read a generic XML resource for the given resource ID.

Configuration getConfiguration();
//Return the current configuration that is in effect for this resource object.

InputStream openRawResource(int id, TypedValue value);
//Open a data stream for reading a raw resource.

static Resources getSystem();
//Return a global shared Resources object that provides access to only system resources (no application resources);, and is not configured for the current screen (can not use dimension units, does not change based on orientation, etc);.

TypedArray obtainAttributes(AttributeSet set, int[] attrs);
//Retrieve a set of basic attribute values from an AttributeSet, not performing styling of them using a theme and/or style resources.

void getValue(String name, @Source(FlowPermission.LITERAL) TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValue(int id, @Source(FlowPermission.LITERAL) TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

@Source(FlowPermission.LITERAL) String getQuantityString(int id, int quantity);
//Return the string value associated with a particular resource ID for a particular numerical quantity.

@Source(FlowPermission.LITERAL) String getQuantityString(int id, int quantity, Object... formatArgs);
//Return the string value associated with a particular resource ID for a particular numerical quantity, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

int getColor(int id);
//Return a color integer associated with a particular resource ID.

@Source(FlowPermission.LITERAL) String[] getStringArray(int id);
//Return the string array associated with a particular resource ID.

@Source(FlowPermission.LITERAL) String getResourceTypeName(int resid);
//Return the type name for a given resource identifier.

@Source(FlowPermission.LITERAL) String getResourcePackageName(int resid);
//Return the package name for a given resource identifier.

@Source(FlowPermission.LITERAL) String getResourceName(int resid);
//Return the full name for a given resource identifier.

@Source(FlowPermission.LITERAL) String getResourceEntryName(int resid);
//Return the entry name for a given resource identifier.

@Source(FlowPermission.LITERAL) int getInteger(int id);
//Return an integer associated with a particular resource ID.

 
//UNUSED and UNANNOTATED
// final void finishPreloading();
// final void flushLayoutCache();
// XmlResourceParser getAnimation(int id);
// final AssetManager getAssets();
// boolean getBoolean(int id);
// ColorStateList getColorStateList(int id);
// float getDimension(int id);
// int getDimensionPixelOffset(int id);
// int getDimensionPixelSize(int id);
// Drawable getDrawableForDensity(int id, int density);
// float getFraction(int id, int base, int pbase);
// int[] getIntArray(int id);
// XmlResourceParser getLayout(int id);
// Movie getMovie(int id);
// CharSequence getQuantityText(int id, int quantity);
// CharSequence[] getTextArray(int id);
// void getValueForDensity(int id, int density, TypedValue outValue, boolean resolveRefs);
// final Resources.Theme newTheme();
// TypedArray obtainTypedArray(int id);
// InputStream openRawResource(int id);
// AssetFileDescriptor openRawResourceFd(int id);
// void parseBundleExtra(String tagName, AttributeSet attrs, Bundle outBundle);
// void parseBundleExtras(XmlResourceParser parser, Bundle outBundle);
// void updateConfiguration(Configuration config, DisplayMetrics metrics);
}

class TypedArray {
    
boolean getBoolean(int index, boolean defValue);
//Retrieve the boolean value for the attribute at index.

int getColor(int index, int defValue);
//Retrieve the color value for the attribute at index.

//ColorStateList getColorStateList(int index);
//Retrieve the ColorStateList for the attribute at index.

//float getDimension(int index, float defValue);
//Retrieve a dimensional unit attribute at index.

//int getDimensionPixelOffset(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as an offset in raw pixels.

int getDimensionPixelSize(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as a size in raw pixels.

//Drawable getDrawable(int index);
//Retrieve the Drawable for the attribute at index.

float getFloat(int index, float defValue);
//Retrieve the float value for the attribute at index.

//float getFraction(int index, int base, int pbase, float defValue);
//Retrieve a fractional unit attribute at index.

//int getIndex(int at);
//Return an index in the array that has data.

//int getIndexCount();
//Return the number of indices in the array that actually have data.

int getInt(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getInteger(int index, int defValue);
//Retrieve the integer value for the attribute at index.

//int getLayoutDimension(int index, String name);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

//int getLayoutDimension(int index, int defValue);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

//String getNonResourceString(int index);
//Retrieve the string value for the attribute at index, but only if that string comes from an immediate value in an XML file.

//String getPositionDescription();
//Returns a message about the parser state suitable for printing error messages.

int getResourceId(int index, int defValue);
//Retrieve the resource identifier for the attribute at index.

//Resources getResources();
//Return the Resources object this array was loaded from.

String getString(int index);
//Retrieve the string value for the attribute at index.

//CharSequence getText(int index);
//Retrieve the styled string value for the attribute at index.

//CharSequence[] getTextArray(int index);
//Retrieve the CharSequence[] for the attribute at index.

//boolean getValue(int index, TypedValue outValue);
//Retrieve the raw TypedValue for the attribute at index.

boolean hasValue(int index);
//Determines whether there is an attribute at index.

//int length();
//Return the number of values in this array.

//TypedValue peekValue(int index);
//Retrieve the raw TypedValue for the attribute at index and return a temporary object holding its data.

void recycle();
//Give back a previously retrieved array, for later re-use.

//String toString();
//Returns a string containing a concise, human-readable description of this object.


}


package android.content.pm;
class PackageManager{
            PackageInfo getPackageInfo(String arg0, int arg1) throws NameNotFoundException;
            List<ResolveInfo> queryIntentActivities(Intent arg0, int arg1);
            boolean hasSystemFeature(String arg0);
            ResolveInfo resolveActivity(Intent arg0, int arg1);
}
class Signature{
            String toCharsString();
}


